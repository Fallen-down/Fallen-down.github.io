{"pages":[],"posts":[{"title":"关于博客","text":"为什么写博客写博客的目的，我有以下几点：1、我本人记忆力极差，学过的知识，看过的视频，音频，书籍，文章很快就忘记了，看的时候觉得有用，转身就忘记了，我希望以博客的形式记录生活中，学习中有用的知识和学习方法。2、锻炼讲故事的能力。当我向别人讲述我看过影视、视频、文章、书籍时，我的讲述往往是碎片化的，没有主线式的，我记得我看过一部美剧《权利的游戏》（冰与火之歌）在向同学讲述第一季的时候，我发现自己很难完整的讲完这个故事，不单单是因为我的记忆力的责任。3、资源整合。我期望把我平时的学习过程记录下来，筛选我看过的视频，文章，书籍中有用的知识点进行整合。4、记录。电脑不行了，电脑配置 CPU i5-6200U 内存 8G ，平时用浏览器多个看几个标签页都会有明显卡顿，然后再运行 一两个代码编辑器，基本上 CPU 和 内存 拉满。我之前已经重装过 N 次系统了，导致一部分文件丢失，重要的是我的 学习资料和老师的授课视频这让我很难受。我决定把我的学习视频和资料上传到 B 站上用于存储。然后用博客记录视频、文章的学习重点和方法。5、我希望我的博客能让任何不懂技术的人看懂，并且一步步做出属于自己的应用。 博客分类我最初打算分两大类：学习和生活。然后再细分下去。 博客内容博客的内容很大程度来源于网络，但是我会尽力标明出处。我只是文章，视频，书籍的搬用工和整理工。因为我自身知识水平有限等各方面有限，所以导致我无法创作出有质量，有内容的文章、博客，视频，但是我会努力学习相关知识，尽力弥补我的知识等各方面的短板，然后创作出属于自己的文章，博客，视频。 博客体系我计划学习某个技能，从视频、书籍、官方文档、实战项目、文章、博客、公司企业实际开发这几个方面来形成一个体系。但是就目前来看很难做到这个体系，我打算先从视频，文章开始扫一遍。 博客更新最近发现自己的战线过于分散也过于长，导致我经历不足。所以我决定博客每周最多更新 2 篇，以保证博客的质量和我的学习经历。 之前挖过好多坑，要填。脑子想的挺好，规划的也挺好，做起来发现没有预期的那么顺利，好多博客，我计划着整一个系列，学习视频引导，书籍补差遗漏点，官网补差遗漏点，文章提升技巧和问题解决答案。可是做起来真实是视频学着学着累了不学了，一天过去了。 奈何企业要求多，这个要会那个要会。实属无奈。覆盖面广必然导致点面无法完全精通，覆盖面窄，必然导致选择的企业少。 学的知识越多，可供选择的企业也就越多。成功就业的几率就会增大？？学的知识越少，可供选择的企业越少，成功的就业几率会减小？？ 博客规范随着学习和工作的深入，写得博客也变得多了起来，为了更多人方便看我的博客，也为了让自己更好读每篇写完的博客。 单个知识点用：article汇总：learning完成： 1&lt;font color=#67C23A&gt;√&lt;/font&gt; 显示更多： 1&lt;!-- more --&gt; 警告注意： 1&lt;font color=#ffc107&gt;&lt;/font&gt; 错误终止： 1&lt;font color=#DC3545&gt;&lt;/font&gt; 视频： 1[视频][视频名称](视频地址) 对话机制感谢你能浏览我的博客，如果有什么好的建议或意见或者遇到什么问题？都可以在我公众号留言进行学习交流或沟通。 我的公众号：散装程序员我的B站账号：黑色的眼睛 建议在 B 站留言或者直接私信我，你也可以关注我防止丢失。 相关工具图床图片压缩pdf转图片","link":"/2020/03/09/About-blog/"},{"title":"文集","text":"封面图片出处Pexels 上的 Nadia Lindsay 拍摄的照片","link":"/2019/12/27/Article-collection-2/"},{"title":"2019 web 大事件 回顾","text":"前端框架排行榜 React (NPM 下载量、NPM 使用量) jQuery Angular Vue WebAssembly 成为第四种 web 语言。 Typescript 激增 React hooks 成为开发首选。 Vue3.0 开放部分代码 开发工具 IDE VSCode 成为了绝对的主流 Webpack 已经迭代到 5.0 即将发行 容器和微服务向前端靠拢 （docker） 以上是我对下列视频及文章的归纳和总结。2019年前端大事回顾","link":"/2019/12/17/Blog-about-industry-1/"},{"title":"文集","text":"封面图片出处Pexels 上的 Nadia Lindsay 拍摄的照片 故事的开头总是这样，适逢其会，猝不及防。故事的结局总是这样，花开两朵，天各一方。 — 张嘉佳《从你的全世界路过》 文学是最徒劳的，且是滑稽的徒劳。写这么多，我不能拯救任何人，甚至不能拯救自己。这么多年，我写这么多，我还不如拿把刀冲进去杀了他。真的。 — 林奕含《房思琪的初恋乐园》 某天，你会无端想起一个人，她曾让你对明天有所期许，却再也没有出现在你的明天里。 — 电影《再见，金华站》 后来我终于知道，它并不是我的花，我只是恰好途经了它的盛放。 — 电影《东邪西毒》 What can I hold you with?I offer you lean streets, desperate sunsets, the moon of the jagged suburbs.I offer you the bitterness of a man who has looked long and long at the lonely moon. 我用什么才能留住你？我给你贫穷的街道、绝望的日落、破败郊区的月亮。我给你一个久久地望着孤月的人的悲哀。 — 博尔赫斯《我拿什么才能留住你》 人生那个东西，也许只是在一段刻骨铭心之后才算是真正的开始，但有时想想，徒留遗憾罢了。 — 《大鼻子情圣》 无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。 — 《百年孤独》加西亚·马尔克斯 在这个世界上，没有人真正可以对另一个人的伤痛感同身受。你万箭穿心，你痛不欲生，也仅仅是你一个人的事，别人也许会同情，也许会嗟叹，但永远不会清楚你伤口究竟溃烂到何种境地。 — 余秋雨 你知道吗？风往哪个方向吹，草就要往那个方向倒。年轻的时候，我也曾经以为自己是风，可是最后遍体鳞伤，我才知道，原来我们都是草。 — 《艋舺》 她一次都没有回头。 — 东野圭吾《白夜行》 那一刻，你心里有场海啸，可你静静地，没有让任何人知道。 — 独木舟 — 葛婉仪 我曾以为你和那些神佛不一样。曾经是不一样的。 — 《悟空传》 长日尽处，我站在你的面前，你将看到我的伤痕，知道我曾经受伤，也曾经痊愈。 — 泰戈尔《飞鸟集》 终有一日，你我各结亲，一妻二妾三四儿女，五六年间，沧海桑田，历历过往七八皆成旧梦，剩余二三不过年少轻狂，老来相忆，空作笑谈。 -《贺新郎》 — 公子欢喜 我仰望阳光，却感觉到自己向着巨大的深渊坠落。 — 江南《龙与少年游》 以上是我对该视频的归纳和总结。 记忆的梗上，谁不有两三朵娉婷，披着情绪的花。 — 林徽因《你是那人间的四月天》 旁观者眼里的悲剧未必是受难者心中的悲剧。 — 爱默生 War does not determine who is right only who is left。战争不决定谁是对了，只决定谁留下了。 — 罗素 你以为我会无足轻重的留在这里吗？你以为我是一架没有感情的机器人吗？你以为我贫穷、低微、不美、渺小，我就没有灵魂，没有心吗？你想错了，我和你有一样多的灵魂，一样充实的心。如果上帝赐予我一点美，许多钱，我就要你难以离开我，就像我现在难以离开你一样。我现在不是以社会生活和习俗的准则和你说话，而是我的心灵同你的心灵讲话。 — 夏洛蒂·勃朗特《简·爱》 忧郁是因为自己无能，烦恼是由于欲望得不到满足，暴躁是一种虚怯的表现。 — 大仲马《三个火枪手》 少关心别人的逸闻私事，多留意别人的思路观点。 — 居里夫人 与其用华丽的外衣装饰自己，不如用知识武装自己。 — 马克思 每个人都会有缺陷，就像被上帝咬过的苹果，有的人缺陷比较大，正是因为上帝特别喜欢他的芬芳。 — 列夫·托尔斯泰《战争与和平》 No snowflake in an avalanche ever feels responsible.雪崩时，没有一片雪花觉得自己有责任。 — 斯坦尼斯罗 《More Unkempt Thoughts》 没有比脚更长的路，没有比人更高的山。 — 汪国真《山高路远》 人生并非只有一处，缤纷烂漫，那凋零的是花，不是春天。 — 汪国真 那时我们有梦，关于文学，关于爱情，关于穿越世界的旅行。如今我们深夜饮酒，杯子碰到一起，都是梦破碎的声音。 — 北岛《波兰来客》 你以为的极限，弄不好只是别人的起点 — 韩寒《告白与告别》 学习文史知识目的在于“温故”，有文史修养的人生活在从过去到现在一个漫长的时间段里。学习科学知识目的在于“知新”有科学知识的人可以预见将来，他生活在从现在到广阔无垠的未来。假如你什么都不学习，那就只能生活在现时现世的一个小圈子里，狭窄得很。 — 王小波《思维得乐趣》 一个人知道自己为什么而活，就可以忍受任何一种生活。 — 尼采 谁终将声震人间，必长久深自缄默；谁中将点燃闪电，必长久如云漂泊； — 尼采《尼采诗集》 将无法实现之事付诸实现正是非凡毅力的真正的标志。 — 茨威格《人类群星闪耀时》 一个民族的自大和自卑都是源于对于本民族历史文化的无知，只有了解自己的过去，才能站在客观的立场上，产生深层的民族自尊。 — 梁思成 心小了，所有的小事就大了；心大了，所有的大事都小了；看淡世事沧桑，内心安然无恙。 — 丰子恺 无目的读书是散步而不是学习。 — 胡适 以上是我对该视频的归纳和总结。 你终究会成为你正在成为的人。 — 毛姆 你那么憎恨那些人，和他们斗了那么久，最终却要变得和他们一样，人世间没有任何理想值得以这样的沉沦作为代价。 — 马尔克斯 但愿每次回忆，对生活都不感到负疚。 — 郭小川 在人世间有一种庸俗势力的大合唱，谁一旦对它屈服，就永远沉沦了。 — 王小波 当泪的潮涌渐渐退远，理想的岛屿就会浮现。 — 顾城 在隆冬，我终于知道，在我身上有一个不可战胜的夏天。 — 阿尔贝·加缪 只有流过血的手指，才能弹出世间的绝唱。 — 泰戈尔 所谓无底深渊，下去，也是前程万里 — 木心 你一直希望自己勇敢而真实，那么现在做个深呼吸，用猛烈的孤独，开始你伟大的历险。 — 莱昂纳德·科恩 我要和生活再死磕几年，要么我就毁灭，要么我就注定铸就辉煌。如果有一天，你发现我在平庸面前低了头，请向我开炮。 — 凯鲁亚克 让自己的内心藏着一条巨龙，既是一种苦刑，也是一种乐趣。 — 维克多·雨果 无论怎么样，一个人借故坠落总是不值得原谅的，越是没有人爱，越要爱自己。 — 亦舒 世界上有太多孤独的人害怕先踏出第一步。 — 《绿皮书》 以上是我对该视频的归纳和总结。 愿为西南风，长逝入君怀。 — 曹植《明月上高楼》 生当复来归，死当长相思 — 苏轼《留别妻》 思君如流水，何有穷已时。 — 徐千《室思》 晓看天色暮看云，行也思君，坐也思君。 — 唐寅《一剪梅·雨打梨花深闭门》 腰中双绮带，梦为同心结。 — 萧衍《有所思》 忆君心似西江水，日夜东流无歇时。 — 鱼玄机《江陵愁望寄子安》 若似月轮终皎洁，不辞冰雪为卿热。 — 纳兰性德《蝴蝶花·辛苦最怜天上月》 愿在夜而为烛，照玉容于两楹。 — 陶渊明《闲情赋》 既见君子，云胡不喜？ — 《诗经》《国风·郑风·风雨》 思君令人老，岁月忽已晚。 — 佚名《行行重行行》 人道海水深，不抵相思半。海水尚有涯，相伴渺无畔。 — 李冶《相思怨》 愿身能似月亭亭，千里伴君行。 — 张先《江南柳·隋堤远》 寻常百种花齐放，偏摘梨花与白人。 — 元稹 南风知我意，吹梦到西洲。 — 佚名《西洲曲》 兰有秀兮菊有芳，怀佳人兮不能忘。 — 刘彻《秋风辞》 愿得一人心，白头不相离。 — 卓文君《白头吟》 以上是我对该视频的归纳和总结。 不存在十全十美的文章，如同不存在彻头彻尾的绝望。 —《且听风吟》 每个人都有属于自己的一片森林，也许我们从来不曾去过，但它一直在那里，总会在那里。迷失的人迷失了，相逢的人会再相逢。 —《挪威的森林》 死并非生的对立面，而作为生的一部分永存。 —《挪威的森林》 孤独一个人也没关系，只要能发自内心的爱着一个人，人生就会有救，哪怕不能和他生活在一起。 —《1Q84》 哪有人会喜欢孤独，只是害怕失望罢了。—《挪威的森林》 不会忘记的永远不会忘记，会忘记的留着也没有用！—《挪威的森林》 少年时我们追求激情，成熟后却迷恋平庸，在我们寻找，伤害，背离之后，还能一如既往的相信爱情，这是一种勇气。—《挪威的森林》 当你穿过了暴风雨，你就不再是原来的那个人。—《海边的卡夫卡》 在某种情况下，一个人的存在本身就是要伤害另一个人。—《国境以南 太阳以西》 人这东西真是不可思议，一瞬之间就长了好多岁。莫名其妙！过去我还以为人是一年一年按部就班地增长岁数的。但不是那样，人是一瞬间长大变老的。—《舞舞舞》 所谓人生便是这么个东西，一如植物的种子被不期而遇的风吹走，我们都在偶然的大地上彷徨。—《遇到百分之百的女孩》 有生以来，我从没有无条件地爱过一个人，从没有产生过为了谁可以抛弃一切的心情，连一次都没有。—《1Q84》 我闭目静止不动。我感觉得出，酒精正在体内缓缓的来回运行。我解开鞋带，脱去衣服，钻进被子。我似乎比自己感觉到的要疲劳的多，沉醉的多。我等待身旁的女孩说一声：喂，有点喝多了！但谁也没有说。我只身一人。—《舞舞舞》 我不愿意从这世界消失。闭上眼睛，我可以真切地感觉到自己的新在摇摆。那是超越悲哀和孤独的、从根本上撼动我自身存在的大起大浮。起伏经久不息。我把胳膊搭在椅背，忍受这种起伏。谁都不救我，谁都救不了我，正像我救不了任何人一样。—《世界尽头与冷酷仙境》 刚刚好，看见你幸福的样子，于是幸福着你的幸福。—《国境以南 太阳以西》 我的人生是我的，你的人生是你的。只要你清楚自己在寻求什么，那就尽管按自己的意愿去生活。别人怎么说与你无关。 —《舞舞舞》 平庸这东西犹如白衬衣上的无痕，一旦染上便永远洗不掉，无可挽回。 —《舞舞舞》 不必太纠结于当下，也不必太忧虑未来，当你经历过一些事情的时候，眼前的风景已经和从前不一样了。 —《1Q84》 以上是我对该视频的归纳和总结。 人生真是讽刺，一个人竟然可以变成自己曾经最讨厌的样子。 —《流浪记》热评 不要企图窥探我的生活，你能看见的，都是我想让你看见的。 —《Valley Of The End》热评 我真不知怎么才能和你亲近起来，你好像是一个可望不可及的目标，我琢磨不透，追也追不上，就坐下哭了起来。 —《Yellow》热评 他看着护士抱着我从产房出来，那时我哭着，他笑着；我看着他睡进棺材，这时我哭着，他不再理我。 —《父亲》热评 暗恋的故事里唯一尴尬的是，你拼命喜欢他爱听的歌，追他提起过的剧，却不知道他是因为喜欢谁而喜欢这些。 —《停格》热评 开了几十上百瓶的谢谢惠顾，终于有一天开出了再来一瓶，却发现活动已经过期好久了。 —《趁早》热评 一气之下就立刻摔门而走这种任性的行为，大概只有被爱的人才有资格这么做吧。我外婆家养了一条黑色的土狗，平时就是吃剩饭，不管春夏秋冬晚上睡觉锁在门外，没有人当它是一条宠物狗，也不会温柔的抚摸它，但是白天解开链子的时候，它没有一次逃脱过，我想它一定害怕离开了，也不会有任何人找它。 —《全世界谁聆听你》热评 高一那年，我室友第一次听到了她的歌，便跟我说非要娶了这个女孩。我跟他说，等你长大了也许连她的名字都会忘记吧。几年了，毕业后就再也没跟他联系。直到前几天，他跟我发了一段消息，他说，他好像永远也结不了婚了。我想了很久，什么也不敢回，我怕弄疼的不仅仅是他的青春。— 本兮《海誓山盟亦会分开》热评 这世界上根本就不会有感同身受这种事情如果有你有很多话就不会说出口。 —《或许你是对的》热评 我自问这辈子没做过坏事，为什么要被生活勒住喉咙。爸爸在日记里写到。 —《父亲写的散文诗》热评 你不愿意种花,你说，我不愿看见它一点点凋落。是的，为了避免结束，你避免了一切的开始。 —《Missing》热评 如果我被众人推到了，你记得也推我一把，别因为我而挨骂。 —《不找了》热评 其实一个人挺好的，我是说如果你不去矫情的话。 —《你看不见》热评 以上是我对该视频的归纳和总结。 现在哪有什么纯绿茶，大家都是混合饮料。 — 赵英男《奇葩说》 你以为我心中没有远方？不是，我缺的是去远方的那张车票。 — 李思恒《奇葩说》 因为那使我悲伤的，都是我曾经热爱过的一切。 — 詹青云《奇葩说》 我们只是累了，后来就算了。 — 蔡康永《奇葩说》 使唐僧成为唐僧的，不是经书，是那条取经的路。 — 詹青云《奇葩说》 被误会是表达者的宿命，我们没有什么可抱怨的。 — 马东《奇葩说》 我喜欢酒，是因为酒让平日怯懦的人勇敢。 — 姜思达《奇葩说》 被误解是表达者的宿命，不随便误解是聆听者的本分。 — 杨奇函《奇葩说》 没有人能够豁免于任何人的眼光，真正的接纳自己。 — 蔡康永《奇葩说》 其实你不管到哪个城市，都是在寻找自己最熟悉的生活方式。 — 肖骁《奇葩说》 我不想做一个被挑选的人，我想做一个被需要的人。 — 詹青云《奇葩说》 一旦你从心里接纳了自己的弱点，就再也没有人可以用这个事情伤害你。 — 庞颖《奇葩说》 以上是我对该视频的归纳和总结。 人生不能过的太圆满 求而不得未必是遗憾 人表达的永远不是他所说的内容，而是渴望被理解的心情。 —《撒野》热评 我没法留下你，所以我只能努力放下你，如果是没结果的事，我放弃你，你一路顺风。 —《尝试温柔》热评 我拦不住要走的风，也抱不住要走的你，单身不过寂寞，将就却是折磨。 —《不将就》热评 我相信某一天我的女孩会越过人群来到我身边，拨开我眼见得重重迷雾，然后我会抱紧她在她耳旁低语，今后我不会再缺席你的一切。 —《想自由》热评 请你记得 再喜欢也不要旧情复燃，因为从他忍心伤害你的那一刻起，你就应该知道，你的感受他从来没有考虑过 —《拿走了什么》热评 缺乏安全感的人是什么状态：“总是逼着喜欢我的人离开，逼他离开，却盼他回来”。 —《每分每秒》热评 我一直觉得如果有机会，我应该是个合格的恋人，温柔大方善解人意之类的，但是一不小心太喜欢你了，所以一切搞砸了，我成了幼稚又小心眼嫉妒心爆棚的讨厌鬼。 —《开始懂了》热评 太用力想做好一件事，通常结果会很糟，太用力爱一个人，往往得不到同等的爱，做好手头上该做的事，顺其自然，爱护自己，当一切变得不再混乱，有规律可循的时候，你想得到的，自然会披星戴月出现在你面前，而且是轻而易举，毫不费力。 —《得不到你》热评 你要分清楚“在空闲时间才陪你的人”和“专门腾出时间陪你的人”，然后再决定爱谁。 —《选择》热评 没有人会突然不爱你，只是你突然知道罢了。 —《只是不够爱》热评 我也曾以为我们是天造地设的一对，我闷不吭声，你叽叽喳喳；我理化样样行，你语文课代表；我热爱音乐喜欢唱歌，你写作画画样样不差。而现在这些却都成了分开的理由。 —《天造地设》热评 最近很流行的一段话：“如果我用你待我的方式来待你，恐怕你早已离去”好好体会这句话。适合任何关系，凡事换个角度，假如你是我，你未必有我大度。 —《有人》热评 婚宴的最后，她拿酒敬我，“如果时光倒流，那天，你会不会出来追我？”我没有回答她，因为这个假设没有任何意义。在我最幼稚的年纪，遇上最好的她。在我可以扛起风雨的时候，她已经嫁给别人。而我所以的成长，却又都是因为失去她。我端起酒杯回敬她，一饮而尽。 —《荒年》热评 以前恋爱，女孩经常会神经兮兮的翻看我的手机，后来我觉得烦就分手了，就这样，错过了一个翻我手机的女孩，剩下了全是翻我钱包的。 —《荒年》热评 很久之后我才知道，原来情深不寿这四个字的意思，并不是说一个人太深情会不长寿，而是说在一段感情里，如果一个人付出太多用情太深，这段感情才会不长久。 —《锦衣飞鱼》热评 暗恋这种，就好像下了一场暴雨，我故意站在你门外，几度想要敲你的门，问你是否可以暂时借避，可我又不敢，只好一直站在雨里。 —《rain》热评 其实，喜欢上你，并不是你长得好不好看，而是你在特殊的时间里，给了我别人给不了的感觉。 —《你的人生》热评 也许我到的时候，你已经走了。也许我到的时候，还碰巧赶上你的婚礼。我风尘仆仆，却顾不得的只洗了脸，就匆忙忙看你春风满面，娶妻生子。 —《我知道是你》热评 你是一场无关风月的红尘，成全了我一厢情愿的认真。 —《红尘客栈》热评 以前特别害怕烟火的爆竹声，你总在我身后笑咪咪的捂着我耳朵哄我抬头，现在我不再害怕了，恰好你也不再我身边了。 -《花火が瞬く夜に》 以上是我对该视频的归纳和总结。 同样的烟花，同样的十月，却没有了同样的你。 —《烟花落》 我很渴望能见你一面，但请你记得，我不会开口要求要见你，这不是因为骄傲，你知道我在你面前毫无骄傲可言，而是因为唯有你也想见我的时候，我们见面才有意义。 —《Love the way you lie》热评 提分手的人是我，删除好友的是我，不再联系的是我，在夜里哭的还是我。可笑的我瞒着所有人，继续爱了你那么久。 —《庸人自扰》热评 有时候做梦自己是知道的，有你的梦我会努力让它持续很久。 —《追光者》热评 你会等一个人很久吗？“不会” “为什么” “凭什么”。 —《我好像在哪见过你》热评 三毛：“刻意去找的东西，往往是找不到的”天下万物的来和去，都有他的时间。 —《Wonderful U》热评 在你之前，我没有一件想样的心事。在你之后，我没有拿得出手的痛苦。 —《断线》热评 那时候你在时，我换了条个签 “或许只有你懂得我 所以你没逃避”后来你离开了我，偶然一天发现，你得最近在听显示这首歌。 —《想自由》热评 打一个巴掌 再给一颗糖 反反复复你到何时才明白 他其实没那么喜欢你。 —《来不及》热评 之前是喜欢你，之后是很喜欢你，再之后是喜欢你很久了。 —《你我之间》热评 没有什么来日方长，有的只是夜长梦多。—《来日方长》热评 你可能不会知道，我对你仍有爱意，我对自己无能为力。我很喜欢你，可是好像只能到这里。 —《从夜晚，到清晨》热评 我已经忘了我这是第几次要放弃你了，可是在你回我消息得时候我就已经原谅你了。 —《不在》热评 孤独久了特别怕有个人对你好，更何况这个人你很喜欢却没有未来，疏远舍不得，靠近又胆小，但你清楚得知道，或早或晚，你都要放弃。 —《不在》热评 除了电影里，没人会等你四五年，说白了感情就是不联系就没有得东西。 —《走马》热评 值得庆幸的是，对有些关系我现在可以大方的说出我已经尽力了，我也丝毫不会觉得遗憾，该后悔的人，不应该是我。 —《遗憾》热评 其实一个人单身久了，你就会慢慢地发现你根本不适合谈恋爱，更不适合结婚，你只适合工作和赚钱，赚钱能治愈一切矫情，有钱能治愈一切自卑。 —《已注销的陌生人》热评 以上是我对该视频的归纳和总结。 生命如过场电影，让 “我再一次甜梦里惊醒”。 —《别念》 有个开婚纱店的女老板说，她看到那么多来试婚纱的姑娘，打开帘子的那一刻，没有一个男生会惊喜发出哇的声音。 —《平淡日子里的刺》热评 叔本华说过：人，要么孤独，要么庸俗，而我，既孤单，又庸俗。 —《一》热评 我吃完了五斤的西瓜，也等到回复我的消息，我想，这应该不是你不够喜欢我，而是这西瓜不够大。 —《那就这样吧》热评 老人拿手机去店里维修工作人员告诉他手机并没有坏，老人突然哭了，那我的孩子们怎么不给我打电话。 —《爸爸妈妈》热评 每一个人只能陪你走一段路，人总是要分开的。 —《啊朋友，再见》热评 喜欢一个人时，吸进去那么多勇气，最后呼出来的都是叹息。 —《没有人不比我快乐》热评 有个女孩子喜欢我，向我表白，我不敢答应，我没房没车 她不懂事 我得懂。 —《下一站遇见相似的灵魂》热评 失去一个人最大的遗憾是，他带走了一部分其他人不认识的你。 —《飘摇》热评 听得出情绪的人，都活的敏感而脆弱，满身裂纹滴着水。 —《All we do》热评 你在自甘堕落的时候，全世界都在昼夜狂欢，你在抑郁孤独的时候，你的前任和讨厌的人都在努力赚大钱从美食找新欢，你在怀念过去的时候，过去里的每一个人都没空等你。 —《我爱的人》热评 你真的不被这个世界所需要 你在炫耀诗和远方，父母却尚在苟且。 —《春风十里》热评 都是小人物，活着就行了。 —《别送我》热评 我们究竟是活了 365 天，还是活了一天，重复了 364 遍。 —《I Lived》热评 差一秒钟就冲进去的火车，信息迟钝而被售罄的商品，满心欢喜去接近却被小猫抓伤的瞬间，还有多看一眼仿佛就觉得会有回应的人，令人委屈的事情有那么多，岂止满身疲惫饥肠辘辘的现在呢？ —《于荒经之中》热评 小时候问过母亲大人一个很傻的问题，说鱼身上那么多刺，就不会痛吗，突然觉得这比喻用在人身上也挺合适的，那些往事像刺一样扎在身体里，时间久了感觉不到痛了，大概不是消失了，只是它们已经变成我们的骨头了吧。 —《鱼》热评 以上是我对该视频的归纳和总结。 活在这珍贵的人间，太阳强烈，水波温柔。 — 海子《活在这珍贵的人间》 猜猜我有几颗糖？猜对了两颗都给你。五颗！猜对了！先给你两颗，剩下的下次给你。 — 《海绵宝宝》 对我来说，风光无限的是你，跌落尘埃的也是你。重点是你，而不是怎样的你。 — 墨香铜臭《天宫赐福》 一见钟情，明明是见色起意。日久生情，不过是权衡利弊。连白头到老，都只是习惯使然。 — 安逸《这咬人的爱》 深思熟虑的结果往往就是说不清楚。 — 王小波《黑铁时代》 应当在朋友正是困难的时候给予帮助，不可在事情无望之后再说闲话。 — 伊索。 从善如登 从恶如崩。 — 左丘明《国语。周语下》 如果有来生，要做一棵树，站成永恒，没有悲欢的姿势，一半在土里安详，一半在风里飞扬，一半洒落阴凉，一半沐浴阳光，非常沉默非常骄傲，从不依靠，从不寻找。 — 三毛《说给自己听》 我追索人心的深度，却看到了人心的浅薄。 — 木心《云雀叫了一整天》 我不在意你曾堕落，我只在意你是否会崛起。 — 林肯 我只愿面朝大海，春暖花开。 — 海子《面朝大海。春暖花开》 我必须承认生命中大部分时光是属于孤独的，努力成长是在孤独里可以进行的最好的游戏。 — 绿川幸《夏目友人帐》 没有可怕的深度，就没有美丽的水面。 — 尼采《尼采遗稿远》 妈妈们都有个通病，只要你说了哪样菜好吃，她们就频繁地煮那道菜，直到你厌烦地埋怨了为止。其实她这辈子，就是在拼命把你觉得好的，给你，都给你，爱得不知所措了而已。 — 张爱玲 我太年轻了，甚至不懂怎么去爱她。 — 安东尼·德·圣-埃克苏佩里《小王子》 许多人所谓的成熟，不过是被习俗磨去了棱角，变得世故而实际了。那不是成熟，而是将神的早衰和个性的消亡，真正的成熟，应当是独特个性的形成，真实自我的发现，精神上的结果和丰收。 — 周国平《灵魂只能独行》 从小我就懂得保护自己，我知道要想不被人拒绝，最好的办法就是先拒绝别人。 — 王家卫《东邪西毒》 你不用对每个过客负责，也不用对每个路人说教。 — 韩寒《后会无期 》 痛苦，是保持清醒的最好方式。 — 范增《秦时明月》 曾虑多情损梵行，入山又恐别倾城，世间安得双全法，不负如来不负卿。 — 仓央嘉措 人最宝贵的是生命，生命对人来说只有一次。人的一生应当这样度过:当他回首往事时，不会因为碌碌无为，虚度年华而悔恨，也不会因为为人卑劣，生活庸俗而愧疚。 — 奥斯特洛夫斯基《钢铁是怎样炼成的》 狐狸说:对我来说，你只是一个小男孩，就像其他成千上万个小男孩一样没有什么两样。我不需要你。你也不需要我。对你来说，我也只是一只狐狸，和其他成千上万的狐狸没有什么不同。但是，如果你驯养了我，我们就会彼此需要。对我来说，你就是我的世界独一无二的了；我对你来说，也是你的世界里的唯一了。 — 安东尼·德·圣-埃克苏佩里《小王子》 派大星:嗨，海绵宝宝，我们去抓水母吧。海绵宝宝:对不起，今天不行，我要上学。派大星:如果你去上学的话，我今天该干点什么，？海绵宝宝:我不知道，一般我不在家的时候，你都干些什么啊？派大星:等你回来。 —《海绵宝宝》 没有谁的生活会一直完美，但无论什么时候，都要看着前方，满怀希望就会所向披靡。 — 巫哲《撒野》 以上是我对该视频的归纳和总结。 别慌，月亮也正在大海某处迷茫。 我们各自努力，最高处见。 你要是愿意，我就永远存在。 你是我疲惫生活中唯一的英雄梦想。 热爱可抵岁月漫长。 第一次看到宇宙，是和你四目相对的时候。 我将永远忠于自己，披星戴月奔向理想和你 如今你依旧是我的光。 地球正在一点点疏离月亮，据说每一百万年就会陌生一秒，早在 25 亿年前，我们便开始了漫长的别离。 一定要站在你所热爱的世界里闪闪发光。 出言有尺 嬉闹有度 做事有余 说话有德。 放松点，不用和每个人都要好，也不用被每个人都喜欢。 永远保持理智选择和接受坏事的心态。 山海的浩瀚，宇宙的浪漫。都在我内心翻腾，在推着我前进。 总有一阵风会吹过我再吹过你，总有一个瞬间我们的距离是零。 对待自己温柔一点。你只不过是宇宙的孩子，与植物、星辰没什么两样。 你也曾是银河的浪漫子民，孤身坠入地球，等不到群星来信。 向着月亮出发，即使不能到达，也能站在群星之中。 夏天有梅子味的晚霞和两三颗啤酒味的星。 出现在别人的生活里要像一份礼物。 你知道的，你是我打不倒的热爱。 如果你来访我，我不在，请和我门外的花坐一会儿，它们很温暖，我注视它们很多很多日子了。 我从未觉得孤单，说的浪漫些，我完全自由。 他们想把我埋了，却不知道我是一颗种子。 羡慕别人的天空简直没道理，因为你是一座宇宙。 以上是我对该视频的归纳和总结。 惊鸿伤心桥下春波绿，曾是惊鸿照影来。 — 陆游《沈园》 尤物脂肤荑手不牢固，世间尤物难留连。 — 白居易《真娘墓》 解语花清肌莹骨能香玉，艳质英姿解语花。 — 赵彦端《鹧鸪天》 似花人红藕花香到槛频，可堪闲忆似花人。 — 李珣《浣溪沙》 飞琼曲水兰船，忆伴飞琼看月眠。 — 晏几道《采桑子》 海棠误了海棠时候，不成直待花残。 — 陈允平《清平乐》 婵娟婵娟二八正娇羞，日暮相逢南陌头。 — 权德舆《玉台体》 仙子楼阁玲珑五云起，其中绰约多仙子。 — 白居易《长恨歌》 娇娘东家娇娘求对值，浓笑画空作唐字。 — 李贺《唐儿歌》 玉奴真态香生谁画得？玉奴纤手嗅梅花。 — 苏轼《四时词》 玉人二十四桥明月夜，玉人何处教吹箫? — 杜牧《寄扬州韩绰判官》 红裙眉黛夺将萤草色，红裙妒杀石榴花。 — 万楚《五日观妓》 红妆只恐夜深花睡去，更烧高烛照红妆。 — 苏轼《海棠》 佳人墙里秋千墙外道，墙外行人，墙里佳人笑。 — 苏轼《蝶恋花》 姝丽取次梳妆，寻常言语，有得几多姝丽。 — 柳永《玉女摇仙佩》 碧玉碧玉当年未破瓜，学成歌舞入侯家。 — 陆游《无题》 倾国汉皇重色思倾国，御宇多年求不得。 — 白居易《长恨歌》 倾城夜出曙翻归，倾城满南陌。 — 王维《同比部杨员外十五夜游有怀静者季》 娇娥斜髻娇娥夜卧迟，梨花风静鸟栖枝。 — 唐寅《美人对月》 红颜痛哭六军皆缟素，冲冠一怒为红颜。 — 吴伟业《圆圆曲》 萧娘奈向灯前堕泪，断肠萧娘，旧日书辞。 — 周邦彦《四园竹》 佳丽后宫佳丽三千人，三千宠爱在一身。 — 白居易《长恨歌》 丽人三月三日天气新，长安水边多丽人。 — 杜甫《丽人行》 以上是我对该视频的归纳和总结。 后续会对以上内容校对，然后有时间再看原文、原诗词，再进行赏析。","link":"/2019/12/17/Article-collection-1/"},{"title":"前端学习路线图谱","text":"网易云课堂高级前端工程师知识图谱 千峰前端工程师知识图谱 2017年的前端工程师图谱 20190418达内图谱 2019115珠峰图谱 开发吧 web全栈架构师 以上图谱来自网络，如有侵权，联系博主，立即删除。2020前端30K知识清单-国庆都结束了，赶紧充电学习! 给女朋友写了一份前端学习路线","link":"/2020/03/06/Blog-about-industry-2/"},{"title":"多端统一开发解决方案","text":"随着微信小程序的火爆，各家厂商纷纷推出自己的小程序，手机厂商也推出轻应用，这意味着开发者要面对不同平台都要开发一套，于是开发一套代码多平台运行成为构想， Uniapp Apiclound Mpvue Taro Uniapp 使用 Vue 开发所有前端应用的框架，开发者编写一套代码，可发布到 iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。 标签：Vue、大量开源项目 Apiclound 使用可视化工具快速构建应用程序，基于大数据与拖拽式产品工具自动关联项目组件，并帮助项目快速落地 标签：可视化工具、操作简单快捷 Mpvue 使用 Vue.js 开发小程序的前端框架。框架基于 Vue.js 核心，mpvue 修改了 Vue.js 的 runtime 和 compiler 实现，使其可以运行在小程序环境中，从而为小程序开发引入了整套 Vue.js 开发体验。 标签：Vue、小程序 Taro Taro 是一套遵循 React 语法规范的 多端开发 解决方案。使用 Taro，只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同终端（微信/百度/支付宝/字节跳动/QQ 小程序、快应用、H5、React-Native 等）运行的代码。 标签：React 以上是我对下列视频及文章的归纳和总结。4款前端移动端开发框架","link":"/2019/12/17/Blog-about-industry-3/"},{"title":"入坑 Java 开发的自学之路","text":"基础知识 工具方面 框架方面 架构方面 关注源码/性能 基础知识 编程语言：Java、python 基本算法 基本网络知识：TCP/IP HTTP/HTTPS 基本的设计模式 工具方面 操作系统：Linux（CentOS\\Ubuntu） 代码管理：SVN/Git 持续集成：（CI/CD）：jenkins Java 的项目管理工具：Maven / Gradle 框架方面应用层框架 ssm：spring springmvc mybatis spring boot 中间件 MQ 消息队列 RPC 通信框架 gRPC thrift dubbo springcloud elasticsearch 数据库 搜索引擎 数据库 SQL：MySQL / Postgre SQL NoSql：Redis Memcached mongodb elasticsearch 架构方面分布式/微服务架构 spring cloud dubbo rpc 通信 虚拟化/容器化的技术 Docker 容器化 k8s kubernetes 关注源码/性能 JDK 源码以及部分设计思想 Spring 源码 JVM 细节与排错 高并发/高可用 以上是我对下列视频及文章的归纳和总结。自学Java开发的学习路线","link":"/2019/12/17/Blog-about-industry-4/"},{"title":"淘客","text":"Python 推荐课程培训机构四大坑：T 州、 D 内、 Q 锋、 Q 鸟比上面机构略好：H 马训练营、S 硅谷理由：老师存在大量简历造假、很多概念理解错误 推荐课程：极客时间零基础学 Python理由：在一线大厂工作 5 年以上的技术人员、内容简洁、应用场景、通俗易懂 以上是我对下列视频的归纳和总结王校长帮你淘课系列","link":"/2019/12/26/Blog-about-industry-5/"},{"title":"关于开源项目","text":"看开源项目有助于解决以下问题问题 1：学完编程语言，但还是感到学习与实践之间的巨大鸿沟？问题 2：在校生，自学的感觉是玩具，不知实际项目怎么写，实际项目代码没看过？问题 3：本科毕业时校招找工作，或研究生复试，或外行转 IT 没项目经验怎么办？ java 推荐开源项目 halo：java、博客系统 hutool：java、工具集 piggymetrics：java、微服务、脚手架、落地 HanLP：机器学习、数据挖掘、自然语言处理 hansonwang99：对初学者友好 Spring Boot 前后端分离项目 美人鱼:Angular、PrimeNG、Bootstrap、Echarts。 微人事:SpringBoot、Vue、Redis。 bootshiro:springboot2、shiro、jwt open-capacity-platform:layui、springcloud V 部落:Vue、SpringBoot paascloud-master:SpringCloud、Vue、oAuth2.0 mall-swarm： Spring Cloud Hoxton &amp; Alibaba、Spring Boot 2.3、Oauth2、MyBatis、Docker、Elasticsearch、vue C/C++推荐开源项目 cjson:轻量级、json 解析器、指针、核心语法 Tinyhttpd：帮助理解服务器的本质 MyTinySTL：C++ oatpp：提供 web 服务 Redis：内存数据库、高速缓存 nginx Web 项目示例 电影搜索应用：React(Hooks)、create-react-app、JSX、CSS 聊天应用:Vue、Vuex、Vue Router、Vue CLI、Pusher、CSS 多语言博客网站:Nuxt.js、组件和页面、Storyblok模块、Mixins、Vuex、SCSS、Nuxt中间件 音频播放器：Quasar、Vue、Cordova、Wavesurfer、UI Components 博客：Gridsome、Vue、GraphQL、Markdown、Netlify 玩转开源项目 了解本项目是干什么的，你有没有兴趣学习，有哪些技术点（可以提前拆分了解） 把项目给跑起来 阅读项目源码并调试（可结合某个运行起来的功能入手，一个组件一个组件弄熟、看报错、看日志、看打印变量） 以上是我对下列视频及文章的归纳和总结。Java 企业级开源项目推荐，研究开源项目是获得项目经验的绝好途径C/C++开源项目推荐，研究开源项目是获得项目经验的绝好途径玩转开源项目没有项目实战经验，程序汪介绍 7 个开源项目充实你的简历做前端两年，月薪18k，这些项目经验你绝对值得学习","link":"/2020/01/16/Blog-about-industry-6/"},{"title":"如何学习一门技术","text":"仅供参考 阶段一：认知了解阶段（第一印象很重要）1.该技术的概念和方向2.该技术解决了什么问题3.同类技术有哪些4.该技术的主要组成部分5.该技术为什么出现 阶段二：学习语法，用法途径进阶1.视频教程（效率低）2.快速上手视频3.入门博客4.权威书籍，官方文档 阶段三：局部练习，小型实战，搭建环境（记录总结，写博客写博客写博客！！！） 阶段四：上手实际项目或开源项目（先打牢基础） 阶段五：（终极目标）造轮子，撸源码 以上是我对下列视频及文章的归纳和总结。如何学好技术","link":"/2020/03/21/Blog-about-industry-7/"},{"title":"40个改变编程技能的小技巧","text":"将大块代码分解成小函数 今日事今日毕，如果没毕，就留到明天 YAGNI原则 不必全知全能，但基础一定要扎实 KISS原则 别想太多 被问题/Bug卡住时，walk away！ 学会写测试代码TDD 先分解问题再开始写代码 代码不要死记硬背 学好用好Stack Overflow 不要「光学不练」 与小伙伴互相审查代码 Don’t Reinvent The Wheel 你的代码是最好的文档 懂得如何搜索 写代码时要之后维护考虑 复制粘贴 不要放弃 休息、休息再休息 学习软件设计模式 使用集成工具 Do code katas 依赖注入是一个要求 重构-测试-重构 及时寻求帮助 Practice makes perfect. 不必太在意评论 了解你的开发环境 复用组件 考虑相关限制 不要过早优化或重构 不要投机取巧 遵循规定的标准 用户不是技术人员 坚持使用Github或bitbucket 记录所有关键部分 风格保持一致 Don’t stop learning patience and love 相关资料15年程序员经验分享：40个改变你编程技能的小技巧！","link":"/2020/03/21/Blog-about-industry-8/"},{"title":"优质学习资源分享","text":"黑马程序员 视频库 学习工具 这里有各种学习软件免费下例如：PS、jsk8、mysql 等。 直播公开课 直播公开课有过往直播课的录播。 免费视频教程 从初级到高级课程应有尽有。 IBM Web 开发","link":"/2020/10/18/Blog-about-industry-9/"},{"title":"Electron 从入门到实践","text":"相关资料Electron+Vue开发跨平台桌面应用","link":"/2020/09/22/Blog-about-learning-1/"},{"title":"GitHub 问题汇总","text":"关于我 hexo 博客上传问题 问题：Failed to connect to github.com port 443: Timed out ping github.com ping 不通看自己是不是启用了代理或vpn，然后再看 host 文件中 github 对应的地址是否能访问通。之前访问不通，在 host 文件中添加了 30.253.112 github.com 199.108.153 assets-cdn.github.com 199.109.153 assets-cdn.github.com 199.110.153 assets-cdn.github.com 199.111.153 assets-cdn.github.com 232.5.194 github.global.ssl.fastly.net 101.113.194 github.global.ssl.fastly.net我全部删除掉，怎么添加 host 我在 GitHub 技巧 有提到过。 相关资料Failed to connect to github.com port 443: Timed out(Windows)GitHub解决git@github.com: Permission denied (publickey).问题","link":"/2020/06/08/Blog-about-learning-100/"},{"title":"微信小程序 从入门到实践","text":"微信小程序介绍小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 微信小程序的特点：免安装、操作更接近原生 APP、必须在微信中使用开放注册范围：个人、企业、政府、媒体、其他组织。 微信小程序和微信的原生功能应用在本质上是一样的 —— 都是 Web App。 Web App 就是一种通过 H5 页面技术实现的，和 Native App 的功能和界面几乎一样的手机 App 形态。 微信小程序的优势1、微信有海量用户，而且粘性很高，在微信里开发产品更容易触达用户；2、推广 App 或 公众号的成本太高。3、开发适配成本低。4、容易小规模试错，然后快速迭代。5、跨平台。 微信小程序对于创业者的优势1、App 流量成本的急剧攀上2、移动互联网格局基本已定，用户主要需求场景已被巨头把持3、面向所有产品对用户时间的竞争 开发支持： 开发文档 开发者工具 设计指南 小程序宣传方式 小程序搜索入口 &amp; 附近的小程序 扫一扫、长按识别小程序码 好友分享、群分享 关联公众号 第三方的小程序应用商店 小程序之间相互跳转 官方文档介绍API指南组件工具 小程序开发流程 注册在微信公众平台注册小程序，完成注册后可以同步进行信息完善和开发。 小程序信息完善填写小程序基本信息，包括名称、头像、介绍及服务范围等。 开发小程序完成小程序开发者绑定、开发信息配置后，开发者可下载开发者工具、参考开发文档进行小程序的开发和调试。 提交审核和发布完成小程序开发后，提交代码至微信团队审核，审核通过后即可发布（公测期间不能发布）。 微信小程序注册 通过公众号注册（避免了重复认证）（暂不支持个人类型公众号复用资质创建小程序）。 进入微信小程序官网注册。(访问注册页面，耐心完成注册即可) 注册注意事项 个人主体无法完成支付，卡包，搜索附近小程序功能。 使用邮箱进行注册时一个邮箱仅能申请一个小程序。 邮箱不能使用注册过公众号、开发平台、企业号及绑定过个人号的邮箱。 进行资料完善时保证信息准确性，主体信息一旦填写无法进行修改。 上传企业基本资料时需要签名加盖公章，保证图片清晰度，否则导致审核不通过。 已经申请微信公众号的企业可直接在首页中点击小程序进入下一步。 微信开发者工具使用新建项目当符合以下条件时，可以在本地创建一个小程序项目 需要一个小程序的 AppID；如没有 AppID，可以选择申请使用测试号。 登录的微信号需要是该 AppID 的开发者； 需要选择一个空目录，或者选择的非空目录下存在 app.json 或者 project.config.json。当选择空目录时，可以选择是否在该目录下生成一个简单的项目。 多开项目工具支持同时打开多个项目，每次打开项目时会从新窗口打开，入口有以下几种： 从项目选择页打开项目，处于项目窗口时可以从菜单栏的项目 -&gt; 查看所有项目打开项目选择页 从菜单栏的最近打开项目列表中打开的项目会从新窗口打开 新建项目 命令行或 HTTP 调用工具打开项目 管理项目对本地项目进行删除和批量删除。 主界面开发者工具主界面，从上到下，从左到右，分别为：菜单栏、工具栏、模拟器、目录树、编辑区、调试器 六大部分。 菜单栏微信 web 开发者工具 切换帐号 关于 检查更新 开发者论坛 开发者文档 调试 更换开发模式:快速切换公众号网页调试和小程序调试 推出 项目 新建项目 打开最近 查看所有项目 关闭当前项目 文件 新建文件 保存 保存所有 关闭文件 编辑：可以查看编辑相关的操作和快捷键 工具 编译：编译当前小程序项目 刷新：与编译的功能一致，由于历史原因保留对应的快捷键 ctrl(⌘) + R 编译配置：可以选择普通编译或自定义编译条件 前后台切换：模拟客户端小程序进入后台运行和返回前台的操作 清除缓存：清除文件缓存、数据缓存、以及授权数据 界面：控制主界面窗口模块的显示与隐藏 设置： 外观设置：控制编辑器的配色主题、字体、字号、行距 编辑设置：控制文件保存的行为，编辑器的表现 代理设置：选择直连网络、系统代理和手动设置代理 通知设置：设置是否接受某种类型的通知 工具栏点击用户头像可以打开个人中心，在这里可以便捷的切换用户和查看开发者工具收到的消息。工具栏中间，可以选择普通编译，也可以新建并选择自定义条件进行编译和预览。通过切后台按钮，可以模拟小程序进入后台的情况工具栏上提供了清缓存的快速入口。可以便捷的清除工具上的文件缓存、数据缓存、还有后台的授权数据，方便开发者调试。工具栏右侧是开发辅助功能的区域，在这里可以上传代码、版本管理、查看项目详情 模拟器在模拟器底部的状态栏，可以直观地看到当前运行小程序的场景值，页面路径及页面参数 独立窗口点击 模拟器/调试器 右上角的按钮可以使用独立窗口显示 模拟器/调试器 项目页卡详情 基本信息包括图标、AppID、第三方平台名（只有第三方平台的开发小程序才会显示）、目录信息、上次提交代码的时间以及代码包大小。 本地设置开发者可以在此选择任意基础库版本，用于开发和调试旧版本兼容问题。 项目配置 项目设置代码保护 主要是对文件进行扁平化处理并替换 require 引用的文件名，以下情况不适合使用此功能 对于小程序只有简单页面的情况下，开启此功能效果不佳 有文件超过 500kb，且其中有使用 require 引用项目中的文件的情况，在运行时可能会报文件没有找到 动态引用的情况，如 var a = ‘somefile.js’; require(a); 将 require 函数赋值给其他变量的情况，如 var a = require; a(‘somefile.js’); 将 require 作为二元运算符的参数的情况，如 require + 1; 6.使用 … 运算符且未开启 ES6 转 ES5 的情况 不校验请求域名及 TLS 版本 域名信息详情/项目配置将显示小程序的安全域名信息，合法域名可在 mp 管理后台进行设置。 设置外观设置 主题 调试器主题 字体 字号 行距 模拟器位置 编辑设置 文件保存 编辑器 Tab 大小 代理设置可以配置不使用代理，或使用系统代理，或使用自定义代理。 安全设置可以开启和关闭 CLI/HTTP 调用功能 代码编辑文件格式因 iOS 下仅支持 UTF8 编码格式，最新版本的开发者工具会在上传代码时候对代码文件做一次编码格式校验。 文件支持工具目前提供了 5 种文件的编辑：wxml、wxss、js、json、wxs 以及图片文件的预览。 文件操作新建页面有两种方式 在目录树上右键，选择新建 Page，将自动生成页面所需要的 wxml、wxss、js、json 在 app.json 的 pages 字段，添加需要新建的页面的路径，将会自动生成该页面所需要的文件 编译模式小程序项目代码结构 .json 后缀的 JSON 配置文件 project.config：项目配置 根目录下的 app.json是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。pages 字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。window 字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。 工具配置 project.config.json 页面配置 page.json JSON 注意事项JSON 文件都是被包裹在一个大括号中 {}，通过 key-value 的方式来表达数据。JSON 的 Key 必须包裹在一个双引号中。JSON 文件中无法使用注释，试图添加注释将会引发报错。 JSON 的值只能是以下几种数据格式，其他任何格式都会触发报错，例如 JavaScript 中的 undefined。数字，包含浮点数和整数字符串，需要包裹在双引号中Bool 值，true 或者 false数组，需要包裹在方括号中 []对象，需要包裹在大括号中 {}Null .wxml 后缀的 WXML 模板文件wxml .wxss 后缀的 WXSS 样式文件新增了尺寸单位。提供了全局的样式和局部样式。 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。wxss 引入外部 wxss：@import ‘./test_0.wxss’ .js 后缀的 JS 脚本逻辑文件WXML-事件小程序的 APIbind 和 catch ，catch 会阻止事件向上冒泡。 页面 小程序文件结构和传统 Web 对比 结构 传统 web 微信小程序 结构 HTML WXML 样式 CSS WXSS 逻辑 JavaScript JavaScript 配置 无 JSON 小程序宿主环境微信客户端给小程序所提供的环境为宿主环境。 渲染层和逻辑层小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。 小程序的渲染层和逻辑层分别由 2 个线程管理：渲染层的界面使用了 WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端（下文中也会采用 Native 来代指微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。 有关渲染层和逻辑层的详细文档参考：小程序框架 程序与页面微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。小程序启动之后，在 app.js 定义的 App 实例的 onLaunch 回调会被执行:整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 注册程序 App 。页面的事件回调参考文档 组件API要获取用户的地理位置时，只需要： 1234567wx.getLocation({ type: &quot;wgs84&quot;, success: res =&gt; { var latitude = res.latitude; // 纬度 var longitude = res.longitude; // 经度 }}); 调用微信扫一扫能力，只需要： 12345wx.scanCode({ success: res =&gt; { console.log(res); }}); 小程序配置全局配置常用配置项pages 页面路径列表window 全局的默认窗口表现tabBar 底部 tab 栏的表现networkTimeout 网络超时时间debug 是否开启 debug 模式，默认关闭 页面配置页面中配置项会覆盖 app.json 的 window 中相同的配置项。 页面常用配置项navigationBarBackgroundColor 导航栏背景颜色navigationBarTextStyle 导航栏标题颜色，仅支持 black / whitenavigationBarTitleText 导航栏标题文字内容backgroundColor 窗口的背景色backgroundTextStyle 下拉 loading 的样式，仅支持 dark / light 注意：配置文件中不能出现注释。 视图层基础组件 数据绑定 1&lt;view&gt;{{message}}&lt;/view&gt; 12345Page({ data: { message: 'Hello MINA!' }}) 组件属性 1&lt;view id=&quot;item-{{id}}&quot;&gt; &lt;/view&gt; 12345Page({ data: { id: 0 }}) 三元运算 1&lt;view hidden=&quot;{{flag ? true : false}}&quot;&gt; Hidden &lt;/view&gt; 算数运算 1&lt;view&gt; {{a + b}} + {{c}} + d &lt;/view&gt; 1234567Page({ data: { a: 1, b: 2, c: 3 }}) 字符串运算 1&lt;view&gt;{{&quot;hello&quot; + name}}&lt;/view&gt; 12345Page({ data:{ name: 'MINA' }}) 逻辑判断 1&lt;view wx:if=&quot;{{length &gt; 5}}&quot;&gt; &lt;/view&gt; 列表渲染 123&lt;view wx:for=&quot;{{array}}&quot; wx:key=&quot;index&quot;&gt; {{index}}: {{item.message}}&lt;/view&gt; 123456789Page({ data: { array: [{ message: 'foo', }, { message: 'bar' }] }}) 123&lt;view wx:for=&quot;{{array}}&quot; wx:for-index=&quot;idx&quot; wx:for-item=&quot;itemName&quot;&gt; {{idx}}: {{itemName.message}}&lt;/view&gt; block wx:for 1234&lt;block wx:for=&quot;{{[1, 2, 3]}}&quot;&gt; &lt;view&gt; {{index}}: &lt;/view&gt; &lt;view&gt; {{item}} &lt;/view&gt;&lt;/block&gt; 尺寸单位 rpx 样式导入 1234@import &quot;common.wxss&quot;;.middle-p { padding:15px;} 样式其他补充 12&lt;view style=&quot;color:{{color}};&quot; /&gt;&lt;view class=&quot;normal_view&quot; /&gt; 基本组件 view hover-class=””text selecttable decodeimage 默认宽 320px 高 240pxswiper 轮播图 样式设置 给 swiper 一个样式，给 swiper-item 内容器一个样式 12345678910&lt;view class=&quot;page-section page-section-spacing swiper&quot;&gt; &lt;swiper indicator-dots=&quot;{{indicatorDots}}&quot; autoplay=&quot;{{autoplay}}&quot; interval=&quot;{{interval}}&quot; duration=&quot;{{duration}}&quot;&gt; &lt;block wx:for=&quot;{{background}}&quot; wx:key=&quot;*this&quot;&gt; &lt;swiper-item&gt; &lt;view class=&quot;swiper-item {{item}}&quot;&gt;&lt;/view&gt; &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt;&lt;/view&gt; navigator 导航 123456&lt;view class=&quot;btn-area&quot;&gt; &lt;navigator url=&quot;/page/navigate/navigate?title=navigate&quot; hover-class=&quot;navigator-hover&quot;&gt;跳转到新页面&lt;/navigator&gt; &lt;navigator url=&quot;../../redirect/redirect/redirect?title=redirect&quot; open-type=&quot;redirect&quot; hover-class=&quot;other-navigator-hover&quot;&gt;在当前页打开&lt;/navigator&gt; &lt;navigator url=&quot;/page/index/index&quot; open-type=&quot;switchTab&quot; hover-class=&quot;other-navigator-hover&quot;&gt;切换 Tab&lt;/navigator&gt; &lt;navigator target=&quot;miniProgram&quot; open-type=&quot;navigate&quot; app-id=&quot;&quot; path=&quot;&quot; extra-data=&quot;&quot; version=&quot;release&quot;&gt;打开绑定的小程序&lt;/navigator&gt;&lt;/view&gt; video 视频 12&lt;video id=&quot;myVideo&quot; src=&quot;http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&amp;bizid=1023&amp;hy=SH&amp;fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400&quot; danmu-list=&quot;{{danmuList}}&quot; enable-danmu danmu-btn controls&gt;&lt;/video&gt; scroll-view 可滚动视图区域 bind:tap=”hanleTap”catch:tap=”hanleTap”mut-bind:tap=”hanleTap”data-index=data-post-id-currente.target.dataset.indexe.target.dataset.postIdCurrent 自定义组件 components 1234567&lt;view class=&quot;my_header&quot;&gt; {{cData}} &lt;view&gt; &lt;slot name=&quot;before&quot;&gt;&lt;/slot&gt; &lt;slot name=&quot;after&quot;&gt;&lt;/slot&gt; &lt;/view&gt;&lt;/view&gt; 12345678910111213141516171819202122232425Component({ options: { multipleSlots: true // 在组件定义时的选项中启用多slot支持 }, properties: { // 这里定义了innerText属性，属性值可以在组件使用时指定 innerText: { type: String, value: 'default value', }, text: Number }, externalClasses: ['f-class'] // 外部样式类 data: { // 这里是一些组件内部数据 someData: {} }, methods: { // 这里是一个自定义方法 customMethod(event){ this.triggerEvent('posttap',{pid:1}) // 只会触发posttap // 详细看 组件之间通信与事件 } }}) 组件注册 12345{ &quot;usingComponents&quot;:{ &quot;PageHeader&quot;: &quot;page/to/&quot; }} 12345&lt;PageHeader innerText=&quot;正在上映&quot; f-class=&quot;movie-list&quot; bind:customMethod=&quot;posttap&quot;&gt; &lt;view slot=&quot;before&quot;&gt;这里是插入到组件slot name=&quot;before&quot;中的内容&lt;/view&gt; &lt;!-- 这部分内容将被放置在组件 &lt;slot name=&quot;after&quot;&gt; 的位置上 --&gt; &lt;view slot=&quot;after&quot;&gt;这里是插入到组件slot name=&quot;after&quot;中的内容&lt;/view&gt;&lt;/PageHeader&gt; 1234posttap(event){ // 获取自定义事件传参 console.log(event.detail.pid)} 12345// 对于对象或数组字段，可以直接修改一个其下的子字段，这样做通常比修改整个对象或数组更好this.setData({ 'array[0].text':'changed data', 'object.text': 'changed data' }) 路由 123456wx.navigateTo({ url: ''})wx.redirectTo({ url: ''}) js 模块 123456789var a = { name: xiaoming}export { a}import { a } from '../../data/data.js' 操作菜单 wx.showActionSheet({}) 背景音乐 12345678910111213141516171819Page({ data: { _mgr: wx.getBackgroundAudioManager() }, onLoad(options){ this.data._mgr.onPlay(this.onMusicStart) this.data._mgr.onStop(this.onMusicStop) this.data._mgr.onPause(this.onMusicStop) } onMusicStart(event){ mgr.src = music.url mgr.title = music.title mgr.coverImgUrl = music.coverImg } onMusicStop(event){ }}) 1234// app.json{ &quot;requiredBackgroundModes&quot;:[&quot;audio&quot;,&quot;location&quot;]} 动态设置当前页面的标题 123wx.setNavigationBarTitle({ title: '当前页面'}) 引用 WXML 提供两种文件引用方式import和include。 1234&lt;!-- item.wxml --&gt;&lt;template name=&quot;item&quot;&gt; &lt;text&gt;{{text}}&lt;/text&gt;&lt;/template&gt; 12&lt;import src=&quot;item.wxml&quot;/&gt;&lt;template is=&quot;item&quot; data=&quot;{{text: 'forbar'}}&quot;/&gt; 12345678910&lt;!-- index.wxml --&gt;&lt;include src=&quot;header.wxml&quot;/&gt;&lt;view&gt; body &lt;/view&gt;&lt;include src=&quot;footer.wxml&quot;/&gt;&lt;!-- header.wxml --&gt;&lt;view&gt; header &lt;/view&gt;&lt;!-- footer.wxml --&gt;&lt;view&gt; footer &lt;/view&gt; 组件库weui-wxss：微信官方设计团队 iview-weapp vant-weapp MinUI wux-weapp ColorUI Linui 组件库使用Linui在小程序跟目录初始化 npm init -y npm i lin-ui@0.8.7 找到工具点击构建 npm 注册组件 123456// 全局 局部注册一致{ &quot;usingComponents&quot;:{ &quot;l-avatar&quot;:&quot;/miniprogram_npm/lin-ui/avatar/index&quot; }} 小程序开发字体图标引入将字体 url 转成 base64 的格式后使用 在线 url 使用 小技巧不做数据绑定推荐用 _ 开头例如： _postsCollected 小程序之间跳转全局配置navigateToMiniProgramAppIdList API 123456789101112131415wx.navigateToMiniProgram({ // 打开小程序的 appid appId: '', // 打开的页面路径以及参数 小程序的 App.onLaunch、App.onShow 和 Page.onLoad 的回调函数中可以获取到query 数据 path: 'page/index/index?id=123', // 需要传递给目标小程序的数据，目标小程序可在 App.onLaunch，App.onShow 中获取到这份数据。 extraData: { foo: 'bar' }, // 体验版、开发版、正式版 envVersion: 'develop', success(res) { // 打开成功 }}) 自定义 tabbar将小程序官方的 自定义 tabBar 示例中的 custom-tab-bar 复制到项目的根目录下（与 pages 同级） 配置信息在 app.json 中的 tabBar 项指定 custom 字段，同时其余 tabBar 相关配置也补充完整。所有 tab 页的 json 里需声明 usingComponents 项，也可以在 app.json 全局开启。 在 tabbar 页面 onShow() 页面中添加如下代码 1234567onShow() { if (typeof this.getTabBar === &quot;function&quot; &amp;&amp; this.getTabBar()) { this.getTabBar().setData({ selected: 2, // 修改选中的 tabbar 0是第一个 tab }); }}, 自定义 navigation我通过 bilibili 的视频找到一个比较好的 github 组件。地址我放在相关资料中了。 生成二维码 weapp-qrcode 使用方法 1&lt;canvas style=&quot;width: 200px; height: 200px;&quot; canvas-id=&quot;myQrcode&quot;&gt;&lt;/canvas&gt; 1234567891011121314151617181920212223// 引入 weapp.qrcode.js 文件import drawQrcode from '../../utils/weapp.qrcode.min.js'data: {},draw () { drawQrcode({ width: 160, height: 160, x: 20, y: 20, canvasId: 'myQrcode', // ctx: wx.createCanvasContext('myQrcode'), typeNumber: 10, text: '123', callback(e) { console.log('e: ', e) } })}onLoad: function(options) { this.draw()}, wxapp-qrcode 使用方法 1&lt;canvas style=&quot;width: 686rpx;height: 686rpx;background:#f1f1f1;&quot; canvas-id=&quot;mycanvas&quot;/&gt; 123456789101112131415161718192021222324252627282930313233import QR from '../../utils/qrcode.js'data: { imagePath: ''},onReady: function() { this.createQrCode('wxapp-qrcode', 'mycanvas', 300, 300)},createQrCode: function (content, canvasId, cavW, cavH) { //调用插件中的draw方法，绘制二维码图片 //this.canvasToTempImage 为绘制完成的回调函数，可根据自己的业务添加 QR.api.draw(content, canvasId, cavW, cavH, this, this.canvasToTempImage);},//获取临时缓存图片路径，存入data中canvasToTempImage: function (canvasId) { let that = this; wx.canvasToTempFilePath({ canvasId, // 这里canvasId即之前创建的canvas-id success: function (res) { let tempFilePath = res.tempFilePath; console.log(tempFilePath); that.setData({ // 如果采用mpvue,即 this.imagePath = tempFilePath imagePath:tempFilePath, }); }, fail: function (res) { console.log(res); } });} 小程序内嵌 H5页面web-view 小程序操作 dom123456&lt;view id=&quot;the-id&quot;&gt; 达达 达达 达达&lt;/view&gt;&lt;canvas canvas-id=&quot;qrcode&quot;&gt;&lt;/canvas&gt; 12345678910111213141516171819202122232425262728293031onLoad:function(){},onReady:function(){ const query = wx.createSelectorQuery() query.select('#the-id').boundingClientRect() query.selectViewport().scrollOffset() query.exec(function (res) { res[0].top // #the-id 节点的上边界坐标 res[0].bottom // #the-id 节点的下边界坐标 res[1].scrollTop // 显示区域的竖直滚动位置 console.log(res) }) console.log(query); var context = wx.createCanvasContext('qrcode') context.setStrokeStyle(&quot;#00ff00&quot;) context.setLineWidth(5) context.rect(0, 0, 200, 200) context.stroke() context.setStrokeStyle(&quot;#ff0000&quot;) context.setLineWidth(2) context.moveTo(160, 100) context.arc(100, 100, 60, 0, 2 * Math.PI, true) context.moveTo(140, 100) context.arc(100, 100, 40, 0, Math.PI, false) context.moveTo(85, 80) context.arc(80, 80, 5, 0, 2 * Math.PI, true) context.moveTo(125, 80) context.arc(120, 80, 5, 0, 2 * Math.PI, true) context.stroke() context.draw()} 小程序过滤器1234567891011// /filter/filter.wxsvar foo = &quot;'hello world' from tools.wxs&quot;;var bar = function (d) { return d;}module.exports = { FOO: foo, bar: bar,};module.exports.msg = &quot;some msg&quot;; 1234&lt;!-- page/index/index.wxml --&gt;&lt;wxs src=&quot;./../filter.wxs&quot; module=&quot;filter&quot; /&gt;&lt;view&gt; {{tools.msg}} &lt;/view&gt;&lt;view&gt; {{tools.bar(tools.FOO)}} &lt;/view&gt; 千位符过滤器123456789101112131415161718192021222324252627282930function Thousands(num) {//num = parseInt(num); var num = num + &quot;&quot;; var d = &quot;&quot;; if (num.slice(0, 1) == &quot;-&quot;) { d = num.slice(0, 1); num = num.slice(1); } var len = num.length; var index = num.indexOf(&quot;.&quot;); if (index == -1) { num = num + &quot;.00&quot;; } else if (index + 2 == len) { num = num + &quot;0&quot;; } var index = num.indexOf(&quot;.&quot;); // 字符出现的位置 var num2 = num.slice(-3); num = num.slice(0, index); var result = &quot;&quot;; while (num.length &gt; 3) { result = &quot;,&quot; + num.slice(-3) + result; num = num.slice(0, num.length - 3); } if (num) { result = num + result; } return d + (result + num2);}//{{filter.Thousands(1000)}} 时间过滤器12345678910111213141516171819202122function formatTime(str) { var formatNumber = function (n) { n = n.toString(); return n[1] ? n : &quot;0&quot; + n; }; var date = getDate(str); var year = date.getFullYear(); var month = date.getMonth() + 1; var day = date.getDate(); var hour = date.getHours(); var minute = date.getMinutes(); var second = date.getSeconds(); return ( [year, month, day].map(formatNumber).join(&quot;.&quot;) + &quot; &quot; + [hour, minute, second].map(formatNumber).join(&quot;:&quot;) );}{{filter.formatTime('时间戳')}} 小程序页面之间传值1、onShow 直接请求接口2、globalData 存储数据 onShow 做刷新获取数据3、获取页面实例，调用页面方法 123456789101112Page({ onCartAdd(num) { // 获取页面栈 let pages = getCurrentPages() // 获取当前页的实例 let currentPage = pages[pages.length - 1] // 获取当前页的路由 const url = currentPage.route; // 使用当前页的方法 currentPage.onCartAdd(num); }}) 4、eventBus(或者叫PubSub)方式5、gloabelData watcher方式5、通过hack方法直接调用通信页面的方法 小程序组件之间传值子传父 获取组件实例 123456789// 父组件中onReady:function(){ // 获取子组件的示例 this.child = this.selectComponent('.the-id'); // 子组件内的方法 this.child.showToast()}&lt;my-component id=&quot;the-id&quot; /&gt; 小程序异步请求小程序中支持 promise ,但是在实际开发中还是会有问题。例如: 1234567891011121314this.getArticle.then(res=&gt;{ console.log(res); // 我们想等这个异步执行完成后再执行一个异步}).then(()=&gt;{ // 需要写成这种链式结构 this.getArticle.then(res=&gt;{ console.log(res=&gt;{ console.log(res); }) })}).catch(error=&gt;{ console.log(error);}) 这种情况下还是避免不了嵌套，也许是我没有把 promise 理解透彻。这时候我想到了async/await 但是 async/await 是 ES7 的语法。 不勾选es6转es5，不勾选增强编译；该模式是纯es7的async/await，需要基础库高版本。 勾选es6转es5，勾选增强编译；一般是因为调用了第三方的es5插件，通过增强编译支持async/await。 勾选es6转es5，不勾选增强编译；手工引入runtime.js支持async/await。 我们需要引入 [regenerator-runtime]中 runtime.js 即可。在这之前你需要找个文件夹将它存到本地。例如：lib\\runtime\\runtime.js regenerator-runtime 编译的生成器和 async函数的独立运行时。 1234567891011121314151617// my 页面import regeneratorRuntime from '../../lib/runtime/runtime';async getGoodsList(){ const res=await request({url:&quot;/goods/search&quot;,data:this.QueryParams}); // 获取 总条数 const total=res.total; // 计算总页数 this.totalPages=Math.ceil(total/this.QueryParams.pagesize); // console.log(this.totalPages); this.setData({ // 拼接了数组 goodsList:[...this.data.goodsList,...res.goods] }) // 关闭下拉刷新的窗口 如果没有调用下拉刷新的窗口 直接关闭也不会报错 wx.stopPullDownRefresh();}, 小程序转发123456789101112Page({ onShareAppMessage: function (res) { if (res.from === 'button') { // 来自页面内转发按钮 console.log(res.target) } return { title: '自定义转发标题', path: '/page/user?id=123' } }}) 1&lt;button open-type=&quot;share&quot;&gt;分享&lt;/button&gt; 扫码进入小程序或获取参数小程序开发/开发设置中/扫普通链接二维码打开小程序，微信扫码的时候直接打开小程序，小程序内扫码的时候，获取参数。 navigateTo 失效 小程序中页面栈最多十层。 减少不必要使用 wx.navigateTo。 要想触发销毁页面onUnload生命周期执行方法，必须要使用不存在页面栈的路由。比如：wx.reLaunch、wx.redirectTo、wx.navigateBack。 1234567891011wx.redirectTo({ url:'/pages/address/address'})// 页面卸载时触发。如wx.redirectTo或wx.navigateBack到其他页面时。onUnload:function(){let pages = getCurrentPages().length - 1; console.log('需要销毁的页面：'+pages); wx.navigateBack({ delta: pages //关闭当前页面，跳转到上一个页面。但是不允许跳转到 tabbar 页面。参数 })} setData 数组和对象setData 的替代品wx-updata 123456789101112131415161718192021222324Page({ data: { list:[] obj:{} }, changelist(){ // 数组 let listData = this.data.list; listData = listData.splice(0,1); listData = listData.push(1); listData = listData.concat([1,2,3]) // 对象 this.setData({ // 对象更新 [&quot;obj.price&quot;]: value, // 数组更新 list:listData, &quot;novel[3].name&quot;: &quot;《巴黎圣母院》&quot;, &quot;novel[3].comment&quot;: &quot;是浪漫主义作品中一座里程碑&quot;, &quot;novel[3].imagePath&quot;: &quot;/pages/img/小说5.jpg&quot; [&quot;serviceList[&quot; + index + &quot;].services[&quot; + pos + &quot;].count&quot;]: num + 1 }) }}) 小程序键盘带搜索1&lt;input confirm-type='search' bindconfirm='shop_search_function'/&gt; 小程序 api Promise风格 小程序扩展能力/工具类库/API Promise化 WxService - Promise API wx-promise-pro 自己 Promise 封装 劫持 WX 复制模式 代理模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * promise 形式 getSetting */export const getSetting=()=&gt;{ return new Promise((resolve,reject)=&gt;{ wx.getSetting({ success: (result) =&gt; { resolve(result); }, fail: (err) =&gt; { reject(err); } }); })}/** * promise 形式 chooseAddress */export const chooseAddress=()=&gt;{ return new Promise((resolve,reject)=&gt;{ wx.chooseAddress({ success: (result) =&gt; { resolve(result); }, fail: (err) =&gt; { reject(err); } }); })}/** * promise 形式 openSetting */export const openSetting=()=&gt;{ return new Promise((resolve,reject)=&gt;{ wx.openSetting({ success: (result) =&gt; { resolve(result); }, fail: (err) =&gt; { reject(err); } }); })}/** * promise 形式 showModal * @param {object} param0 参数 */export const showModal=({content})=&gt;{ return new Promise((resolve,reject)=&gt;{ wx.showModal({ title: '提示', content: content, success :(res) =&gt;{ resolve(res); }, fail:(err)=&gt;{ reject(err); } }) })}/** * promise 形式 showToast * @param {object} param0 参数 */export const showToast=({title})=&gt;{ return new Promise((resolve,reject)=&gt;{ wx.showToast({ title: title, icon: 'none', success :(res) =&gt;{ resolve(res); }, fail:(err)=&gt;{ reject(err); } }) })}/** * promise 形式 login */export const login=()=&gt;{ return new Promise((resolve,reject)=&gt;{ wx.login({ timeout:10000, success: (result) =&gt; { resolve(result); }, fail: (err) =&gt; { reject(err); } }); })}/** * promise 形式的 小程序的微信支付 * @param {object} pay 支付所必要的参数 */export const requestPayment=(pay)=&gt;{ return new Promise((resolve,reject)=&gt;{ wx.requestPayment({ ...pay, success: (result) =&gt; { resolve(result) }, fail: (err) =&gt; { reject(err); } }); })}// 使用import { getSetting, chooseAddress, openSetting, showModal, showToast, requestPayment } from &quot;../../utils/asyncWx.js&quot;;requestPayment(pay);// 代码来源黑马 小程序请求 极简 promise 封装接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 同时发送异步代码的次数let ajaxTimes=0;export const request=(params)=&gt;{ // 判断 url中是否带有 /my/ 请求的是私有的路径 带上header token let header={...params.header}; if(params.url.includes(&quot;/my/&quot;)){ // 拼接header 带上token header[&quot;Authorization&quot;]=wx.getStorageSync(&quot;token&quot;); } ajaxTimes++; // 显示加载中 效果 wx.showLoading({ title: &quot;加载中&quot;, mask: true }); // 定义公共的url const baseUrl=&quot;https://api.zbztb.cn/api/public/v1&quot;; return new Promise((resolve,reject)=&gt;{ wx.request({ ...params, header:header, url:baseUrl+params.url, success:(result)=&gt;{ resolve(result.data.message); }, fail:(err)=&gt;{ reject(err); }, complete:()=&gt;{ ajaxTimes--; if(ajaxTimes===0){ // 关闭正在等待的图标 wx.hideLoading(); } } }); })}// 使用import { request } from &quot;../../request/index.js&quot;;request({url:&quot;/goods/search&quot;,data:this.QueryParams}).then(res=&gt;{ console.log(res);})// 代码来源黑马 请求封装 WxRequest - 发送请求 微信小程序wx.request二次封装 扫普通二维码打开小程序中文乱码扫码、页面传值过程中，有遇到中文传输乱码的情况，需要 encodeURIComponent()编码、或者decodeURIComponent()解码。 骨架屏返回键123456//生命周期函数--监听页面卸载onUnload: function () { wx.redirectTo({ url: &quot;/pages/index/index&quot;, }); }, 获取小程序码auth.getAccessTokenwxacode.getUnlimited微信小程序带参数小程序码微信小程序扫描二维码、小程序码进入并获得携带参数 小程序跳转wx.navigateToMiniProgramwx.navigateBackMiniProgram小程序跳转 下拉刷新什么情况下使用 scroll-view 最好呢！我目前觉得自定义导航栏的时候，自定义导航会导致下拉整个页面跟着动。但是用 scroll-view 也会有几个问题： 上拉刷新 加载动画，用原生的整个页面都会动，需要设置、注意兼容。 下拉加载更多 bindscrolltolower 事件触发 需要获取高度、然后动态设置高度。 scroll-view 自定义下拉刷新示例 小程序的AR能力canvas 画图Painter 小程序图表wx-charts 时间 new Date()在 Android 和 Ios 下执行得到的结果不一致。（微信小程序、webApp上均遇到此类问题。） 订阅消息模板消息2020年1月10日下线,开发者可使用订阅消息功能。 长期订阅消息只针对特定行业开放（目前长期性订阅消息向政务、医疗、交通、金融、教育等线下公共服务开放），所以普通开发者并无法使用，而且，现在长期消息模板是没有的，添加的入口估计目前没全量放开。 1234wx.requestSubscribeMessage({ tmplIds: ['模板消息id1'], success (res) { }}) 一次获取多张图片信息1234567891011121314const promixify = (api) =&gt; { return (options, ...params) =&gt; { return new Promise((resolve, reject) =&gt; { api(Object.assign({}, options, { success: resolve, fail: reject }), ...params) }) }}const getImageInfo = promixify(wx.getImageInfo)const images = ['img1.jpg', 'img2.jpg', 'img3.jpg']Promise.all( images.map(img =&gt; getImageInfo({ src: img }))).then((imageInfos) =&gt; { console.log(imageInfos)}) 小程序显示隐藏 tabbar12wx.showTabBar()wx.hideTabBar() 微信支付 对比栏目 JSAPI JSSDK 小程序 统一下单 都需要先获取到Openid，调用相同的API 调起数据签名 五个字段参与签名(区分大小写)：appId,nonceStr,package,signType,timeStamp 调起支付页面协议 HTTP或HTTPS HTTP或HTTPS HTTPS 支付目录 有 有 无 授权域名 回调函数 success回调 complete、fail、success回调函数 程序访问商户服务都是通过HTTPS,开发部署的时候需要安装HTTPS服务器 123456789wx.requestPayment({ timeStamp: '', nonceStr: '', package: '', signType: 'MD5', paySign: '', success (res) { }, fail (res) { }}) 实时音视频截图截图：LivePlayerContext.snapshot(string quality)保存图片：wx.saveImageToPhotosAlbum(Object object) 微信小程序截屏保存图片小程序上传图片后旋转问题小程序 扩展能力扩展组件视频滑动切换组件：video-swiper小程序长列表组件：recycle-view吸顶布局：sticky选项卡：tabs纵向选项卡组件：vtabs索引列表组件通讯录效果:index-list可选文本组件：select-text 工具类库API Promise化wx-js-utils 小程序用户 小程序模板消息 小程序统一消息 小程序动态消息 小程序码 微信支付 小程序实践腾讯在线教育小程序开发实践之路CSS预处理 css 预处理：使用 postcss 来编写样式并编译成 wxss postcss-url 解决 background-image不支持本地图片问题 通过 postcss-font-base64插件将字体变成base64格式 数据管理westore 构建gulp 来实现图片压缩以及前面提到的Post CSS编译 微信小程序项目脚手架 分包优化tab 页面 以 util 常用组件放到主包、其他每个页面分成300-500k 左右的子包 分包预加载通过配置preloadRule即可实现分包预加载。 独立分包：活动页类 setDate 优化减少调用 setDate，合并 setDate。少于64K，避免不必要的数据。与界面无关的数据不要放在 date 中。去掉不必要的事件绑定，减少更改次数。不要在节点 data 前缀放置大量数据。公共组件的复用 小程序日志监控工具 FundebugFundebug 云开发云函数获取 appid获取 openid生成分享图调用腾讯云 SDK 云函数 云数据库数据增加数据删除数据修改数据查询 JSON 数据库，提供 2GB 免费存储空间 文档型数据库 文档型数据库：频繁读写操作更合适关系型数据库：查询复杂的表关联占优势 数据类型String 字符串Number 数字Object 对象Array 数组Bool 布尔值GeoPoint 地理位置点 地理位置查找时建立地理位置索引Date 时间 创建的时间指的是客户端的时间Null 操作云数据库小程序控制 （读写数据库受权限控制限制）云函数控制 （拥有所有读写数据库的权限）控制台控制 （拥有所有读写数据库的权限） 云数据库权限管理 仅创建者可写，所有人可读（适合文章） 仅创建者可读写（适合私密相册） 仅管理端可写（适合商品信息） 仅管理端可读写（适合后台敏感数据） 每条记录都有一个 _id 字段用以唯一标志一条记录，一个 _openid 字段用以标志记录的创建者，即小程序的用户。需要特别注意的是，在管理端（控制台和云函数）中创建的不会有 _openid 字段，因为这是属于管理员创建的记录。开发者可以自定义 _id，但不可自定义和修改 _openid 。_openid 是在文档创建时由系统根据小程序用户默认创建的，开发者可使用其来标识和定位文档。 数据库 API 分为 小程序端 服务端 小程序端 API 拥有严格的调用权限控制，开发者可在小程序内直接调用 API 进行非敏感数据的操作。对于有更高安全要求的数据，可在云函数内通过服务端 API 进行操作。云函数的环境是与客户端完全隔离的，在云函数上可以私密且安全的操作数据库。 代码编写 使用 API 操作数据库只需三步：获取数据库引用、构造查询/更新条件、发出请求。 12345678910111213141516171819// 1. 获取数据库引用const db = wx.cloud.database();// 2. 构造查询语句// collection 方法获取一个集合的引用// where 方法传入一个对象，数据库返回集合中字段等于指定值的 JSON 文档。API 也支持高级的查询条件（比如大于、小于、in 等），具体见文档查看支持列表// get 方法会触发网络请求，往数据库取数据db.collection('books').where({ publishInfo: { country: 'United States' }}).get({ success: function(res) { // 输出 [{ &quot;title&quot;: &quot;The Catcher in the Rye&quot;, ... }] console.log(res) }})const testDB = wx.cloud.database({ env: &quot;test&quot;}); 上传文件\\下载文件\\删除文件\\换取临时链接 云存储管理文件上传文件下载文件分享文件 代码编写 存储在小程序端可以分别调用 wx.cloud.uploadFile 和 wx.cloud.downloadFile 完成上传和下载云文件操作。 1234567891011121314151617// 让用户选择一张图片wx.chooseImage({ success: chooseResult =&gt; { // 将图片上传至云存储空间 wx.cloud.uploadFile({ // 指定上传到的云路径 cloudPath: 'my-photo.png', // 指定要上传的文件的小程序临时文件路径 filePath: chooseResult.tempFilePaths[0], // 成功回调 success: res =&gt; { console.log('上传成功', res) }, }) },}) 调试基础库版本：2.2.3 以上版本才能使用云开发 了解云开发基础云开发是什么1、云开发是什么云开发是微信团队联合腾讯云提供的原生 Serverless 云服务，致力于帮助更多的开发者快速实现小程序业务的开发，快速迭代。 2、云开发与传统开发模式的对比传统模式 云开发模式 云开发与传统开发模式的对比 3、云开发能力介绍存储：在小程序端直接上传/下载云端文件，可视化管理。云函数：在云端运行代码，微信私有天然鉴权，开发者只需编写自身业务逻辑代码。云数据库：一个即可在小程序前端操作，也能在云函数中读写的 JSON 数据库。音视频服务：提供互通高品质实时音视频通话服务，支持互动白板，美颜滤镜，高清视频通话等，基于云开发快速接入。智能图像服务：集成智能鉴黄、人脸识别、人脸核身等 AI 视觉能力，基于云开发快速接入。 4、云开发对小程序开发的变革一天一交付，一天多交付成为可能：云开发的模式可以帮助开发者快速迭代产品，一天多次产品交付成为可能。小团队也可以做大事情：云开发的模式简单易懂，小的团队也可以借助云计算的能力，做一些更大的事情。弹性成本几乎为 0：所有资源都由服务方来管理，团队只需要关注业务逻辑。 云开发基本功能演示1、云开发的数据存储能力云开发为小程序开发者提供了数据存储能力，帮助开发者快速完成应用的开发。 传统的数据存储模式 云开发的数据存储模式 创建数据 123456789101112131415// 1. 获取数据库引用const db = wx.cloud.database()// 2. 构造查询语句// collection 方法获取一个集合的引用// todos 集合// add 新增db.collection('todos').add({ data: { description: 'learn cloud database' done: false }, success: function(res) { console.log(res) }}) 查询数据 1234567891011// 1. 获取数据库引用const db = wx.cloud.database()// 2. 构造查询语句// collection 方法获取一个集合的引用// 获取一个记录的数据,已有一个 ID 为 todo-identifiant-aleatoire 的在集合 todos 上的记录// get 方法会触发网络请求，往数据库取数据db.collection('todos').doc('todo-identifiant-aleatoire').get({ success: function(res) { console.log(res.data) }}) 2、云开发的计算能力云开发为小程序开发者提供了开箱即用的计算平台，开发者只需关注自己的核心逻辑，就可以完成复杂逻辑的编写。 传统模式下的计算能力的实现 云开发模式下的计算能力的实现不再需要了解 Apache Linux、MySQL，只需要在小程序中创建用函数编写代码并将其部署到云端就可以进行调用就可以获得计算能力的使用了。 3、云开发的文件存储能力云开发为小程序开发者提供了配置好常用环境的海量非结构化数据存储，帮助开发者解决数据存储问题。 云开发控制面板介绍如何进入云开发控制台 云开发控制台的几个功能查看数据统计管理用户信息管理数据库管理云函数管理云存储 云开发控制台的讲解云开发 API 简介云开发 API 分类 云开发 API 初始化方法 初始化选项 env云开发的初始化选项支持传入一个 Object，指定各个服务使用的默认环境传入一个 Object，这样可以分别指定数据库、文件存储、云函数所使用的的默认环境，从而实现在一个应用程序当中同时调用两个环境的内容。 云开发 API 使用注意事项云开发 API 同时支持 callback 风格和 promise 风格云开发 API 初始化时如果没有设置 ID，默认使用先创建的那个。在服务端可以借助云开发 SDK 内置的 getWXContext 来获取用户的身份信息 云开发数据库能力介绍云开发·数组查询使用云开发，可以实现诸如 A 在数组 B 中或 A 不在数组 B 中的条件判断。 1234567891011const db = wx.cloud.database();const _ = db.command;db.collection(&quot;todos&quot;) .where({ // progress: _.nin([0,100]) progress: _.in([0,100]) }) .get({ success: console.log, fail: console.error }) 字段类型查询如何使用云开发 API 进行字段类型查询使用云开发，可以实现只查询所需字段内容，而不是查询所有字段内容。 12345678910const db = wx.cloud.database();db.collection(&quot;todos&quot;) .field({ description: true, done: true, progress: true }) .get() .then(console.log) .catch(console.error) 正则表达式什么是正则表达式正则表达式描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 云开发中的正则表达式对象从基础库 2.3.2 开始，云开发支持使用正则表达式查询，开发者可以使用原生的正则对象，或者构建 db.RegExp 对象。 原生正则对象/miniprogram/i db.RegExp 对象 db.RegExp({ regexp: “miniprogram”, options: “i”,}) 在云开发中使用正则查询123456db.collection('todos').where({ description: db.RegExp({ regexp: &quot;miniprogram&quot;, options: &quot;i&quot;, })}) 12345678db.collection('todos').where({ name: new db.RegExp({ regexp: &quot;name-0[1-9]&quot;, options: &quot;i&quot;, })}).get().then(console.log) 地理位置查询在云开发中创建一个地理位置索引 12345const db = wx.cloud.database();db.collection(&quot;location&quot;).add({ description: 'eat an apple', location: db.Geo.Point(113,23)}) 在云开发中使用地理位置索引查询 1234db.collection('location').get().then(res =&gt;{ // 读取经纬度 console.log(res.data[0].location.latitude)}) 云开发数据库权限介绍云开发数据库中的几种权限云开发数据库一共有四种权限，从宽到紧排列如下： 仅创建者可写，所有人可读：数据只有创建者可写、所有人可读；仅创建者可读写：数据只有创建者可读写，其他用户不可读写；仅管理端可写，所有人可读：该数据只有管理端可写，所有人可读；仅管理端可读写：该数据只有管理端可读写； 云开发数据库中的权限对应场景 如何修改云开发数据库权限 云开发文件存储能力介绍文件存储 生成临时链接为什么要生成文件的临时链接 云开发的 fileID 无法在小程序以外的平台上使用一些服务需要文件的源地址 1234567891011wx.cloud.getTempFileURL({ // 需要获取链接的文件 fileList: ['cloud://xxx','cloud://yyy'], success: res =&gt;{ // 获取临时文件链接 console.log(res.fileList) }, fail: err =&gt;{ // 处理错误 }}) 云函数基础用法之定时器云函数定时器的使用场景函数需要定时、定期执行时，可以使用云函数定时器来进行触发。 如何使用云函数定时触发器在云函数目录下创建 config.json 文件，并设置触发器上传触发器 123{ 'triggers'} WXML 基础tabBar-底部导航设置小程序的状态栏、导航条、标题、窗口背景色客服消息swiper-轮播图拨打电话提示框判断小程序 API 是否在当前版本可用获取系统信息 获取场景值可以在 App 的 onLaunch 和 onShow，或 wx.getLaunchOptionsSync 中获取上述场景值。 123onLaunch: function(e) { console.log(e.scene);} 小程序常见问题API 请求网络请求 基础库兼容 不同页面传值方式 url 传值 数据缓存本地存储 全局变量通过全局变量 微信登陆 相关资料[视频]《入门微信小程序开发》√ [视频]2小时轻松实现人脸识别的小程序√[视频]1-1、微信小程序云开发–自定义tabBar中间凸起效果√ [视频]28 节课快速玩转微信小程序√ [视频]微信小程序入门与实战√ [视频]微信小程序教程√ [视频]《轻松入门微信小程序与云开发》 腾讯云大学重磅打造 —— 小程序学习路径课 小程序自定义tabBar√weapp-qrcode√SelectorQuery wx.createSelectorQuery()√微信小程序操作dom元素节点 wx.createSelectorQuery()√微信小程序动态生成二维码的实现代码√wxapp-qrcode√微信小程序 使用filter过滤器几种方式√regenerator√微信小程序中使用Async-await方法异步请求变为同步请求√微信小程序-实现分享（带参数）√让微信小程序页面之间的通信不在变得困难√微信小程序设置引导页后navigateTo失效√微信小程序setData复杂数组的更新、删除、添加、拼接√微信小程序使用键盘搜索功能√微信小程序正则校验√小程序改造成async/await模式√小程序踩过的一个小坑—解析二维码decodeURIComponent() url解码√微信小程序wx.request二次封装√小程序日志监控工具√腾讯在线教育小程序开发实践之路√[微信小程序] API Promise化√微信小程序之使用函数防抖与函数节流√小程序销毁页面的方法√微信小程序scroll-view bindscrolltolower事件不触发√小程序scroll-view自定义下拉刷新√Painter√wx-charts√github上5个实用的微信小程序开发工具√微信小程序中的日期格式在Android和iOS真机下兼容性问题的坑√getImageInfo一次获取多张图片信息，怎么处理？√微信小程序上传照片后旋转问题解决√微信小程序三种授权登录的方式√一招搞定微信小程序ScrollView等组件高度自适应√在微信小程序中使用 ECharts√echarts-for-weixin√小程序promise工具的使用√强烈推介的几个微信小程序开发小技巧，简单又实用√微信小程序父组件调用子组件方法√微信小程序，格式化千分位并保留两位小数√微信小程序订阅消息踩坑初体验√模板消息√小程序广告投放到达率提升的优化实践(https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/template-message.html)√微信小程序代码最大限制2M的解决方案√2小时轻松实现人脸识别的小程序√ 如何在微信小程序中使用字体图标√ 小程序√ 微信小程序之页面路由(九)√ vant-weapp组件得外部样式类引用说明√ u-miniprogram统计分析埋点√ 微信小程序搜索内容显示关键词高亮√ 小程序实现复制粘贴功能√ 小程序海报生成工具，可视化编辑直接生成代码使用，你的海报你自己做主微信小程序拖拽生成海报 微信H5网页跳转 App、跳转小程序 一起来做小程序直播吧！小程序海报生成工具，可视化编辑直接生成代码使用，你的海报你自己做主微信小程序截屏保存图片小程序如何生成海报分享朋友圈微信小程序canvas生成并保存图片微信小程序 canvas圆角矩形的绘制小程序利用canvas实现波浪动态图，原生canvas的部分限制小程序动态生成canvas海报微信小程序之生成图片分享微信小程序Canvas隐藏 不影响canvas绘图处理办法微信小程序中把页面生成图片openid的获取顺序并解决openid的异步问题如何使用小程序的AR能力微信小程序弹窗组件微信小程序组件封装小程序通过摄像头拍摄个人身份证微信小程序 自定义头部导航栏和导航栏背景图片 navigationStyle微信小程序自定义navigation-bar导航栏(自适应安卓苹果)小程序授权流程化 开源小程序组件 navigation-bar√","link":"/2020/01/22/Blog-about-learning-10/"},{"title":"防抖和节流","text":"防抖（debounce）setTimeout 方法1234567891011var debounce = function(fn, delayTime) { var timeId; // 用于存储定时器 // 闭包 防止 timeId 被销毁 return function() { var context = this, args = arguments; // args 存储传入的参数 timeId &amp;&amp; clearTimeout(timeout); // 判断定时器是否存在，存在则删除定时器 timeId = setTimeout(function{ // 添加定时任务 fn.apply(context, args); }, delayTime) }} 思路解析：执行 debounce 函数之后会返回一个新的函数，通过闭包的形式，维护一个变量 timeId ，每次执行该函数的时候会结束之前的延迟操作，重新执行 setTimeout 方法，也就实现了上面所说的指定的时间内多次触发同一个事件，会合并执行一次。 温馨提示： 上述代码中arguments只会保存事件回调函数中的参数，譬如：事件对象等，并不会保存 fn、delayTime 使用 apply 改变传入的fn方法中的this指向，指向绑定事件的 DOM 元素。 节流（throttle）时间戳123456789101112var throttle = (fn, delayTime) =&gt; { var _start = Date.now(); // 获取当前时间戳 return function () { var _now = Date.now(), context = this, args = arguments; if (_now - _start &gt;= delayTime) { fn.apply(context, args); _start = Date.now(); } };}; 思路解析：我们设置了一个标志变量 flag，当 delayTime 之后执行事件回调，便会把这个变量重置，表示一次回调已经执行结束。 温馨提示： 上述代码中arguments只会保存事件回调函数中的参数，譬如：事件对象等，并不会保存 fn、delayTime 使用 apply 改变传入的fn方法中的this指向，指向绑定事件的 DOM 元素。 定时器12345678910111213var throttle = function (fn, delayTime) { var flag; return function () { var context = this, args = arguments; if (!flag) { flag = setTimeout(function () { fn.apply(context, args); flag = false; }, delayTime); } };}; 定时器 + 时间戳1234567891011121314151617var throttle = function (fn, delayTime) { var flag, _start = Date.now(); return function () { var context = this, args = arguments, _now = Date.now(), remainTime = delayTime - (_now - _start); if (remainTime &lt;= 0) { fn.apply(this, args); } else { setTimeout(function () { fn.apply(this, args); }, remainTime); } };}; requestAnimationFrame1234567891011var throttle = function (fn, delayTime) {var flag; return function () { if (!flag) { requestAnimationFrame(function() { fn(); flag = false; }); flag = true ; }} 保证在屏幕刷新的时候（对于大多数的屏幕来说，大约16.67ms），可以执行一次回调函数 fn。使用这种方式也存在一种比较明显的缺点，时间间隔只能跟随系统变化，我们无法修改，但是准确性会比 setTimeout 高一些。 温馨提示： 防抖和节流只是减少了事件回调函数的执行次数，并不会减少事件的触发频率。 防抖和节流并没有从本质上解决性能问题，我们还应该注意优化我们事件回调函数的逻辑功能，避免在回调中执行比较复杂的DOM操作，减少浏览器reflow和repaint。 underscore 源码debounce1234567891011121314151617181920212223_.debounce = function (func, wait, immediate) { var timeout, result; var later = function (context, args) { timeout = null; if (args) result = func.apply(context, args); }; var debounced = restArguments(function (args) { if (timeout) clearTimeout(timeout); if (immediate) { var callNow = !timeout; timeout = setTimeout(later, wait); if (callNow) result = func.apply(this, args); } else{ timeout = _.delay(later, wait, this, args); } return result; }); debounced.cancel = function() { clearTimeout(timeout); timeout = null; }; return debounced;}; throttle123456789101112131415161718192021222324252627282930313233343536_.throttle = function (func, wait, options) { var timeout, context, args, result; var previous = 0; if (!options) options = {}; var later = function () { previous = options.leading === false ? 0: _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; var throttled = function () { var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if(!timeout &amp;&amp; options.trailing !== false) { timeout = setTimeout(later, remaining); } return result; }; throttled.cancel = function() { clearTimeout(timeout); previous = 0; timeout = context = args = null; }; return throttled;}; 以上是我对下列视频及文章的归纳和总结。十分钟学会防抖和节流√函数防抖与函数节流","link":"/2020/06/14/Blog-about-learning-101/"},{"title":"请求","text":"说说对 options 请求的理解√","link":"/2020/06/14/Blog-about-learning-102/"},{"title":"Vuex 基础入门","text":"状态管理模式问题：当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏并产生以下问题： 多个视图依赖于同一状态 来自不同视图的行为需要变更同一状态 解决方法： 将数据以及操作数据的行为都定义在父组件； 将数据以及操作数据的行为传递给需要的各个子组件（有可能需要多级传递） 上述的解决方法并未根本上解决问题，随着项目的复杂会暴露出以下问题： 传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 因此，为什么不把组件的共享状态抽取出来，以全局单例模式管理呢？通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。这就是 Vuex 背后的基本思想。 VuexVue 简介Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 使用 Vuex中大型单页应用：Vuex小型单页应用：store 模式 store 模式安装1yarn add vuex 1234import Vue from 'vue'import Vuex from 'vuex'new Vuex.Store({})Vue.use(Vuex) es6-promiseVuex 依赖 promise，浏览器不支持 promise，需要引入 es6-promise 1yarn add es6-promise 1import 'es6-promise/auto' Store(仓库)Vuex 应用的核心 Store，Store 包含应用中大部分的状态 state。 Vuex 和 全局对象的不同 Vuex 的状态存储是响应式的 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation 基础示例12345678910111213141516171819202122232425262728293031323334353637// main.jsimport Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &quot;es6-promise/auto&quot;;import Vuex from &quot;vuex&quot;;Vue.config.productionTip = false;Vue.use(Vuex);const store = new Vuex.Store({ state: { count: 0, }, mutations: { increment(state) { state.count++; }, },});store.commit('increment'); // 触发状态变更console.log(store.state.count); // 获取状态对象// 组件中this.$store.commit('increment')console.log(this.$store.state.count)// 或者在计算属性中computed: { count() { return this.$store.state.count; },}new Vue({ store, render: (h) =&gt; h(App),}).$mount(&quot;#app&quot;); Vuex 计数器应用123456789101112131415161718192021222324// main.jsimport Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &quot;es6-promise/auto&quot;;import Vuex from &quot;vuex&quot;;Vue.config.productionTip = false;Vue.use(Vuex);const store = new Vuex.Store({ state: { count: 0, }, mutations: { increment: state =&gt; state.count++, decrement: state =&gt; state.count-- },});new Vue({ store, render: (h) =&gt; h(App),}).$mount(&quot;#app&quot;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{ count }}&lt;/p&gt; &lt;p&gt; &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decrement&quot;&gt;-&lt;/button&gt; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: &quot;App&quot;, components: {}, computed: { count() { return this.$store.state.count; }, }, methods: { increment() { this.$store.commit(&quot;increment&quot;); }, decrement() { this.$store.commit(&quot;decrement&quot;); }, }, created: function() { console.log(this.$store.state.count); },};&lt;/script&gt;&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; state（状态）组件中获取 Vuex 状态 12345678910111213141516&lt;script&gt;// App.vueimport { mapState } from &quot;vuex&quot;;export default { name: &quot;App&quot;, components: {}, computed: { count () { return this.$store.state.count } ), created: function() { console.log(this.$store.state.count); },};&lt;/script&gt; mapState1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;// App.vueimport { mapState } from &quot;vuex&quot;;export default { name: &quot;App&quot;, components: {}, data() { return { localCount: 4, }; }, methods: { increment() { this.$store.commit(&quot;increment&quot;); }, decrement() { this.$store.commit(&quot;decrement&quot;); }, }, computed: mapState({ count: (state) =&gt; state.count, countAlias: &quot;count&quot;, countPlusLocalState(state) { return state.count + this.localCount; }, }), // computed: mapState([ // // 映射 this.count 为 store.state.count // 'count' // ]), created: function() { console.log(this.$store.state.count); },};&lt;/script&gt; 对象展开运算符 123456789101112131415161718192021222324252627282930&lt;script&gt; // App.vue import { mapState } from &quot;vuex&quot;; export default { name: &quot;App&quot;, components: {}, data() { return { localCount: 4, }; }, methods: { increment() { this.$store.commit(&quot;increment&quot;); }, decrement() { this.$store.commit(&quot;decrement&quot;); }, }, computed: { // 使用对象展开运算符将此对象混入到外部对象中 ...mapState({ count: &quot;count&quot;, }), }, created: function() { console.log(this.$store.state.count); }, }; &lt;/script&gt; getter（state 计算属性）12345678910111213141516171819202122232425262728293031323334// main.jsimport Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &quot;es6-promise/auto&quot;;import Vuex from &quot;vuex&quot;;Vue.config.productionTip = false;Vue.use(Vuex);const store = new Vuex.Store({ state: { todos: [ { id: 1, text: &quot;...&quot;, done: true }, { id: 2, text: &quot;...&quot;, done: false }, ], }, getters: { doneTodos: (state) =&gt; { return state.todos.filter((todo) =&gt; todo.done); }, doneTodosCount: (state, getters) =&gt; { return getters.doneTodos.length; }, getTodoById: (state) =&gt; (id) =&gt; { return state.todos.find((todo) =&gt; todo.id === id); }, },});new Vue({ store, render: (h) =&gt; h(App),}).$mount(&quot;#app&quot;); mapGetters跟 mapState 用法类似 12345678910111213141516171819202122232425262728293031323334353637383940414243// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt;Completed Todos: {{ doneTodosCount }}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapGetters } from &quot;vuex&quot;;export default { name: &quot;App&quot;, components: {}, data() { return { localCount: 4, }; }, methods: { increment() { this.$store.commit(&quot;increment&quot;); }, decrement() { this.$store.commit(&quot;decrement&quot;); }, }, computed: { ...mapGetters([&quot;doneTodosCount&quot;]), }, created: function() { // 方法访问 console.log(this.$store.getters.getTodoById(1)); },};&lt;/script&gt;&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; Mutation（处理数据）1234567891011121314151617181920212223242526// main.jsimport Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &quot;es6-promise/auto&quot;;import Vuex from &quot;vuex&quot;;Vue.config.productionTip = false;Vue.use(Vuex);const store = new Vuex.Store({ state: { count: 1, }, mutations: { increment(state, payload) { // 提交负荷 state.count += payload.amount; }, },});new Vue({ store, render: (h) =&gt; h(App),}).$mount(&quot;#app&quot;); 1234567891011121314151617181920212223242526272829303132333435363738394041// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; Completed Todos: {{ count }} &lt;button @click=&quot;increment&quot;&gt;+10&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapState } from &quot;vuex&quot;;export default { name: &quot;App&quot;, components: {}, data() { return {}; }, methods: { increment() { // 提交负荷 this.$store.commit(&quot;increment&quot;, { amount: 10 }); // 对象风格 // this.$store.commit({type: 'increment', amount: 10 }); }, }, computed: { ...mapState([&quot;count&quot;]), }, created: function() {},};&lt;/script&gt;&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; mapMutations123456789101112131415161718192021222324252627282930313233343536// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; Completed Todos: {{ count }} &lt;button @click=&quot;increment({ amount: 10 })&quot;&gt;+10&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapState, mapMutations } from &quot;vuex&quot;;export default { name: &quot;App&quot;, components: {}, data() { return {}; }, methods: { ...mapMutations([&quot;increment&quot;]), }, computed: { ...mapState([&quot;count&quot;]), }, created: function() {},};&lt;/script&gt;&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; Mutation 需遵守 Vue 的响应规则 在 store 中初始化好所有所需属性 当需要在对象上添加新属性时 12Vue.set(obj, 'newProp', 123)state.obj = { ...state.obj, newProp: 123 } Action(异步处理数据)123456789101112131415161718192021222324252627282930313233343536373839// main.jsimport Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &quot;es6-promise/auto&quot;;import Vuex from &quot;vuex&quot;;Vue.config.productionTip = false;Vue.use(Vuex);const store = new Vuex.Store({ state: { count: 1, }, mutations: { increment(state, payload) { // 变更状态 state.count += payload.amount; }, }, actions: { incrementAsync(context,payload) { setTimeout(() =&gt; { // 载荷形式 context.commit(&quot;increment&quot;, payload); }, 1000); }, // incrementAsync({ commit }) { // setTimeout(() =&gt; { // commit(&quot;increment&quot;); // }, 1000); // }, },});new Vue({ store, render: (h) =&gt; h(App),}).$mount(&quot;#app&quot;); 12345678910111213141516171819202122232425262728293031323334353637383940// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; Completed Todos: {{ count }} &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapState } from &quot;vuex&quot;;export default { name: &quot;App&quot;, components: {}, data() { return {}; }, methods: { increment() { // 载荷形式 this.$store.dispatch(&quot;incrementAsync&quot;, { amount: 10 }); // this.$store.dispatch(&quot;incrementAsync&quot;); }, }, computed: { ...mapState([&quot;count&quot;]), }, created: function() {},};&lt;/script&gt;&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; mapActions1234567891011121314151617181920212223242526272829303132333435363738// App.vue&lt;template&gt;&lt;div id=&quot;app&quot;&gt; Completed Todos: {{ count }} &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapState, mapActions } from &quot;vuex&quot;;export default { name: &quot;App&quot;, components: {}, data() { return {}; }, methods: { ...mapActions(['incrementAsync']), increment() { this.incrementAsync({ amount: 10 }) }, }, computed: { ...mapState([&quot;count&quot;]), }, created: function() {},};&lt;/script&gt;&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; 组合 Action结合 promise、async 1234567891011121314151617181920212223242526272829303132333435363738394041424344// main.jsimport Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &quot;es6-promise/auto&quot;;import Vuex from &quot;vuex&quot;;Vue.config.productionTip = false;Vue.use(Vuex);const store = new Vuex.Store({ state: { count: 1, }, mutations: { increment(state, payload) { // 变更状态 state.count += payload.amount; }, }, actions: { // incrementAsync(context, payload) { // return new Promise((resolve) =&gt; { // setTimeout(() =&gt; { // context.commit(&quot;increment&quot;, payload); // resolve(); // }, 1000); // }); // }, incrementAsync({ commit }, payload) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { commit(&quot;increment&quot;, payload); resolve(); }, 1000); }); }, },});new Vue({ store, render: (h) =&gt; h(App),}).$mount(&quot;#app&quot;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; Completed Todos: {{ count }} &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { mapState, mapActions } from &quot;vuex&quot;;export default { name: &quot;App&quot;, components: {}, data() { return {}; }, methods: { ...mapActions([&quot;incrementAsync&quot;]), // increment() { // this.incrementAsync({ amount: 10 }).then(() =&gt; { // setTimeout(() =&gt; { // console.log(111); // }, 1000); // }); // }, async increment() { await this.incrementAsync({ amount: 10 }); console.log(222); setTimeout(() =&gt; { console.log(111); }, 1000); }, }, computed: { ...mapState([&quot;count&quot;]), }, created: function() {},};&lt;/script&gt;&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; Module（模块）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// main.jsimport Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &quot;es6-promise/auto&quot;;import Vuex from &quot;vuex&quot;;Vue.config.productionTip = false;Vue.use(Vuex);const moduleA = { state: { count: 3, }, mutations: { increment(state) { // 这里的 `state` 对象是模块的局部状态 state.count++; }, }, getters: { sumWithRootCount(state, getters, rootState) { return state.count + rootState.count; // rootState 为根节点状态 }, }, actions: { incrementIfOddOnRootSum({ state, commit, rootState }) { if ((state.count + rootState.count) % 2 === 1) { commit(&quot;increment&quot;); } }, },};const moduleB = { state: { count: 8, }, mutations: {}, getters: {}, actions: {},};const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB, }, state: { count: 10, },});new Vue({ store, render: (h) =&gt; h(App),}).$mount(&quot;#app&quot;);console.log(store.state.a.count);console.log(store.state.b.count); 1234567891011121314151617181920212223242526272829303132333435363738394041// App.vue &lt;template&gt; &lt;div id=&quot;app&quot;&gt; Completed Todos: {{ count }} &lt;button @click=&quot;increment&quot;&gt;+&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: &quot;App&quot;, components: {}, data() { return {}; }, methods: { increment(){ // 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的 this.$store.dispatch(&quot;incrementIfOddOnRootSum&quot;); } }, computed: { count() { return this.$store.getters.sumWithRootCount }, }, created: function() {},};&lt;/script&gt;&lt;style&gt;#app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px;}&lt;/style&gt; 相关资料Vuex√store 模式√大白话理解Vuex√从头开始学习Vuex√Vuex 注入 Vue 生命周期的过程[视频]Scrimba 上的 Vuex 课程√[视频]vuex基础入门√","link":"/2020/06/14/Blog-about-learning-103/"},{"title":"Vue 源码","text":"vue 虚拟dom实现原理Vue源码解析：虚拟dom比较原理vue虚拟dom原理剖析面试官：谈谈你对虚拟DOM原理的理解？vue核心之虚拟DOM(vdom)详解Vue中的虚拟DOM深入剖析：Vue核心之虚拟DOM浅谈Vue虚拟DOM技术虚拟DOM深入理解Vue2.x的虚拟DOM diff原理Vue原理解析（四）：你知道被大家聊烂了的虚拟Dom是怎么生成的吗？【Vue】基础（虚拟DOM &amp; 响应式原理）vue的重要基本原理（一）：虚拟DOM","link":"/2020/06/14/Blog-about-learning-106/"},{"title":"虚拟 DOM","text":"虚拟 DOM缺点 代码更多，体积更大 内存占用增大 小量的单一的 dom 修改使用虚拟 dom 成本反而更高，不如直接修改真实 dom 快 snabbdomVirual DOMVirual DOM 是 JS 对象记录一个 dom 节点的副本，当 dom 发生更改时候，先用虚拟 dom 进行 diff，算出最小差异，再修改真实的 dom。 vue虚拟dom原理√[视频]Vue中的虚拟dom实现原理VueVuesnabbdom阅读分析snabbdom源码snabbdom.js虚拟dom应用snabbdom入门使用snabbdomsnabbdom 实现原理Virtual DOM和snabbdom.jssnabbdomSnabbdom.js（一）你不知道的Virtual DOM（一）：Virtual Dom介绍Virtual-Dom理解Virtual DOM虚拟DOM（Virtual DOM）合格前端系列第五弹- Virtual Dom &amp;&amp; Diff（迁移）","link":"/2020/06/14/Blog-about-learning-107/"},{"title":"","text":"","link":"/2020/06/14/Blog-about-learning-108/"},{"title":"瀑布流布局","text":"JS 实现瀑布流column 多行布局实现瀑布流flex 弹性布局实现瀑布流3种方式对比需要动态加载数据，需要使用 JS + jQuery 3种方式实现瀑布流布局小程序瀑布流组件:支持翻页与图片懒加载","link":"/2020/06/25/Blog-about-learning-109/"},{"title":"如何告别 if else","text":"实际例子：不同管理员权限不一样，能够行使的操作也不一样。 123456789101112131415publicclassJudgeRole{ publicString judge(String roleName ) { String result = &quot;&quot;; if (roleName.equals( &quot;ROLE_ROOT_ADMIN&quot; )) { // 系统管理员有A权限 result = &quot;ROLE_ROOT_ADMIN: &quot; + &quot;has AAA permission&quot; ; }elseif( roleName.equals(&quot;ROLE_ORDER_ADMIN&quot;) ) { // 订单管理员有B权限 result = &quot;ROLE_ORDER_ADMIN: &quot; + &quot;has BBB permission&quot; ; }elseif( roleName.equals(&quot;ROLE_NORMAL&quot;) ) {// 普通用户有C权限 result = &quot;ROLE_NORMAL: &quot; + &quot;has CCC permission&quot; ; }else{ result = &quot;XXX&quot; ; } return result; }} 枚举什么角色能干什么事，这很明显有一个对应关系。 123456789101112131415161718192021222324252627282930313233343536// 首先定义一个公用接口 RoleOperation，表示不同角色所能做的操作：publicinterfaceRoleOperation{ String op(); // 表示某个角色可以做哪些op操作}// 将不同角色的情况全部交由枚举类来做，定义一个不同角色有不同权限的枚举类 RoleEnum：publicenumRoleEnumimplementsRoleOperation{ // 系统管理员(有A操作权限) ROLE_ROOT_ADMIN { @Override publicString op() { return &quot;ROLE_ROOT_ADMIN:&quot; + &quot; has AAA permission&quot;; } }, // 订单管理员(有B操作权限) ROLE_ORDER_ADMIN { @Override publicString op() { return &quot;ROLE_ORDER_ADMIN:&quot; + &quot; has BBB permission&quot;; } }, // 普通用户(有C操作权限) ROLE_NORMAL { @Override publicString op() { return &quot;ROLE_NORMAL:&quot; + &quot; has CCC permission&quot;; } },}// 调用publicclassJudgeRole { publicString judge( String roleName ) {// 一行代码搞定！之前的if/else没了！ returnRoleEnum.valueOf(roleName).op(); }} 工厂模式不同分支做不同的事情，很明显就提供了使用工厂模式的契机，我们只需要将不同情况单独定义好，然后去工厂类里面聚合即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 针对不同的角色，单独定义其业务类：// 系统管理员(有 A 操作权限)publicclassRootAdminRoleimplementsRoleOperation { privateString roleName; publicRootAdminRole(String roleName ) { this.roleName = roleName; } @Override publicString op() { return roleName + &quot; has AAA permission&quot; ; }}// 订单管理员(有 B 操作权限)publicclassOrderAdminRoleimplementsRoleOperation { privateString roleName; publicOrderAdminRole( String roleName ) { this.roleName = roleName; } @Override publicString op() { return roleName + &quot; has BBB permission&quot;; }}// 普通用户(有 C 操作权限)publicclassNormalRoleimplementsRoleOperation { privateString roleName; publicNormalRole( String roleName ) { this.roleName = roleName; } @Override publicString op() { return roleName + &quot; has CCC permission&quot;; }}// 接下来再写一个工厂类 RoleFactory对上面不同角色进行聚合：publicclassRoleFactory { staticMap &lt; String, RoleOperation &gt; roleOperationMap = newHashMap &lt;&gt;(); // 在静态块中先把初始化工作全部做完 static{ roleOperationMap.put( &quot;ROLE_ROOT_ADMIN&quot;, newRootAdminRole(&quot;ROLE_ROOT_ADMIN&quot;) ); roleOperationMap.put( &quot;ROLE_ORDER_ADMIN&quot;, newOrderAdminRole(&quot;ROLE_ORDER_ADMIN&quot;) ); roleOperationMap.put( &quot;ROLE_NORMAL&quot;, newNormalRole(&quot;ROLE_NORMAL&quot;) ); }publicstaticRoleOperation getOp( String roleName ) { return roleOperationMap.get( roleName ); }}// 调用publicclassJudgeRole{ publicString judge( String roleName ) { // 一行代码搞定！之前的 if/else也没了！ returnRoleFactory.getOp(roleName).op(); }} 策略模式123456789101112131415161718192021222324252627282930313233// 按照策略模式的指导思想，我们也来创建一个所谓的策略上下文类，这里命名为 RoleContext：publicclassRoleContext { // 可更换的策略，传入不同的策略对象，业务即相应变化 privateRoleOperation operation; publicRoleContext( RoleOperation operation ) { this.operation = operation; } publicString execute() { return operation.op(); }}//很明显上面传入的参数 operation就是表示不同的“策略”。我们在业务代码里传入不同的角色，即可得到不同的操作结果publicclassJudgeRole { publicString judge( RoleOperation roleOperation ) { RoleContext roleContext = newRoleContext( roleOperation ); return roleContext.execute(); }}publicstaticvoid main( String[] args ) { JudgeRole judgeRole = newJudgeRole(); String result1 = judgeRole.judge( newRootAdminRole(&quot;ROLE_ROOT_ADMIN&quot;)); System.out.println( result1 ); String result2 = judgeRole.judge( newOrderAdminRole(&quot;ROLE_ORDER_ADMIN&quot;)); System.out.println( result2 ); String result3 = judgeRole.judge( newNormalRole(&quot;ROLE_NORMAL&quot;)); System.out.println( result3 );} 参考文章答应我，别再 if/else 走天下了可以吗？","link":"/2020/01/24/Blog-about-learning-11/"},{"title":"优化逻辑判断","text":"入门switch三元运算\\逻辑与运算符\\includes中级数组/对象 相关资料你可以这样优化 if-else 代码√编写高质量可维护的代码之优化逻辑判断","link":"/2020/06/29/Blog-about-learning-110/"},{"title":"前端存储","text":"HTTP cookiesHTTP Cookie（Web Cookie 或者浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登陆状态。Cookie 是基于无状态的HTTP协议记录稳定的状态信息成为了可能。 Cookie 的本职工作并非本地存储，而是“维持状态”HTTP协议是无状态的，HTTP协议自身不对请求和响应之间的通信状态进行保存。Cookie指某些网站为了辨别用户身份而储存在用户本地终端上的数据(通常经过加密)。 cookie是服务端生成，客户端进行维护和存储。 服务器 → 浏览器 → 存储在本地浏览器再发起请求会携带 cookie → 服务器 Cookie 主要用于以下三个方面： 会话状态管理（如用户登陆状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） Cookie 用于客户端数据的存储，随着浏览器开始支持各种各样的存储方法，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器API已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话村存储）或 IndexedDB。 Cookie 的特点 Cookie 的大小受限，一般为 4 KB 同一个域名下存放 Cookie 的个数是有限制的，不同浏览器的个数不一样，一般为 20 个 Cookie 支持设置过期时间，当过期时自动销毁 每次发起同域下的 HTTP 请求时，都会携带当前域名下的 Cookie 支持设置为 HttpOnly，防止 Cookie 被客户端的 JavaScript 访问 创建 Cookie当服务器收到 HTTP 请求时，服务器可以在响应头里面添加一个 Set-Cookie选项。浏览器收到响应后通常会保存下 Cookie，之后对该服务器每次请求中都通过 Cookie 请求头部将 Cookie 信息发送给服务器。另外，Cookie 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。 Set-Cookie 响应头和 Cookie 请求头部服务器使用 Set-Cookie 响应头部向用户代理（一般是浏览器）发送 Cookie信息。Set-cookie ： &lt;cookie名&gt; = &lt;cookie值&gt;服务器通过该头部告知客户端保存 Cookie 信息。 PHPNode.jsPythonRuby on Rails 现在，对该服务器发起的每次新请求，浏览器都会将之前保存的 Cookie 信息通过 Cookie 请求头部发送给服务器。 会话期 Cookie会话期 Cookie ：浏览器关闭之后它会被自动删除，它仅在会话期内有效。会话期 Cookie 不需要指定过期时间（Expires）或者有效期（Max-Age）。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。 持久性 Cookie和关闭浏览器的会话期 Cookie 不同，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。 当 Cookie 的过期时间被设定时，设定的日期和时间只于客户端相关，而不是服务端。 Cookie 的 Secure 和 HttpOnly 标记标记为 Secure 的 Cookie 只应通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确定的安全保障。从 Chrome 52 和 Firefox 52 开始，不安全的站点 （http:）无法使用 Cookie 的 Secure 标记。 为避免跨域脚本（XSS）攻击，通过 Javascript 的 Document.cookie API 无法访问带有 HttpOnly 标记的 Cookie，它们只应该发送给服务器。如果包含服务端 Session 信息的 Cookie 不想被客户端 Javascript 脚本调用，那么就应该为其设置 HttpOnly 标记。 Cookie 的作用域Domain 和 Path 标识定义了 Cookie的作用域：即 Cookie 应该发送那些 URL。 Domain 标识指定了哪些主机可以接收 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain ，则一般包含子域名。 例如：如果设置 Domain = mozilla.org，则 Cookie 也包含在子域名中 （如 developer.mozilla.org）。 Path 标识指定了主机下哪些路可以接收 Cookie （该 URL 路径必须存在于请求 URL 中）。以字符 %x2F （”/“）作为路径分隔符，子路径也会被匹配。 例如，设置 Path = /docs，则以下地址都会匹配： /docs/docs/Web/docs/Web/HTTP SameSite CookiesSameSite Cookie 允许服务器要求某个 cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。但是目前 SameSite Cookie 还处于实验阶段，并不是所有浏览器都支持。 JavaScript 通过 Document.cookies 访问 Cookie通过 Document.cookie 属性可创建新的 Cookie ，也可通过该属性访问非 HttpOnly 标记的 Cookie。 1234document.cookie = &quot;yummy_cookie=choco&quot;; document.cookie = &quot;tasty_cookie=strawberry&quot;; console.log(document.cookie); // logs &quot;yummy_cookie=choco; tasty_cookie=strawberry&quot; 123456// 得到名为 test2 的 cookiedocument.cookie = &quot;test1=Hello&quot;;document.cookie = &quot;test2=World&quot;;var myCookie = document.cookie.replace(/(?:(?:^|.*;\\s*)test2\\s*\\=\\s*([^;]*).*$)|^.*$/, &quot;$1&quot;);alert(myCookie); 请留意在安全节提到的安全隐患，JavaScript 可以通过跨站脚本攻击 （XSS）的方式来窃取 Cookie。 安全当机器处于不安全环境时，切记不能通过 HTTP Cookie 存储、传输敏感信息。 会话劫持和XSS在 Web 应用中，Cookie 常用来标记用户或授权会话。Web 应用的Cookie 被窃取，可能导致授权用户的会话受到攻击。常用的窃听 Cookie 的方式有利用社会工程学攻击和利用应用程序漏洞进行 XSS 攻击。 HttpOnly 类型的 Cookie 由于阻止了 JavaScript 对其的访问性而能在一定程度上缓解此类攻击。 跨站请求伪造（CSRF）阻止此类事件的发生： 对用户输入进行过滤来阻止 XSS； 任何敏感操作都需要确认； 用于敏感信息的 Cookie 只能拥有较短的生命周期； session为什么要有 session？HTTP是无状态的 web 应用的特点 用户每执行一个操作，就要与服务器重新建立一个连接 http是无状态的 每次操作建立的连接，在操作结束后，连接都会断开 连接断开后，连接所使用的资源，默认都自动释放 优点：快速释放资源，给其它更多的人，增大服务器的负载能力缺点：即使同一个用户的新连接，也无法得到上次连接的状态和数据 Session：是服务器内存中的一个对象 session 允许将数据库在Web服务器上，从而在整个用户会话过程中保持任何数据。 用户会话是指用户在浏览器某个网站时，从进入网站到关闭浏览器搜经过的这段时间 生命周期 打开新浏览器窗口，首次请求服务器时，浏览器就与服务器建立 session。服务器自动给客户端分配一个唯一的标识（sessionid）被存储于cookie中。强调：从当前浏览器窗口打开的新链接，不再建立新session，而是和第一打开的窗口共用同一个session。 Web StorageWeb Storage 包括如下两种机制： sessionStorage 为每个给定的源 （give origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只能浏览器处于打开状态，包括页面重新加载和恢复）。 localStorage 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。 这两种机制是通过 window.sessionStorage 和 window.localStorage 属性使用（更确切的说，在支持的浏览器中 Window 对象实现了 WindowLocalStorage和 WindowSessionStorage 对象并挂在其 localStorage 和 sessionStorage属性下）—— 调用其中任一对象会创建 Storage 对象，通过 Storage 对象，可以设置、获取和移动数据项，对于每个源（origin）sessionStorage 和 localStorage 使用不同的 Storage 对象 —— 独立运行和控制。 localStorage存储在 localStorage 的数据可以长期保留； localStorage 的特点 大小限制为 5MB ~10MB； 在同源的所有标签页和窗口之间共享数据； 数据仅保存在客户端，不与服务器进行通信； 数据持久存在且不会过期，重启浏览器后仍然存在； 对数据的操作是同步的。 基础用法12345678// 添加修改localStorage.setItem('myCat', 'Tom');// 读取 localStoragelet cat = localStorage.getItem('myCat');// 移除 localStorage 项localStorage.removeItem('myCat');// 移除所有的 localStoragelocalStorage.clear(); localStorage 功能检测12345678910111213141516171819202122232425262728293031323334// 测试可用性function storageAvailable(type) { var storage; try { storage = window[type]; var x = '__storage_test__'; storage.setItem(x, x); storage.removeItem(x); return true; } catch(e) { return e instanceof DOMException &amp;&amp; ( // everything except Firefox e.code === 22 || // Firefox e.code === 1014 || // test name field too, because code might not be present // everything except Firefox e.name === 'QuotaExceededError' || // Firefox e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &amp;&amp; // acknowledge QuotaExceededError only if there's something already stored (storage &amp;&amp; storage.length !== 0); }}// 测试 localStorageif (storageAvailable('localStorage')) { // Yippee! We can use localStorage awesomeness}else { // Too bad, no localStorage for us}// 测试 sessionStoragestorageAvailable('sessionStorage') 兼容性cookies 对 localStorage 对象的实现。 localStorage sessionStoragesessionStorage 是一种会话级别的缓存，关闭浏览器时数据会被清除 sessionStorage 的特点 页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。 在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同。 打开多个相同的URL的Tabs页面，会创建各自的sessionStorage。 关闭对应浏览器tab，会清除对应的sessionStorage 与 localStorage 拥有统一的 API 接口； 对数据的操作是同步的。 基础用法123456789// 添加修改数据sessionStorage.setItem('key', 'value');// 获取数据let data = sessionStorage.getItem('key');// 删除数据sessionStorage.removeItem('key');// 清除数据sessionStorage.clear(); Web SQLHTML5 已经放弃 Web SQL 数据库。 Web SQL Database 规范中定义的三个核心方法 openDatabase：这个方法使用现有数据库或新建数据库来创建数据库对象； transaction：这个方法允许我们根据情况控制事务的提交或回滚； executeSql：这个方法用于执行真实的 SQL 语句。 Web SQL 的特点 Web SQL 能方便进行对象存储； Web SQL 支持事务，能方便地进行数据查询和数据处理操作。 基础用法123456789var db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);db.transaction(function (tx) { // 执行查询操作 tx.executeSql('CREATE TABLE IF NOT EXISTS LOGS (id unique, log)'); // 执行插入操作 tx.executeSql('INSERT INTO LOGS (id, log) VALUES (1, &quot;foobar&quot;)'); tx.executeSql('INSERT INTO LOGS (id, log) VALUES (2, &quot;logmsg&quot;)'); }); IndexedDBIndexedDB 是一种低级API,用于客户端存储大量结构化数据（包括，文件/blobs）。该API 使用索引实现对该数据的高性能搜索。虽然 Web Storage 对于存储较少量的数据很有用，对于存储更大量的结构化数据 IndexedDB 提供了一个解决方案。 IndexedDB 是一个事务性数据库系统，类似于基于 SQL 的 RDBMS。不同的是它使用固定的列表，IndexedDB 是一个基于 JavaScript 的面向对象的数据库。IndexedDB 允许您存储和检索用检索用键索引的对象；可以存储 structured clone algorithm 支持的任何对象。只需要指定数据库模式，打开于数据库的连接，然后检索和更新一些列事务中的数据。 IndexedDB 是一种可以让你在用户的浏览器内持久化存储数据的方法。IndexedDB 为生成 Web Application 提供了丰富的查询能力，使我们的应用在在线和离线时都可以正常工作。 IndexedDB 的特点 存储空间大：存储空间可以达到几百兆甚至更多； 支持二进制存储：它不仅可以存储字符串，而且还可以存储二进制数据； IndexedDB 有同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问； 支持事务型：IndexedDB 执行的操作会按照事务来分组的，在一个事务中，要么所有的操作都成功，要么所有的操作都失败； 键值对存储：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以 “键值对” 的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。 数据操作是异步的：使用 IndexedDB 执行的操作是异步执行的，以免阻塞应用程序。 基础用法123456789101112131415161718192021222324252627282930313233343536var dbName = &quot;my_db&quot;;// 打开数据库var request = indexedDB.open(dbName, 2); // 数据库名称 数据库版本// 打开数据库失败request.onerror = function(event) { // 错误处理};// 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded。request.onupgradeneeded = function(event) { // 拿到数据库实例 var db = event.target.result; // 建立一个对象仓库来存储我们客户的相关信息，我们选择 ssn 作为键路径（key path） // 因为 ssn 可以保证是不重复的 ssn 是主键 var objectStore; if (!db.objectStoreNames.contains('person')) { objectStore = db.createObjectStore(&quot;customers&quot;, { keyPath: &quot;ssn&quot; }); // IndexedDB 自动生成主键。 // var objectStore = db.createObjectStore( 'person', { autoIncrement: true }) } // 建立一个索引来通过姓名来搜索客户。名字可能会重复，所以我们不能使用 unique 索引 objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, { unique: false }); // 使用邮箱建立索引，我们确保客户的邮箱不会重复，所以我们使用 unique 索引 objectStore.createIndex(&quot;email&quot;, &quot;email&quot;, { unique: true }); // 使用事务的 oncomplete 事件确保在插入数据前对象仓库已经创建完毕 objectStore.transaction.oncomplete = function(event) { // 将数据保存到新创建的对象仓库 var customerObjectStore = db.transaction(&quot;customers&quot;, &quot;readwrite&quot;).objectStore(&quot;customers&quot;); customerData.forEach(function(customer) { customerObjectStore.add(customer); }); };}; 开源库ShareDBShareDB 是一个基于 JSON 文档操作转换（OT）的实时数据库后端。它是 DerbyJS Web 应用程序框架的实时后端。 ImmortalDBImmortalDB是在浏览器中存储持久键值数据的最佳方法。保存到ImmortalDB的数据被冗余地存储在 Cookies， IndexedDB和 LocalStorage中，并且如果其中的任何数据被删除或损坏，它们将不断进行自我修复。 web-storage-cacheWebStorageCache 对 HTML5 localStorage 和 sessionStorage 进行了扩展，「添加了超时时间，序列化方法」。可以直接存储 JSON 对象，同时可以非常简单的进行超时时间的设置。 lz-stringlz-string 旨在满足在 localStorage 中（尤其是在移动设备上）存储大量数据的需求。localStorage 通常限制为 5MB ~10MB，你可以通过对数据进行压缩，以存储更多的数据。 主流数据库localForagelocalForage 是一个快速简单的 JavaScript 存储库。它通过使用类似于 localStorage 的简单 API 来使用异步存储（IndexedDB 或 WebSQL)），进而改善你的 Web 应用程序的离线体验。 对于不支持 IndexedDB 或 WebSQL 的浏览器，localForage 会使用 localStorage 进行数据存储。此外，localForage 还支持存储所有可以序列化为 JSON 的原生 JS 对象以及 ArrayBuffers，Blob 和 TypedArrays。 PouchDBPouchDB 是一个浏览器内数据库，允许应用程序在本地保存数据，以便用户即使在离线时也可以享受应用程序的所有功能。另外，数据在客户端之间是同步的，因此用户可以随时随地保持最新状态 RxdbRxDB（Reactive Database 的缩写）是 NoSQL 数据库，用于 JavaScript 应用程序，如网站，混合应用程序，Electron Apps，Progressive Web Apps 和 Node.js。响应式意味着你不仅可以查询当前状态，还可以订阅所有状态更改，比如查询的结果或文档的单个字段。 NeDBNeDB 是一个 JavaScript 数据库，能够运行在 Node.js、nw.js、Electron 和浏览器环境。它是使用纯的 JavaScript 实现，不依赖其它库，提供的 API 是 MongoDB API 的子集，重要的是它的速度非常快： Dexie.jsDexie.js 是 IndexedDB 的包装库，它提供了一套经过精心设计的 API，强大的错误处理，较强的可扩展性，此外它能够跟踪数据变化，支持 KeyRange (搜索不区分大小写，可设置匹方式和 OR 操作)。 Lowdb适用于Node，Electron和浏览器的小型JSON数据库。由Lodash驱动。 LovefieldLovefield是用纯JavaScript编写的关系数据库。它提供类似SQL的语法并可以跨浏览器运行（当前支持Chrome 37 +，Firefox 31 +，IE 11 +，Edge和Safari 10+）。 LokiJSLokiJS是一个以javascript编写的面向文档的数据库，已根据MIT许可证发布。其目的是以nosql方式将javascript对象存储为文档，并以类似的机制对其进行检索。在节点（包括cordova / phonegap和node-webkit），本机 脚本和浏览器中运行。 相关资料前端存储除了 localStorage 还有啥√浏览器存储√HTTP cookies√Web Storage API√使用 Web Storage API√Window.localStorage√LocalStorage√Window.sessionStorage√IndexedDB√ 详细后期用到在看使用 IndexedDB浏览器数据库 IndexedDB 入门教程网道","link":"/2020/06/29/Blog-about-learning-111/"},{"title":"小程序采坑","text":"组件scroll-viewscroll-view内部的第一个盒子添加margin-top属性会出现滚动条IOS scroll-view中的自定义组件fixed问题","link":"/2020/06/29/Blog-about-learning-112/"},{"title":"JavaScript Source Map","text":"Source Map有了 Source Map，就可以从压缩代码中找到原始代码。 相关资料JavaScript Source Map 详解√【JS基础】sourceMap是个啥√","link":"/2020/06/29/Blog-about-learning-113/"},{"title":"","text":"","link":"/2020/06/29/Blog-about-learning-114/"},{"title":"Nuxt 从入门到实践","text":"Nuxt 常用配置项配置 IP 和端口12345678910// package.json&quot;scripts&quot;: { // ...},&quot;config&quot;:{ &quot;nuxt&quot;:{ &quot;host&quot;:&quot;127.0.0.1&quot;, &quot;port&quot;:&quot;1818&quot; }}, 配置全局CSS1234567// nuxt.config.jshead: { // ... },css: [ '~assets/css/normailze.css',], 配置webpack的loader在nuxt.config.js里是可以对webpack的基本配置进行覆盖的 123456789101112131415161718192021222324252627// nuxt.config.jsbuild: { loaders:[ { test:/\\.(png|jpe?g|gif|svg)$/, loader:&quot;url-loader&quot;, query:{ limit:10000, name:'img/[name].[hash].[ext]' } } ], /* ** Run ESLint on save */ extend (config, { isDev, isClient }) { if (isDev &amp;&amp; isClient) { config.module.rules.push({ enforce: 'pre', test: /\\.(js|vue)$/, loader: 'eslint-loader', exclude: /(node_modules)/ }) } }} Nuxt 路由 Nuxt.js 路由会根据 pages 目录中提供的Vue文件自动为您生成配置。 路由跳转传参1234567&lt;template&gt;&lt;!--路由跳转传参--&gt; &lt;nuxt-link :to=&quot;{name:'news',params:{newsId:3306}}&quot;&gt;NEWS&lt;/nuxt-link&gt;&lt;!--路由接收参数--&gt; &lt;p&gt;NewsID:{{$route.params.newsId}}&lt;/p&gt;&lt;/template&gt; 动态路由跳转传参以下画线为前缀的Vue文件就是动态路由，然后在文件里边有 $route.params.id来接收参数 123&lt;template&gt; &lt;nuxt-link :to=&quot;{name:'news-id',params:{id:123}}&quot;&gt;News-1&lt;/nuxt-link&gt;&lt;/template&gt; 动态参数校验12345678&lt;script&gt; export default { validate ({ params }) { // Must be a number return /^\\d+$/.test(params.id) } }&lt;/script&gt; 路由切换动画全局动画 1234567/* assets/css/main.css */.page-enter-active, .page-leave-active { transition: opacity 2s;}.page-enter, .page-leave-active { opacity: 0;} 12// nuxt.config.jscss:['assets/css/main.css'], 单页动画 123456789/* assets/css/main.css */.test-enter-active, .test-leave-active { transition: all 2s; font-size:12px;}.test-enter, .test-leave-active { opacity: 0; font-size:40px;} 12345&lt;script&gt; export default { transition:'test' }&lt;/script&gt; Views 布局默认模板根目录下创建一个 app.html 就可实现 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;!-- 读取的是nuxt.config.js里的信息 --&gt; {{ HEAD }}&lt;/head&gt;&lt;body&gt; &lt;p&gt;jspang.com 技术胖的博客&lt;/p&gt; &lt;!-- pages文件夹下的主体页面 --&gt; {{ APP }}&lt;/body&gt;&lt;/html&gt; 默认布局1234567&lt;!-- layouts/default.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;JSPang.com 技术胖的博客&lt;/p&gt; &lt;nuxt/&gt; &lt;/div&gt;&lt;/template&gt; 自定义布局例如：创建博客布局 在layouts 新建一个 blog.vue。 1234567&lt;!--layouts/blog.vue--&gt;&lt;template&gt; &lt;div&gt; &lt;div&gt;My blog navigation bar here&lt;/div&gt; &lt;Nuxt /&gt; &lt;/div&gt;&lt;/template&gt; 使用博客布局 12345678910&lt;!--pages/posts.vue--&gt;&lt;template&gt; &lt;!-- Your template --&gt;&lt;/template&gt;&lt;script&gt; export default { layout: 'blog' // page component definitions }&lt;/script&gt; 自定义错误页面 123456789101112131415&lt;!--layouts/error.vue--&gt;&lt;template&gt; &lt;div&gt; &lt;h1 v-if=&quot;error.statusCode === 404&quot;&gt;Page not found&lt;/h1&gt; &lt;h1 v-else&gt;An error occurred&lt;/h1&gt; &lt;NuxtLink to=&quot;/&quot;&gt;Home page&lt;/NuxtLink&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { props: ['error'], layout: 'error' // you can set a custom layout for the error page }&lt;/script&gt; SEO meta、title123456789101112131415161718&lt;script&gt; export default { data(){ return{ title:this.$route.params.title, } }, // 独立设置 head 信息 head(){ return{ title:this.title, meta:[ {hid:'description',name:'news',content:'This is news page'} ] } } } &lt;/script&gt; 注意：为了避免子组件中的meta标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用 hid 键为meta标签配一个唯一的标识编号。 数据请求安装 Axios 1npm install axios --save 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;h1&gt;姓名：{{info.name}}&lt;/h1&gt; &lt;h2&gt;年龄：{{info.age}}&lt;/h2&gt; &lt;h2&gt;兴趣：{{info.interest}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from 'axios' export default { data(){ return { name:'hello World', } }, // promise asyncData(){ return axios.get('https://api.myjson.com/bins/8gdmr') .then((res)=&gt;{ console.log(res) return {info:res.data} }) } // await async asyncData(){ let {data}=await axios.get('https://api.myjson.com/bins/8gdmr') return {info: data} } }&lt;/script&gt; 静态资源的引入及打包直接引入图片 123&lt;template&gt; &lt;div&gt;&lt;img src=&quot;~static/logo.png&quot; /&gt;&lt;/div&gt;&lt;/template&gt; css 图片的引入 1234567&lt;style&gt; .diss{ width: 300px; height: 100px; background-image: url('~static/logo.png') }&lt;/style&gt; 打包静态HTML并运行 1npm run generate live-server 可以查看打包后的文件 相关资料[代码沙盒]路由[代码沙盒]Views布局使用技术胖Nuxt.js教程开启SSR渲染[视频]技术胖Nuxt.js免费视频教程 开启SSR渲染","link":"/2020/06/29/Blog-about-learning-116/"},{"title":"uniapp 从入门到实战","text":"uniappuniapp 基础运行项目第一次在微信开发者工具中运行需要先配置小程序的相关路径、小程序开发者工具中安全中服务端口开启 项目目录及文件pages 所有的页面存放目录static 静态资源目录，例如图片等unpackage 就是打包目录，在这里有各个平台的打包文件components 组件存放目录App.vue 是我们的根组件，所有页面都是在 App.vue 下进行切换的，是页面入口文件，可以调用应用的生命周期函数。manifest.json 文件是应用的配置文件，用于指定应用的名称、图标、权限等。pages.json 文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等main.js 是我们的项目入口文件，主要作用是初始化 vue 实例并使用需要的插件。uni.scss 文件的用途是为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss 文件里预置了一批scss变量预置。 为了实现多端兼容，综合考虑编译速度、运行性能等因素，uni-app 约定了如下开发规范： 页面文件遵循 Vue 单文件组件 (SFC) 规范 组件标签靠近小程序规范，详见uni-app 组件规范 接口能力（JS API）靠近微信小程序规范，但需将前缀 wx 替换为 uni，详见uni-app接口规范 数据绑定及事件处理同 Vue.js 规范，同时补充了App及页面的生命周期 为兼容多端运行，建议使用flex布局进行开发 全局配置和页面配置通过 pages.json 中 globalStyle 进行全局配置用于设置应用的状态栏、导航条、标题、窗口背景色等。详细文档 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #F7F7F7 导航栏背景颜色（同状态栏背景色） navigationBarTextStyle String white 导航栏标题颜色及状态栏前景颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 backgroundTextStyle String dark 下拉 loading 的样式，仅支持 dark / light enablePullDownRefresh Boolean false 是否开启下拉刷新，详见页面生命周期。 onReachBottomDistance Number 50 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见页面生命周期 通过 pages.json 中 pages 进行页面配置 属性 类型 默认值 描述 path String 配置页面路径 style Object 配置页面窗口表现，配置项参考 pageStyle 通过style修改页面的标题和导航栏背景色，并且设置h5下拉刷新的特有样式 12345678910111213141516&quot;pages&quot;: [ //pages数组中第一项表示应用启动页，参考：https://uniapp.dcloud.io/collocation/pages { &quot;path&quot;:&quot;pages/message/message&quot;, &quot;style&quot;: { &quot;navigationBarBackgroundColor&quot;: &quot;#007AFF&quot;, &quot;navigationBarTextStyle&quot;: &quot;white&quot;, &quot;enablePullDownRefresh&quot;: true, &quot;disableScroll&quot;: true, &quot;h5&quot;: { &quot;pullToRefresh&quot;: { &quot;color&quot;: &quot;#007AFF&quot; } } } } ] 配置tabbar如果应用是一个多 tab 应用，可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页。 Tips 当设置 position 为 top 时，将不会显示 icon tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 属性说明： 属性 类型 必填 默认值 描述 平台差异说明 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar 上边框的颜色，仅支持 black/white App 2.3.4+ 支持其他颜色值 list Array 是 tab 的列表，详见 list 属性说明，最少2个、最多5个 tab position String 否 bottom 可选值 bottom、top top 值仅微信小程序支持 其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 说明 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字，在 5+APP 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片，不支持字体图标 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 123456789101112131415161718&quot;tabBar&quot;: { &quot;color&quot;: &quot;#7A7E83&quot;, &quot;selectedColor&quot;: &quot;#3cc51f&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;backgroundColor&quot;: &quot;#ffffff&quot;, &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;static/tabs/home.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabs/home-active.png&quot;, &quot;text&quot;: &quot;组件&quot; }, { &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;iconPath&quot;: &quot;static/tabs/message.png&quot;, &quot;selectedIconPath&quot;: &quot;static/tabs/message-active.png&quot;, &quot;text&quot;: &quot;接口&quot; }] // &quot;position&quot;: &quot;top&quot; } condition启动模式配置启动模式配置，仅开发期间生效，用于模拟直达页面的场景，如：小程序转发后，用户点击所打开的页面。 属性说明： 属性 类型 是否必填 描述 current Number 是 当前激活的模式，list节点的索引值 list Array 是 启动模式列表 list说明： 属性 类型 是否必填 描述 name String 是 启动模式名称 path String 是 启动页面路径 query String 否 启动参数，可在页面的 onLoad 函数里获得 123456789&quot;condition&quot;: { &quot;current&quot;: 0, &quot;list&quot;: [{ &quot;name&quot;: &quot;Scan code&quot;, &quot;path&quot;: &quot;pages/index/index&quot;, &quot;query&quot;: &quot;interval=4000&amp;autoplay=false&quot; } ] } 组件的基本使用uni-app提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼接称自己的应用 uni-app中的组件，就像 HTML 中的 div 、p、span 等标签的作用一样，用于搭建页面的基础结构 text 文本组件的用法text 组件的属性 属性 类型 默认值 必填 说明 selectable boolean false 否 文本是否可选 space string . 否 显示连续空格，可选参数：ensp、emsp、nbsp decode boolean false 否 是否解码 text 组件相当于行内标签、在同一行显示 除了文本节点以外的其他节点都无法长按选中 1234567891011121314151617181920212223&lt;template&gt; &lt;view&gt; &lt;!-- 长按文本是否可选 --&gt; &lt;text selectable&gt;来了老弟&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;!-- 显示连续空格的方式 --&gt; &lt;view&gt; &lt;text space='ensp'&gt;来了 老弟&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text space='emsp'&gt;来了 老弟&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text space='nbsp'&gt;来了 老弟&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view&gt; &lt;!-- 是否解码 --&gt; &lt;text decode='true'&gt;&amp;nbsp; &lt; &gt; &amp; &amp;apos; &amp;ensp; &amp;emsp;&lt;/text&gt; &lt;/view&gt;&lt;/template&gt; view 视图容器组件的用法 View 视图容器， 类似于 HTML 中的 div view 组件的属性 属性 类型 默认值 必填 说明 hover-class String none 否 指定按下去的样式类。当 hover-class=”none” 时，没有点击态效果 hover-stop-propagation Boolean false 否 指定是否阻止本节点的祖先节点出现点击态 hover-start-time Number 50 否 按住后多久出现点击态，单位毫秒 hover-stay-time Number 400 否 手指松开后点击态保留时间，单位毫秒 button 按钮组件的用法button 组件的属性 属性名 类型 默认值 说明 size String default 按钮的大小 type String default 按钮的样式类型 plain Boolean false 按钮是否镂空，背景色透明 disabled Boolean false 是否按钮 loading Boolean false 名称是否带 loading t图标 button 组件默认独占一行，设置 size 为 mini 时可以在一行显示多个 12345&lt;template&gt; &lt;button size='mini' type='primary'&gt;前端&lt;/button&gt; &lt;button size='mini' type='default' disabled='true'&gt;前端&lt;/button&gt; &lt;button size='mini' type='warn' loading='true'&gt;前端&lt;/button&gt;&lt;/template&gt; image 组件的使用image 组件的属性图片。 属性名 类型 默认值 说明 平台差异说明 src String 图片资源地址 mode String ‘scaleToFill’ 图片裁剪、缩放的模式 uni-app中的样式 rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。以750宽的屏幕为基准，750rpx恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大。 使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束 支持基本常用的选择器class、id、element等 在 uni-app 中不能使用 * 选择器。 page 相当于 body 节点 定义在 App.vue 中的样式为全局样式，作用于每一个页面。在 pages 目录下 的 vue 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 App.vue 中相同的选择器 uni-app 支持使用字体图标，使用方式与普通 web 项目相同，需要注意以下几点： - 字体文件小于 40kb，`uni-app` 会自动将其转化为 base64 格式； - 字体文件大于等于 40kb， 需开发者自己转换，否则使用将不生效； - 字体文件的引用路径推荐使用以 ~@ 开头的绝对路径。 1234@font-face { font-family: test1-icon; src: url('~@/static/iconfont.ttf');} 如何使用scss或者less uni-app 中的数据绑定在页面中需要定义数据，和我们之前的vue一摸一样，直接在data中定义数据即可 1234567export default { data () { return { msg: 'hello-uni' } }} 利用插值表达式渲染基本数据 1&lt;view&gt;{{msg}}&lt;/view&gt; 在插值表达式中使用三元运算 1&lt;view&gt;{{ flag ? '我是真的':'我是假的' }}&lt;/view&gt; 基本运算 1&lt;view&gt;{{1+1}}&lt;/view&gt; v-bind 动态绑定属性在data中定义了一张图片，我们希望把这张图片渲染到页面上 1234567export default { data () { return { img: 'http://destiny001.gitee.io/image/monkey_02.jpg' } }} 利用v-bind进行渲染 1&lt;image v-bind:src=&quot;img&quot;&gt;&lt;/image&gt; 还可以缩写成: 1&lt;image :src=&quot;img&quot;&gt;&lt;/image&gt; v-for 的使用data中定以一个数组，最终将数组渲染到页面上 12345678910data () { return { arr: [ { name: '刘能', age: 29 }, { name: '赵四', age: 39 }, { name: '宋小宝', age: 49 }, { name: '小沈阳', age: 59 } ] }} 利用v-for进行循环 123&lt;template&gt; &lt;view v-for=&quot;(item,i) in arr&quot; :key=&quot;i&quot;&gt;名字：{{item.name}}---年龄：{{item.age}}&lt;/view&gt;&lt;/template&gt; uni 中的事件事件绑定在uni中事件绑定和vue中是一样的，通过v-on进行事件的绑定，也可以简写为@ 1&lt;button @click=&quot;tapHandle&quot;&gt;点我啊&lt;/button&gt; 事件函数定义在methods中 12345methods: { tapHandle () { console.log('真的点我了') }} 事件传参 默认如果没有传递参数，事件函数第一个形参为事件对象 12345678910&lt;template&gt; &lt;button @click=&quot;tapHandle&quot;&gt;点我啊&lt;/button&gt;&lt;/template&gt;&lt;script&gt; methods: { tapHandle (e) { console.log(e) } }&lt;/script&gt; 如果给事件函数传递参数了，则对应的事件函数形参接收的则是传递过来的数据 12345678910&lt;template&gt; &lt;button @click=&quot;tapHandle(1)&quot;&gt;点我啊&lt;/button&gt;&lt;/template&gt; &lt;script&gt; methods: { tapHandle (num) { console.log(num) } }&lt;/script&gt; 如果获取事件对象也想传递参数 12345678910 &lt;template&gt; &lt;button @click=&quot;tapHandle(1,$event)&quot;&gt;点我啊&lt;/button&gt;&lt;/template&gt; &lt;script&gt; methods: { tapHandle (num,e) { console.log(num,e) } }&lt;/script&gt; uni 的生命周期应用的生命周期生命周期的概念：一个对象从创建、运行、销毁的整个过程被成为生命周期。 生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数 uni-app 支持如下应用生命周期函数： 函数名 说明 onLaunch 当uni-app 初始化完成时触发（全局只触发一次） onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 onError 当 uni-app 报错时触发 页面的生命周期uni-app 支持如下页面生命周期函数： 函数名 说明 平台差异说明 最低版本 onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考示例 onShow 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 onReady 监听页面初次渲染完成。 onHide 监听页面隐藏 onUnload 监听页面卸载 下拉刷新开启下拉刷新在uni-app中有两种方式开启下拉刷新 需要在 pages.json 里，找到的当前页面的pages节点，并在 style 选项中开启 enablePullDownRefresh 通过调用uni.startPullDownRefresh方法来开启下拉刷新 通过配置文件开启创建list页面进行演示 123456789101112131415161718&lt;template&gt; &lt;view&gt; 杭州学科 &lt;view v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt; {{item}} &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { arr: ['前端','java','ui','大数据'] } } }&lt;/script&gt; 通过 pages.json 文件中找到当前页面的 pages 节点，并在 style 选项中开启 enablePullDownRefresh 123456{ &quot;path&quot;:&quot;pages/list/list&quot;, &quot;style&quot;:{ &quot;enablePullDownRefresh&quot;: true }} 通过API开启api文档 1uni.startPullDownRefresh() 监听下拉刷新通过onPullDownRefresh可以监听到下拉刷新的动作 123456789101112131415export default { data () { return { arr: ['前端','java','ui','大数据'] } }, methods: { startPull () { uni.startPullDownRefresh() } }, onPullDownRefresh () { console.log('触发下拉刷新了') }} 关闭下拉刷新uni.stopPullDownRefresh() 停止当前页面下拉刷新。 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @click=&quot;startPull&quot;&gt;开启下拉刷新&lt;/button&gt; 杭州学科 &lt;view v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt; {{item}} &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { arr: ['前端','java','ui','大数据'] } }, methods: { startPull () { uni.startPullDownRefresh() } }, onPullDownRefresh () { this.arr = [] setTimeout(()=&gt; { this.arr = ['前端','java','ui','大数据'] uni.stopPullDownRefresh() }, 1000); } }&lt;/script&gt; 上拉加载通过在 pages.json 文件中找到当前页面的 pages 节点下 style 中配置 onReachBottomDistance 可以设置距离底部开启加载的距离，默认为50px。 通过onReachBottom监听到触底的行为 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @click=&quot;startPull&quot;&gt;开启下拉刷新&lt;/button&gt; 杭州学科 &lt;view v-for=&quot;(item,index) in arr&quot; :key=&quot;index&quot;&gt; {{item}} &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { arr: ['前端','java','ui','大数据','前端','java','ui','大数据'] } }, onReachBottom () { console.log('触底了') } }&lt;/script&gt;&lt;style&gt; view{ height: 100px; line-height: 100px; }&lt;/style&gt; 网络请求在 uni 中可以调用 uni.request 方法进行请求网络请求 需要注意的是：在小程序中网络相关的 API 在使用前需要配置域名白名单。 发送get请求 12345678910111213141516171819&lt;template&gt; &lt;view&gt; &lt;button @click=&quot;sendGet&quot;&gt;发送请求&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { methods: { sendGet () { uni.request({ url: 'http://localhost:8082/api/getlunbo', success(res) { console.log(res) } }) } } }&lt;/script&gt; 发送post请求 数据缓存uni.setStorage将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。 123456789101112131415161718192021222324&lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @click=&quot;setStor&quot;&gt;存储数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { methods: { setStor () { uni.setStorage({ key: 'id', data: 100, success () { console.log('存储成功') } }) } } }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; uni.setStorageSync将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。 代码演示 123456789101112131415161718&lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @click=&quot;setStor&quot;&gt;存储数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { methods: { setStor () { uni.setStorageSync('id',100) } } }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; uni.getStorage从本地缓存中异步获取指定 key 对应的内容。 代码演示 123456789101112131415161718192021222324 &lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @click=&quot;getStorage&quot;&gt;获取数据&lt;/button&gt; &lt;/view&gt; &lt;/template&gt; &lt;script&gt; export default { data () { return { id: '' } }, methods: { getStorage () { uni.getStorage({ key: 'id', success: res=&gt;{ this.id = res.data } }) } } }&lt;/script&gt; uni.getStorageSync从本地缓存中同步获取指定 key 对应的内容。 代码演示 123456789101112131415&lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @click=&quot;getStorage&quot;&gt;获取数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { methods: { getStorage () { const id = uni.getStorageSync('id') console.log(id) } } }&lt;/script&gt; uni.removeStorage从本地缓存中异步移除指定 key。 代码演示 12345678910111213141516171819&lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @click=&quot;removeStorage&quot;&gt;删除数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { methods: { removeStorage () { uni.removeStorage({ key: 'id', success: function () { console.log('删除成功') } }) } } }&lt;/script&gt; uni.removeStorageSync从本地缓存中同步移除指定 key。 代码演示 1234567891011121314&lt;template&gt; &lt;view&gt; &lt;button type=&quot;primary&quot; @click=&quot;removeStorage&quot;&gt;删除数据&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { methods: { removeStorage () { uni.removeStorageSync('id') } } }&lt;/script&gt; 上传图片、预览图片上传图片uni.chooseImage方法从本地相册选择图片或使用相机拍照。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;view&gt; &lt;button @click=&quot;chooseImg&quot; type=&quot;primary&quot;&gt;上传图片&lt;/button&gt; &lt;view&gt; &lt;image v-for=&quot;item in imgArr&quot; :src=&quot;item&quot; :key=&quot;index&quot;&gt;&lt;/image&gt; &lt;/view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { imgArr: [] } }, methods: { chooseImg () { uni.chooseImage({ count: 9, success: res=&gt;{ this.imgArr = res.tempFilePaths } }) } } }&lt;/script&gt; 预览图片1234567891011121314&lt;template&gt; &lt;view&gt; &lt;image v-for=&quot;item in imgArr&quot; :src=&quot;item&quot; @click=&quot;previewImg(item)&quot; :key=&quot;item&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;template&gt;&lt;script&gt;// 预览图片的方法previewImg (current) { uni.previewImage({ urls: this.imgArr, current })}&lt;/script&gt; 条件注释实现跨段兼容条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。 写法：以 #ifdef 加平台标识 开头，以 #endif 结尾。 平台标识 值 平台 参考文档 APP-PLUS 5+App HTML5+ 规范 H5 H5 MP-WEIXIN 微信小程序 微信小程序 MP-ALIPAY 支付宝小程序 支付宝小程序 MP-BAIDU 百度小程序 百度小程序 MP-TOUTIAO 头条小程序 头条小程序 MP-QQ QQ小程序 （目前仅cli版支持） MP 微信小程序/支付宝小程序/百度小程序/头条小程序/QQ小程序 组件的条件注释代码演示 123456789101112131415&lt;!-- #ifdef H5 --&gt;&lt;view&gt; h5页面会显示&lt;/view&gt;&lt;!-- #endif --&gt;&lt;!-- #ifdef MP-WEIXIN --&gt;&lt;view&gt; 微信小程序会显示&lt;/view&gt;&lt;!-- #endif --&gt;&lt;!-- #ifdef APP-PLUS --&gt;&lt;view&gt; app会显示&lt;/view&gt;&lt;!-- #endif --&gt; api的条件注释代码演示 12345678onLoad () { //#ifdef MP-WEIXIN console.log('微信小程序') //#endif //#ifdef H5 console.log('h5页面') //#endif} 样式的条件注释 代码演示 1234567891011121314/* #ifdef H5 */ view{ height: 100px; line-height: 100px; background: red; } /* #endif */ /* #ifdef MP-WEIXIN */ view{ height: 100px; line-height: 100px; background: green; } /* #endif */ uni-app 中的导航跳转利用 navigator 进行跳转navigator详细文档：文档地址 跳转到普通页面 123&lt;navigator url=&quot;/pages/about/about&quot; hover-class=&quot;navigator-hover&quot;&gt; &lt;button type=&quot;default&quot;&gt;跳转到关于页面&lt;/button&gt;&lt;/navigator&gt; 跳转到tabbar页面 123&lt;navigator url=&quot;/pages/message/message&quot; open-type=&quot;switchTab&quot;&gt; &lt;button type=&quot;default&quot;&gt;跳转到message页面&lt;/button&gt;&lt;/navigator&gt; 利用编程式导航进行跳转导航跳转文档 利用navigateTo进行导航跳转 保留当前页面，跳转到应用内的某个页面，使用uni.navigateBack可以返回到原页面。 1&lt;button type=&quot;primary&quot; @click=&quot;goAbout&quot;&gt;跳转到关于页面&lt;/button&gt; 通过navigateTo方法进行跳转到普通页面 12345goAbout () { uni.navigateTo({ url: '/pages/about/about', })} 通过switchTab跳转到tabbar页面 跳转到tabbar页面 1&lt;button type=&quot;primary&quot; @click=&quot;goMessage&quot;&gt;跳转到message页面&lt;/button&gt; 通过switchTab方法进行跳转 12345goMessage () { uni.switchTab({ url: '/pages/message/message' })} redirectTo进行跳转 关闭当前页面，跳转到应用内的某个页面。 12345678&lt;!-- template --&gt;&lt;button type=&quot;primary&quot; @click=&quot;goMessage&quot;&gt;跳转到message页面&lt;/button&gt;&lt;!-- js --&gt;goMessage () { uni.switchTab({ url: '/pages/message/message' })} 通过onUnload测试当前组件确实卸载 123onUnload () { console.log('组件卸载了')} 导航跳转传递参数在导航进行跳转到下一个页面的同时，可以给下一个页面传递相应的参数，接收参数的页面可以通过onLoad生命周期进行接收 传递参数的页面 12345goAbout () { uni.navigateTo({ url: '/pages/about/about?id=80', });} 接收参数的页面 1234567&lt;script&gt; export default { onLoad (options) { console.log(options) } }&lt;/script&gt; uni-app 中组件uni-app中组件的创建在uni-app中，可以通过创建一个后缀名为vue的文件，即创建一个组件成功，其他组件可以将该组件通过impot的方式导入，在通过components进行注册即可 创建login组件，在component中创建login目录，然后新建login.vue文件 1234567891011&lt;template&gt; &lt;view&gt; 这是一个自定义组件 &lt;/view&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在其他组件中导入该组件并注册 1234567&lt;template&gt; &lt;test&gt;&lt;/test&gt;&lt;/template&gt;&lt;script&gt; import login from &quot;@/components/test/test.vue&quot; components: {test}&lt;/script&gt; 组件的生命周期函数 beforeCreate 在实例初始化之后被调用。详见 created 在实例创建完成后被立即调用。详见 beforeMount 在挂载开始之前被调用。详见 mounted 挂载到实例上去之后调用。详见 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用$nextTickVue官方文档 beforeUpdate 数据更新时调用，发生在虚拟 DOM 打补丁之前。详见 仅H5平台支持 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。详见 仅H5平台支持 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。详见 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。详见 组件的通讯父组件给子组件传值通过props来接受外界传递到组件内部的值 12345678910111213&lt;template&gt; &lt;view&gt; 这是一个自定义组件 {{msg}} &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { props: ['msg'] }&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 其他组件在使用login组件的时候传递值 123456789101112131415161718&lt;template&gt; &lt;view&gt; &lt;test :msg=&quot;msg&quot;&gt;&lt;/test&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import test from &quot;@/components/test/test.vue&quot; export default { data () { return { msg: 'hello' } }, components: {test} }&lt;/script&gt; 子组件给父组件传值通过$emit触发事件进行传递参数 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view&gt; 这是一个自定义组件 {{msg}} &lt;button type=&quot;primary&quot; @click=&quot;sendMsg&quot;&gt;给父组件传值&lt;/button&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default { data () { return { status: '打篮球' } }, props: { msg: { type: String, value: '' } }, methods: { sendMsg () { this.$emit('myEvent',this.status) } } }&lt;/script&gt; 父组件定义自定义事件并接收参数 12345678910111213141516171819202122&lt;template&gt; &lt;view&gt; &lt;test :msg=&quot;msg&quot; @myEvent=&quot;getMsg&quot;&gt;&lt;/test&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; import test from &quot;@/components/test/test.vue&quot; export default { data () { return { msg: 'hello' } }, methods: { getMsg (res) { console.log(res) } }, components: {test} }&lt;/script&gt; 兄弟组件通讯123456&lt;script&gt; // 触发全局自定义事件 uni.$emit(eventName,OBJECT); // 监听全局自定义事件 uni.$on(eventName,callback)&lt;/script&gt; 注意及时销毁事件监听 uni-ui的使用 以上是我对下列视频及文章的归纳和总结。 2020uniApp视频全套资料配源码 相关资料运行uni-appuni-app的开发经历（持续更新）uni-app小程序手把手项目实战uni-app消息推送方案uni-app 1.4 发布，一套代码，发行小程序（微信/支付宝/百度）、H5、App多个平台uni-app踩坑+小改造uniapp-adminuni-app消息推送方案","link":"/2020/06/29/Blog-about-learning-115/"},{"title":"mpvue","text":"封装自定义登录弹窗组件 相关资料mpvue+koa2","link":"/2020/06/29/Blog-about-learning-118/"},{"title":"immutablejs","text":"immutablejs 解决数据可变性带来的问题，并提升了性能。 相关资料immutablejs 是如何优化我们的代码的？√","link":"/2020/06/29/Blog-about-learning-120/"},{"title":"JSBridge 的原理及使用","text":"JSBridge的原理及使用主要是给 JavaScript 提供调用 Native 功能的接口，让混合开发中的前端部分可以方便地使用 Native 的功能（例如：地址位置、摄像头）。 而且 JSBridge 的功能不止调用 Native 功能这么简单宽泛。实际上，JSBridge 就像其名称中的Bridge的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是构建 Native 和非 Native 间消息通信的通道，而且这个通信的通道是双向的。 双向通信的通道:JS 向 Native 发送消息: 调用相关功能、通知 Native 当前 JS 的相关状态等。Native 向 JS 发送消息: 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。 H5与Native交互如下图： JSBridge 的实现原理JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。 在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信） 和句柄解析调用。 JSBridge 的通信原理JavaScript 调用 Native的方式主要有两种：注入API拦截URL SCHEME 注入API注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。 对于 iOS 的 UIWebView，实例如下： 12345678JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) { // Native 逻辑};//前端调用方式：window.postBridgeMessage(message); 对于 iOS 的 UIWebView，实例如下： 12345678JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) { // Native 逻辑};//前端调用方式：window.postBridgeMessage(message); 对于 iOS 的 WKWebView 可以用以下方式： 123456789101112131415161718192021222324252627@interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt;@implementation WKWebVIewVC- (void)viewDidLoad { [super viewDidLoad]; WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init]; configuration.userContentController = [[WKUserContentController alloc] init]; WKUserContentController *userCC = configuration.userContentController; // 注入对象，前端调用其方法时，Native 可以捕获到 [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;]; WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; // TODO 显示 WebView}- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) { NSLog(@&quot;前端传递的数据 %@: &quot;,message.body); // Native 逻辑 }}// 前端调用方式：window.webkit.messageHandlers.nativeBridge.postMessage(message); 拦截 URL SCHEME解释一下 URL SCHEME：URL SCHEME 是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的。 例如:qunarhy://hy/url?url=ymfe.tech，protocol 是 qunarhy，host 则是 hy。 拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。 在实践过程中，这种方式有一定的缺陷：使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。 有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。 创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。 因此：JavaScript 调用 Native 推荐使用注入 API 的方式。 Native 调用 JavaScript 的方式相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，直接执行拼接好的 JavaScript 代码即可。从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。 对于 iOS 的 UIWebView，示例如下： 123result = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];* javaScriptString为JavaScript 代码串 对于 iOS 的 WKWebView，示例如下 1[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler]; JSBridge 接口实现从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：调用 Native（给 Native 发消息） 和 接被 Native 调用（接收 Native 消息）。因此，JSBridge 可以设计如下： 12345678910window.JSBridge = { // 调用 Native invoke: function(msg) { // 判断环境，获取不同的 nativeBridge nativeBridge.postMessage(msg); }, receiveMessage: function(msg) { // 处理 msg }}; 在上面部分中，提到过 RPC 中有一个非常重要的环节是 句柄解析调用 ，这点在 JSBridge 中体现为 句柄与功能对应关系。同时，我们将句柄抽象为 桥名（BridgeName），最终演化为一个 BridgeName 对应一个 Native 功能或者一类 Native 消息。基于此点，JSBridge 的实现可以优化为如下： 123456789101112131415window.JSBridge = { // 调用 Native invoke: function(bridgeName, data) { // 判断环境，获取不同的 nativeBridge nativeBridge.postMessage({ bridgeName: bridgeName, data: data || {} }); }, receiveMessage: function(msg) { var bridgeName = msg.bridgeName, data = msg.data || {}; // 具体逻辑 }}; 终极提问：消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释： 当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 当前页面唯一 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。 整体流程：在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 =&gt; 解析参数，拿到 bridgeName、data 和 callbackId =&gt; 根据 bridgeName 找到功能方法，以 data 为参数执行 =&gt; 执行返回值和 callbackId 一起回传前端。 Native调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。 JSBridge 的引用对于 JSBridge 的引用，常用有如下两种方式，但各有利弊。 由 Native 端进行注入注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。优点：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容。缺点：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。 由 JavaScript 端引用直接与 JavaScript 一起执行。 优点：JavaScript 端可以确定 JSBridge 的存在，直接调用即可。缺点：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。 阅读原文","link":"/2020/03/21/Blog-about-learning-12/"},{"title":"大规格文件的上传优化","text":"相关资料FileReader√在web应用程序中使用文件HTML5之FileReader的使用前端通过spark-md5.js计算本地文件md5大规格文件的上传优化通过File对象的slice()方法实现文件分片上传Vue-多文件断点续传、秒传、分片上传","link":"/2020/07/30/Blog-about-learning-123/"},{"title":"图像处理","text":"函数图片压缩123456789101112131415161718192021222324252627282930313233343536373839404142434445const tool = { //base64转file dataURLtoFile (dataurl, filename) { let arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n) while (n--) { u8arr[n] = bstr.charCodeAt(n) } return new File([u8arr], filename, {type: mime}) }, // 压缩图片 compress (img) { let originWidth = img.width, // 压缩后的宽 originHeight = img.height, maxWidth = 600, maxHeight = 600, quality = 0.8, // 压缩质量 canvas = document.createElement('canvas'), drawer = canvas.getContext('2d'); // 目标尺寸 let targetWidth = originWidth, targetHeight = originHeight // 图片尺寸超过300x300的限制 if (originWidth &gt; maxWidth || originHeight &gt; maxHeight) { if (originWidth / originHeight &gt; maxWidth / maxHeight) { // 更宽，按照宽度限定尺寸 targetWidth = maxWidth targetHeight = Math.round(maxWidth * (originHeight / originWidth)) } else { targetHeight = maxHeight targetWidth = Math.round(maxHeight * (originWidth / originHeight)) } } canvas.width = targetWidth canvas.height = targetHeight drawer.clearRect(0, 0, canvas.width, canvas.height) drawer.drawImage(img, 0, 0, canvas.width, canvas.height) let base64 = canvas.toDataURL('image/jpeg', quality) // 压缩后的base64图片 let file = this.dataURLtoFile(base64, Date.parse(Date()) + '.jpg') file = {content: base64, file: file} console.log(file)//压缩后的file return file },}export default tool 图片压缩、方向纠正、预览、上传实现原理 用filereader读取用户上传的图片数据 将img绘制到canvas上，用EXIF.js对图片方向进行纠正，再调用canvas.toDataURL对图片进行压缩，获取到压缩后的base64格式图片数据，转成二进制 123456789101112131415161718192021222324251. 可以直接把base64数据转为File对象，如下：// dataUrl数据转为File对象，dataUrl表示图片的base64数据dataURLtoFile (dataurl, filename) {var arr = dataurl.split(',')var mime = arr[0].match(/:(.*?);/)[1]var bstr = atob(arr[1])var n = bstr.length; var u8arr = new Uint8Array(n)while (n--) {u8arr[n] = bstr.charCodeAt(n)}return new File([u8arr], filename, { type: mime })}2. 或者你想把上文 方法返回的blob对象转为File对象，可以这样写：/** * Blob对象转为File对象 * @param {object} blob 二进制对象 * @param {string} fileName 文件名称 * @return {object} blob改造后的file文件对象。 * 注意：file对象就是一个特殊的blob对象 */function blobToFile(blob, fileName){ blob.lastModifiedDate =new Date(); blob.name = fileName; return blob;} 工具 RECOMPRESSOR在线图片优化工具，在文件尺寸和质量之间选择完美平衡。 智图 在线高效优质图片优化，大图需要下载客户端。 库 Pica减小大图像的上传大小，节省上传时间。在图像处理上节省服务器资源。在浏览器中生成缩略图。 注意。如果您需要调整File/Blob的大小（通过表单的文件输入），请考虑使用 image-blob-reduce。 Lena.js用于图像处理的微型库，有 22 个图像滤镜。 Compressor.jsJavaScript图像压缩器。使用浏览器的本机canvas.toBlob API进行压缩工作，这意味着它是有损压缩。通常使用此方法在上载客户端映像文件之前对其进行预压缩。 Fabric.js使用 canvas JavaScript 在网页上轻松创建简单的形状（如矩形，圆形，三角形和其他多边形）或由许多路径组成的更复杂的形状。Fabric.js将允许您使用鼠标来操纵这些对象的大小，位置和旋转。 blurify用于模糊图片 merge-images图像合并 cropperjsJavaScript 图像裁剪，旋转，缩放。 marvinj滤镜、裁剪 grade提供图像中的前2种主要颜色生成的互补渐变 相关资料最优图像优化√智图√手把手教你如何编写一个前端图片压缩、方向纠正、预览、上传插件√图片压缩原理图片懒加载从简单到复杂 高质量前端快照方案：来自页面的「自拍」一个有趣的例子带你入门canvas了解 JS 压缩图片，这一篇就够了 HTMLCanvasElement.toDataURLCanvasRenderingContext2D.drawImage()FileReader在web应用程序中使用文件FormData 对象的使用Using XMLHttpRequest","link":"/2020/07/30/Blog-about-learning-124/"},{"title":"前端的算法 从入门到实战","text":"相关资料写给前端的算法进阶指南，我是如何两个月零基础刷200题","link":"/2020/08/01/Blog-about-learning-126/"},{"title":"React、React native 从入门到实践开发","text":"App 开发流程 前端 后端 前端设计 node Koa 用户界面 Mongodb Mock 假数据测试 RESTful API 服务 App 的桌面图标和启动画面App 的过渡页面和轮播效果App 的注册登陆和账户管理视频的配音制作页面展示所有制作完毕的创意视频列表 Koa 搭建 API 服务mongoDB 音频视频的建模七牛、Cloudinary静态资源的上传、存储和合并 环境搭建node 项目构建React Native 环境的搭建异常调试Xcode 引入第三方模块 服务器端服务器端频繁的异步处理mongoDB 对于数据的建模数据增删改查 前后端连调无后台实现接口Mock 本地数据测试 手写 reactjsxcreateElementrenderConcurrent 相关资料开发吧 React 源码扩展React 源码解析React 入门儿react 中高阶函数与高阶组件2020 年你必须知道的 React 库React 入门","link":"/2019/12/26/Blog-about-learning-127/"},{"title":"CSS 布局及技巧","text":"布局奇技吸顶 12345.sticky-wrapper { position: sticky; top: 0; z-index: 99;} 加载骨架屏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** Variables*/:root { --card-padding: 24px; --card-height: 340px; --card-skeleton: linear-gradient(lightgrey var(--card-height), transparent 0); --avatar-size: 32px; --avatar-position: var(--card-padding) var(--card-padding); --avatar-skeleton: radial-gradient(circle 16px at center, white 99%, transparent 0 ); --title-height: 32px; --title-width: 200px; --title-position: var(--card-padding) 180px; --title-skeleton: linear-gradient(white var(--title-height), transparent 0); --desc-line-height: 16px; --desc-line-skeleton: linear-gradient(white var(--desc-line-height), transparent 0); --desc-line-1-width:230px; --desc-line-1-position: var(--card-padding) 242px; --desc-line-2-width:180px; --desc-line-2-position: var(--card-padding) 265px; --footer-height: 40px; --footer-position: 0 calc(var(--card-height) - var(--footer-height)); --footer-skeleton: linear-gradient(white var(--footer-height), transparent 0); --blur-width: 200px; --blur-size: var(--blur-width) calc(var(--card-height) - var(--footer-height));}/** Card Skeleton for Loading*/.card { width: 280px; height: var(--card-height);}.card:empty::after { content: &quot;&quot;; display: block; width: 100%; height: 100%; border-radius: 6px; box-shadow: 0 10px 45px rgba(0, 0, 0, 0.1); background-image: linear-gradient(90deg, rgba(211, 211, 211, 0) 0, rgba(211, 211, 211, 0.8) 50%, rgba(211, 211, 211, 0) 100%), var(--title-skeleton), var(--desc-line-skeleton), var(--desc-line-skeleton), var(--avatar-skeleton), var(--footer-skeleton), var(--card-skeleton); background-size: var(--blur-size), var(--title-width) var(--title-height), var(--desc-line-1-width) var(--desc-line-height), var(--desc-line-2-width) var(--desc-line-height), var(--avatar-size) var(--avatar-size), 100% var(--footer-height), 100% 100%; background-position: -200% 0, var(--title-position), var(--desc-line-1-position), var(--desc-line-2-position), var(--avatar-position), var(--footer-position), 0 0; background-repeat: no-repeat; -webkit-animation: loading 1.5s infinite; animation: loading 1.5s infinite;}@-webkit-keyframes loading { to { background-position: 350% 0, var(--title-position), var(--desc-line-1-position), var(--desc-line-2-position), var(--avatar-position), var(--footer-position), 0 0; }}@keyframes loading { to { background-position: 350% 0, var(--title-position), var(--desc-line-1-position), var(--desc-line-2-position), var(--avatar-position), var(--footer-position), 0 0; }}/* * Demo Stuff*/body { min-height: 100vh; background-color: #FFF; display: flex; justify-content: center; align-items: center;} 利用 CSS 穿透覆盖默认样式123img { pointer-events: none;} 实现自定义原生 select 控件的样式1234select { /* 禁用原生的样式 */ -webkit-appearance: none;} 文本溢出处理123456789101112131415//单行.single { overflow: hidden; white-space: nowrap; text-overflow: ellipsis;}//多行.more { display: -webkit-box !important; overflow: hidden; text-overflow: ellipsis; work-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 2; //指定行数} 开启弹性滚动1234body { overflow: scroll; -webkit-overflow-scrolling: touch;} 注意：Android 不支持原生的弹性滚动，但可以借助第三方库 iScroll 来实现。 一像素边框设置1234567891011121314.folder li { position: relative; padding: 5px;}.folder li + li:before { position: absolute; top: -1px; left: 0; content: &quot; &quot;; width: 100%; height: 1px; border-top: 1px solid #ccc; -webkit-transform: scaleY(0.5);} 兼容 IE 浏览器的透明度处理123456.ui { width: 100%; height: 100%; opacity: 0.4; filter: Alpha(opacity=40); //兼容IE浏览器的处理} 常用的全屏居中 CSS 函数12345body { height: 100vh; text-align: center; line-height: 100vh;} Flex 布局 justify-content space-around 时 单个左居中1234.container:after { content: &quot;&quot;; flex: auto;} 固定定位滚动1234.container{ position: fixed; overflow:scroll} 扩大可点击区域利用伪元素和定位达到鼠标移到边缘时候出现手型且可点击 12345678910111213141516171819202122.expand-range { position: relative;}.expand-range:after { content: ''; position: absolute; top: -10px; right: -10px; bottom: -10px; left: -10px;}/* 推荐使用scss */@mixin expand-range($top: -10px, $right: $top, $bottom: $top, $left: $right, $position: relative) { position: $position; &amp;:after { content: ''; position: absolute; top: $top; right: $right; bottom: $bottom; left: $left; }}//使用：.test { @include expand-range($top: -5px, $position: absolute) } 巧用层叠上下文利用层叠上下文和 z-index: -1 特性实现伪元素覆盖背景同时又不会遮挡文字。梯形、菱形、平行四边形 12345678910div:after { content: ''; position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: cyan;} 边框内圆角利用伪元素实现圆角矩形并叠加在父元素的背景之上文字之下 12345678910111213141516171819div { position: relative; z-index: 1; height: 200px; padding: 10px; background: #333;}div::after { content: ''; position: absolute; left: 10px; top: 10px; right: 10px; bottom: 10px; z-index: -1; border-radius: 5px; background: cyan;} 自适应宽度折角切角高度坍塌12345678.container{ display:block; content:''; height:0; clear:both; overflow:hidden; visibility: hidden;} 注意外边距折叠只使用一个方向的 margin 更好的表格边框12/* 删除所有的双倍边框 */border-collapse: collapse; 短横线命名1.footer-column-left {} 不要重复设置1234/* font 会被继承 */html { font: normal 16px/1.4 sans-serif;} 使用transform属性来创建动画123456789.ball { left: 50px; transition: 0.4s ease-out;}/* 建议 */.ball.slide-out { transform: translateX(450px);} 使用AutoPrefixer达到更好的兼容性autoprefixer 压缩CSS文件Caniuse检查使用的属性是否得到了广泛的支持 验证Stylelint 相关资料12 个实用的前端开发技巧总结√【CSS】470- 是时候开始用 CSS 自定义属性了响应式布局新方案20个让你效率更高的CSS代码技巧√深入理解CSS background-blend-mode的作用机制一文梳理CSS必会知识点 收藏！40 个 CSS 布局技巧【第2022期】不定宽溢出文本适配滚动 奇妙的 CSS MASK【CSS】333- 使用CSS自定义属性做一个前端加载骨架√《CSS揭秘》实用技巧总结√工作中常用的css整理√","link":"/2020/07/30/Blog-about-learning-122/"},{"title":"云开发 Serverless 从入门到实战","text":"Serverless指构建和运行不需要服务器管理的应用程序的概念。Serverless 是 FaaS 和 BaaS 的结合。Serverless = FaaS + BaaS。 FaaS（Function as a Service） 就是一些运行函数的平台，比如阿里云的函数计算、AWS 的 Lambda 等。BaaS（Backend as a Service）则是一些后端云服务，比如云数据库、对象存储、消息队列等。利用 BaaS，可以极大简化我们的应用开发难度。 Serverless 的主要特点有： 事件驱动 函数在 FaaS 平台中，需要通过一系列的事件来驱动函数执行。 无状态 因为每次函数执行，可能使用的都是不同的容器，无法进行内存或数据共享。如果要共享数据，则只能通过第三方服务，比如 Redis 等。 无运维 使用 Serverless 我们不需要关心服务器，不需要关心运维。这也是 Serverless 思想的核心。 低成本 使用 Serverless 成本很低，因为我们只需要为每次函数的运行付费。函数不运行，则不花钱，也不会浪费服务器资源 前端工程师基于 Serverless 去写后端，最好也需要具备一定的后端知识。涉及复杂的后端系统或者 Serverless 不适用的场景，还是需要后端开发，后端变得更靠后了。 Serverless 开发最佳实践将业务逻辑和函数依赖的 FaaS（如函数计算） 和 BaaS （如云数据库）分离。 1234567891011121314151617181920212223242526272829class Users { constructor(db, mailer) { this.db = db; this.mailer = mailer; } save(email, callback) { const user = { email: email, created_at: Date.now() } this.db.saveUser(user, function (err) { if (err) { callback(err); } else { this.mailer.sendWelcomeEmail(email); callback(); } }); }}module.exports = Users;const db = require('db').connect();const mailer = require('mailer');const Users = require('users');let users = new Users(db, mailer);module.exports.saveUser = (event, context, callback) =&gt; { users.save(event.email, callback);}; 将业务逻辑全都放在了 Users 这个类里面，Users 不依赖任何外部服务。 函数的性能当驱动函数执行的事件到来的时候，首先需要下载代码，然后启动一个容器，在容器里面再启动一个运行环境，最后才是执行代码。前几步统称为冷启动（Cold Start）。传统的应用没有冷启动的过程。 当第一次请求（驱动函数执行的事件）来临，成功启动运行环境并执行函数之后，运行环境会保留一段时间，以便用于下一次函数执行。这样就能减少冷启动的次数，从而缩短函数运行时间。当请求达到一个运行环境的限制时，FaaS 平台会自动扩展下一个运行环境。 执行上下文重用123456const mysql = require('mysql');// 初始化数据库连接 const connection = mysql.createConnection({ /* ... */ });connection.connect();module.exports.saveUser = (event, context, callback) =&gt; { connection.query('...');}; 这样就只有第一次运行环境启动的时候，才会初始化数据库连接。后续请求来临、执行函数的时候，就可以直接利用执行上下文中的 connection，从而提高后续高函数的性能。大部分情况下，通过牺牲一个请求的性能，换取大部分请求的性能，是完全可以够接受的。 给函数预热通过主动调用函数的方式，隔一段时间就冷启动一个运行环境，这样就能使得其他正常的请求都是热启动，从而避免冷启动时间对函数性能的影响。 需要注意： 不要过于频繁调用函数，至少频率要大于 5 分钟 直接调用函数，而不是通过网关等间接调用 创建专门处理这种预热调用的函数，而不是正常业务函数 如果你的业务允许“牺牲第一个请求的性能换取大部分性能”，那也完全不必使用该方案， CloudBase腾讯云CloudLite认证-云开发 CloudBase初识云开发 CloudBase 传统开发模式的问题 云开发 CloudBase 产品介绍 云函数 运行在云端的代码，无需管理服务器 云数据库 即可在前端操作，也能在云函数中读写的 JSON 数据库 云存储 前端可直接上传/下载云端文件，云开发控制台可视化管理 静态托管 一键将静态网站资源部署在云端，提供 CDN 进行加速 云应用 无服务器容器托管平台，用户可面向代码/镜像等多种方式使用 扩展能力 图像处理裁剪、压缩、盲水印、标签、安全审核。 数据库支持 mysql、redis等数据库的快速接入。 CMS 内容管理系统免开发的内容管理系统，方便运营。 Web 云开发快速开始开通环境注册腾讯云账号开通云开发环境 控制台 云产品 云开发 CloudBase 获取 SDK SDK 版本 SDK 链接 配置开发环境 Node.js &gt; 8.6.0 CloudBase CLI 是开源命令行界面交互工具，用于帮助用户快速、方便的部署项目， npm i -g @cloudbase/cli 安装云开发 在 VSCode 中搜索 Tencent CloudBase Toolkit 即可安装 创建初始化项目 vue create cloudbase 创建 Vue 项目 配置云开发 SDKnpm i –save tcb-js-sdk@latest 1234567891011import Vue from 'vue'import App from './App.vue'const tcb = require('tcb-js-sdk')const app = tcb.init({ env:'env-rahqdieb'})Vue.config.productionTip = falsenew Vue({ render:h =&gt; h(App),}).$mount('#app') 添加安全域名 打开云开发控制台，左侧的环境-安全配置-Web 安全域名 开启匿名登录 云开发支持 微信公众号登录、微信开发平台登录、匿名登录、邮箱登录、短信验证码登录和自定义登录。 自定义登录可以用于实现各种自定义的登录逻辑、如LDAP、HTTP Basic等。 云开发的资源要用户登录后才可以调用，匿名登录也是一种登录状态。 访问云开发控制台 找到环境-登录授权 开启匿名登录选项开启匿名登录 123456789101112131415161718import Vue from 'vue'import App from './App.vue'const tcb = require('tcb-js-sdk')const app = tcb.init({ env:'env-rahqdieb'})app.auth({ persistence:&quot;session&quot;}).anonymousAuthProvider().signIn().then(()=&gt;{ // 登录成功}).catch(err=&gt;{ // 登录失败})Vue.config.productionTip = falsenew Vue({ render:h =&gt; h(App),}).$mount('#app') 调用云开发资源 云开发支持在 Web 页面中直接调用云开发数据库 12345678910111213141516171819202122232425import Vue from 'vue'import App from './App.vue'const tcb = require('tcb-js-sdk')const app = tcb.init({ env:'env-rahqdieb'})app.auth({ persistence:&quot;session&quot;}).anonymousAuthProvider().signIn().then((res)=&gt;{ console.log('登录成功',res) // 登录成功 const db = app.database(); const collection = db.collection('user'); collection.get().then(result =&gt; { console.log(result.data); // 这里可以获取到数据 })}).catch(error =&gt; { // 登录失败 console.log('登录失败',error)})Vue.config.productionTip = falsenew Vue({ render:h =&gt; h(App),}).$mount('#app') 调用云开发函数云开发支持在 Web 页面中直接调用云开发函数 123456app.callFunction({ name: 'test', data: { a : 1}}).then((res)=&gt;{ const result = res.result; // 云函数执行结果}) 新建目录 cloud打开 Tencent CloudBase Toolkit 插件，点击初始化云开发项目，选择环境，选择类型npm init，上传部署云函数，在 vue 项目中调用。 1234567891011121314151617181920212223242526272829303132333435363738import Vue from 'vue'import App from './App.vue'const tcb = require('tcb-js-sdk')const app = tcb.init({ env:'env-rahqdieb'})app.auth({ persistence:&quot;session&quot;}).anonymousAuthProvider().signIn().then((res)=&gt;{ console.log('登录成功',res) // 登录成功 const db = app.database(); const collection = db.collection('user'); collection.get().then(result =&gt; { console.log(&quot;数据库返回值&quot;,result.data); }).catch(error =&gt; { console.log('查询出错' error) }) app.callFunction({ name: 'node-app', data: { text: 'hello world', invoker: 'browser' } }).then(item =&gt; { console.log(item) }).catch(error =&gt;{ console.log(error); })}).catch(error =&gt; { // 登录失败 console.log('登录失败',error)})Vue.config.productionTip = falsenew Vue({ render:h =&gt; h(App),}).$mount('#app') 部署静态页面配置云开发 CLI 使用云开发 CLI 可以快速完成项目的上传和部署 执行 npm i -g @cloudbase/cli 安装云开发 CLI 使用 cloudbase login 完成用户登录 进入项目根目录，执行 cloudbase hosting:deploy -e envId 部署静态文件 npm run build 构建静态页面cd distcloudbase logincloudbase hosting:deploy -e env-rahqdied开启静态网站服务 打开云开发控制台 静态网站托管 基础配置 默认域名 30分钟创建并上线小程序项目不勾选云开发，新建文件，在 project.config.json 中指定云开发根目录 1234{ &quot;description&quot;: &quot;项目配置文件&quot;, &quot;cloudfunctionRoot&quot;: &quot;cloudfunctions/&quot;,} 指定云开发环境 123456789101112App({ onLaunch: function () { // app.js if (!wx.cloud) { console.error('请使用 2.2.3 或以上的基础库以使用云能力') } else { wx.cloud.init({ env: 'cloud-demo-51566c', traceUser: true, }) }} 登录功能（云函数的创建和调用）1234&lt;open-data type=&quot;userAvatarUrl&quot;&gt;&lt;/open-data&gt;&lt;open-data type=&quot;userNickName&quot;&gt;&lt;/open-data&gt;&lt;button wx:if=&quot;{{canIUse}}&quot; open-type=&quot;getUserInfo&quot; lang=&quot;zh_CN&quot; bindgetuserinfo=&quot;onGotUserInfo&quot; &gt;登录&lt;/button&gt;&lt;view wx:else&gt;请升级微信版本&lt;/view&gt; 12345678910111213141516171819202122data: { canIUse: wx.canIUse('button.open-type.getUserInfo'), userInfo:{}},onGotUserInfo(e){ console.log(e.detail.userInfo)},onLoad: function (options) { // 查看是否授权 wx.getSetting({ success (res){ if (res.authSetting['scope.userInfo']) { // 已经授权，可以直接调用 getUserInfo 获取头像昵称 wx.getUserInfo({ success: function(res) { console.log(res.userInfo) } }) } } })}, 新建 Node.js 云函数 login 123456789101112131415// 调用云函数wx.cloud.callFunction({ name: 'login', success:res =&gt;{ userInfo.openid = res.result.openid this.setData({ userInfo, hasLogin:true }) app.login(userInfo) }, fail:error=&gt;{ console.log(error); }}) 微信小程序云开发官方文档基础介绍云开发可以开发微信小程序、小游戏，无需搭建服务器环境，即可使用云端能力。云开发提供了完整的原生云端支持和微信服务支持。 云开发提供基础能力 云函数 数据库 存储 云调用 第一个云开发小程序快速使用云开发 新建云开发模板 无游客模式、也不可以使用 测试号 project.config.json 中增加了字段 cloudfunctionRoot 用于指定存放云函数的目录 cloudfunctionRoot 指定的目录有特殊的图标 云开发能力从基础库 2.2.3 开始支持（覆盖率 97.3%，查看兼容性问题） 从基础库 2.4.1 开始，在小程序插件中可以使用云开发。 开通云开发 体验小程序 查看控制台 运营分析：查看云开发监控、配额使用量、用户访问情况 数据库：管理数据库，可查看、增加、更新、查找、删除数据、管理索引、管理数据库访问权限等 存储管理：查看和管理存储空间 云函数：查看云函数列表、配置、日志 云开发能力数据库 关系型 文档型 数据库 database 数据库 database 表 table 集合 collection 行 row 记录 record / doc 列 column 字段 field 集合数据示例 1234567891011121314151617181920212223242526272829303132[ { &quot;_id&quot;: &quot;Wzh76lk5_O_dt0vO&quot;, &quot;title&quot;: &quot;The Catcher in the Rye&quot;, &quot;author&quot;: &quot;J. D. Salinger&quot;, &quot;characters&quot;: [ &quot;Holden Caulfield&quot;, &quot;Stradlater&quot;, &quot;Mr. Antolini&quot; ], &quot;publishInfo&quot;: { &quot;year&quot;: 1951, &quot;country&quot;: &quot;United States&quot; } }, { &quot;_id&quot;: &quot;Wzia0lk5_O_dt0vR&quot;, &quot;_openid&quot;: &quot;ohl4L0Rnhq7vmmbT_DaNQa4ePaz0&quot;, &quot;title&quot;: &quot;The Lady of the Camellias&quot;, &quot;author&quot;: &quot;Alexandre Dumas fils&quot;, &quot;characters&quot;: [ &quot;Marguerite Gautier&quot;, &quot;Armand Duval&quot;, &quot;Prudence&quot;, &quot;Count de Varville&quot; ], &quot;publishInfo&quot;: { &quot;year&quot;: 1848, &quot;country&quot;: &quot;France&quot; } }] id 字段用以唯一标志一条记录_openid 字段用以标志记录的创建者 数据库 API 分为小程序端和服务端，小程序端有限制。数据库 API 包含增删改查的能力，使用 API 操作数据库 获取数据库引用 构造查询/更新条件 发出请求 12345678910111213// 1.获取数据库引用const db = wx.cloud.database();// 2.构造查询语句db.collection('books').where({publishInfo: { country: 'United States'}}).get({ success: function(res) { // 输出 [{ &quot;title&quot;: &quot;The Catcher in the Rye&quot;, ... }] console.log(res) }}) 存储 123456789101112131415wx.chooseImage({ success: chooseResult =&gt; { // 将图片上传至云存储空间 wx.cloud.uploadFile({ // 指定上传到的云路径 cloudPath: 'my-photo.png', // 指定要上传的文件的小程序临时文件路径 filePath: chooseResult.tempFilePaths[0], // 成功回调 success: res =&gt; { console.log('上传成功', res) }, }) },}) 云函数 1234567891011121314// index.js 是入口文件，云函数被调用时会执行该文件导出的 main 方法// event 包含了调用端（小程序端）调用该函数时传过来的参数，同时还包含了可以通过 getWXContext 方法获取的用户登录态 `openId` 和小程序 `appId` 信息const cloud = require('wx-server-sdk')exports.main = (event, context) =&gt; { let { userInfo, a, b} = event let { OPENID, APPID } = cloud.getWXContext() // 这里获取到的 openId 和 appId 是可信的 let sum = a + b return { OPENID, APPID, sum }} 12345678910111213141516171819wx.cloud.callFunction({ // 需调用的云函数名 name: 'add', // 传给云函数的参数 data: { a: 12, b: 19, }, // 成功回调 complete: console.log})// 当然 promise 方式也是支持的wx.cloud.callFunction({ name: 'add', data: { a: 12, b: 19 }}).then(console.log) 重要概念资源环境 建议每一个正式环境都搭配一个测试环境，建议一个创建为 test 测试环境，一个创建为 release 正式环境。 配额 插件支持从基础库 2.4.1 开始，在小程序插件中可以使用云开发。 多端支持云开发除了支持小程序端 SDK、云函数端 SDK 访问外，从 06/04 起支持 Web 端 SDK 访问。 未登录模式开发指引控制台云开发控制台 概览：查看云资源的总体使用情况 用户管理：查看小程序的用户访问记录 数据库：管理数据库集合、记录、权限设置、索引设置 存储管理：管理云文件、权限设置 云函数：管理云函数、查看调用日志、监控记录 统计分析：查看云资源详细使用统计 初始化小程序端初始化 123wx.cloud.init({ env: 'test-x1dzi' // env 设置只会决定小程序API 调用的云环境}) 云函数端初始化 123456789101112131415161718const cloud = require('wx-server-sdk')cloud.init({ env: cloud.DYNAMIC_CURRENT_ENV})exports.main = async (event) =&gt; { const { ENV, OPENID, APPID } = cloud.getWXContext() // 如果云函数所在环境为 abc，则下面的调用就会请求到 abc 环境的数据库 const dbResult = await cloud.database().collection('test').get() return { dbResult, ENV, OPENID, APPID, }} 相关资料Web云开发快速开始√Serverless 掀起新的前端技术变革√小程序云开发 30分钟创建并上线小程序项目√ 云开发自动化索引的设计与实现新能力丨报告，邮箱登录已支持！海量数据热迁移，小程序云开发数据库这样做实战丨云开发帮你和「火箭少女」合个影！实战丨基于云开发实现的外卖小程序如何用Cloudbase Framework部署一个Vue项目？实战丨用云开发快速构建信息申报小程序用云开发实现的开源的外卖小程序，现在来啦如何用云开发打造“万人同屏”高并发实时互动小程序几行代码搞定智能插座控制丨云开发 × 涂鸦小程序云开发数据库核心能力解析及最佳实践浅析小程序云原生数据库设计与应用","link":"/2020/07/29/Blog-about-learning-121/"},{"title":"JavaScript 函数及开发技巧","text":"生成一周时间12345function getWeekTime(){ return [...new Array(7)].map((j,i)=&gt; new Date(Date.now()+i*8.64e7).toLocaleDateString())}getWeekTime();// 输出效果 [&quot;2020/7/21&quot;, &quot;2020/7/22&quot;, &quot;2020/7/23&quot;, &quot;2020/7/24&quot;, &quot;2020/7/25&quot;, &quot;2020/7/26&quot;, &quot;2020/7/27&quot;] 判断空对象12let a = {}JSON.stringify(a) == '{}'; 类型判断1234567891011121314/*** @param {any} target* @param {string} type* @return {boolean}*/function isType(target, type) { let targetType = Object.prototype.toString.call(target).slice(8, -1).toLowerCase() return targetType === type.toLowerCase()}isType([], 'Array') // trueisType(/\\d/, 'RegExp') // trueisType(new Date(), 'Date') // trueisType(function(){}, 'Function') // trueisType(Symbol(1), 'Symbol') // true 对象属性剔除12345678910111213141516171819202122/*** @param {object} object* @param {string[]} props* @return {object}*/function omit(object, props=[]){ let res = {} Object.keys(object).forEach(key=&gt;{ if(props.includes(key) === false){ res[key] = typeof object[key] === 'object' &amp;&amp; object[key] !== null ? jsON.parse(jsON.stringify(object[key])): object[key] } }) return res}let data = { id: 1, title: 'xxx', comment: []}omit(data, ['id']) // {title: 'xxx', comment: []} 日期格式化12345678910111213141516171819202122232425262728/*** @param {string} format* @param {number} timestamp - 时间戳* @return {string}*/function formatDate(format='Y-M-D h:m', timestamp=Date.now()){ let date = new Date(timestamp) let dateInfo = { Y: date.getFullYear(), M: date.getMonth()+1, D: date.getDate(), h: date.getHours(), m: date.getMinutes(), s: date.getSeconds() } let formatNumber = (n) =&gt; n &gt; 10 ? n : '0' + n let res = format .replace('Y', dateInfo.Y) .replace('M', dateInfo.M) .replace('D', dateInfo.D) .replace('h', formatNumber(dateInfo.h)) .replace('m', formatNumber(dateInfo.m)) .replace('s', formatNumber(dateInfo.s)) return res}formatDate() // &quot;2020-2-24 13:44&quot;formatDate('M月D日 h:m') // &quot;2月24日 13:45&quot;formatDate('h:m Y-M-D', 1582526221604) // &quot;14:37 2020-2-24&quot; 性能分析12345678910111213141516window.onload = function(){ setTimeout(()=&gt;{ let t = performance.timing, m = performance.memory console.table({ 'DNS查询耗时': (t.domainLookupEnd - t.domainLookupStart).toFixed(0), 'TCP链接耗时': (t.connectEnd - t.connectStart).toFixed(0), 'request请求耗时': (t.responseEnd - t.responseStart).toFixed(0), '解析dom树耗时': (t.domComplete - t.domInteractive).toFixed(0), '白屏时间': (t.responseStart - t.navigationStart).toFixed(0), 'domready时间': (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0), 'onload时间': (t.loadEventEnd - t.navigationStart).toFixed(0), 'js内存使用占比': m ? (m.usedjsHeapSize / m.totaljsHeapSize * 100).toFixed(2) + '%' : undefined }) })} 防抖1234567891011121314151617181920212223242526272829/*** @param {function} func - 执行函数* @param {number} wait - 等待时间* @param {boolean} immediate - 是否立即执行* @return {function}*/function debounce(func, wait = 300, immediate = false){ let timer, ctx; let later = (arg) =&gt; setTimeout(()=&gt;{ func.apply(ctx, arg) timer = ctx = null }, wait) return function(...arg){ if(!timer){ timer = later(arg) ctx = this if(immediate){ func.apply(ctx, arg) } }else{ clearTimeout(timer) timer = later(arg) } }}let scrollHandler = debounce(function(e){ console.log(e)}, 500)window.onscroll = scrollHandler 节流1234567891011121314151617181920/*** @param {function} func - 执行函数* @param {number} delay - 延迟时间* @return {function}*/function throttle(func, delay){ let timer = null return function(...arg){ if(!timer){ timer = setTimeout(()=&gt;{ func.apply(this, arg) timer = null }, delay) } }}let scrollHandler = throttle(function(e){ console.log(e)}, 500)window.onscroll = scrollHandler base64数据导出文件下载1234567891011121314151617181920212223/*** @param {string} filename - 下载时的文件名* @param {string} data - base64字符串*/function downloadFile(filename, data){ let downloadLink = document.createElement('a'); if ( downloadLink ){ document.body.appendChild(downloadLink); downloadLink.style = 'display: none'; downloadLink.download = filename; downloadLink.href = data; if ( document.createEvent ){ let downloadEvt = document.createEvent('MouseEvents'); downloadEvt.initEvent('click', true, false); downloadLink.dispatchEvent(downloadEvt); } else if ( document.createEventObject ) { downloadLink.fireEvent('onclick'); } else if (typeof downloadLink.onclick == 'function' ) { downloadLink.onclick(); } document.body.removeChild(downloadLink); }} 检测是否为PC端浏览器123456789101112function isPCBroswer() { let e = window.navigator.userAgent.toLowerCase() , t = &quot;ipad&quot; == e.match(/ipad/i) , i = &quot;iphone&quot; == e.match(/iphone/i) , r = &quot;midp&quot; == e.match(/midp/i) , n = &quot;rv:1.2.3.4&quot; == e.match(/rv:1.2.3.4/i) , a = &quot;ucweb&quot; == e.match(/ucweb/i) , o = &quot;android&quot; == e.match(/android/i) , s = &quot;windows ce&quot; == e.match(/windows ce/i) , l = &quot;windows mobile&quot; == e.match(/windows mobile/i); return !(t || i || r || n || a || o || s || l)} 识别浏览器及平台123456789101112131415161718192021222324function getPlatformInfo(){ //运行环境是浏览器 let inBrowser = typeof window !== 'undefined'; //运行环境是微信 let inWeex = typeof WXEnvironment !== 'undefined' &amp;&amp; !!WXEnvironment.platform; let weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase(); //浏览器 UA 判断 let UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase(); if(UA){ let platforms = { IE: /msie|trident/.test(UA), IE9: UA.indexOf('msie 9.0') &gt; 0, Edge: UA.indexOf('edge/') &gt; 0, Android: UA.indexOf('android') &gt; 0 || (weexPlatform === 'android'), IOS: /iphone|ipad|ipod|ios/.test(UA) || (weexPlatform === 'ios'), Chrome: /chrome\\/\\d+/.test(UA) &amp;&amp; !(UA.indexOf('edge/') &gt; 0), } for (const key in platforms) { if (platforms.hasOwnProperty(key)) { if(platforms[key]) return key } } }} 加入收藏、设为首页、保存到桌面12345678910111213141516171819202122232425262728293031323334353637383940414243//设为首页function SetHome(obj,url){ try{ obj.style.behavior='url(#default#homepage)'; obj.setHomePage(url); }catch(e){ if(window.netscape){ try{ netscape.security.PrivilegeManager.enablePrivilege(&quot;UniversalXPConnect&quot;); }catch(e){ alert(&quot;抱歉，此操作被浏览器拒绝！\\n\\n请在浏览器地址栏输入“about:config”并回车然后将[signed.applets.codebase_principal_support]设置为'true'&quot;); } }else{ alert(&quot;抱歉，您所使用的浏览器无法完成此操作。\\n\\n您需要手动将【&quot;+url+&quot;】设置为首页。&quot;); } }}//收藏本站function AddFavorite(title, url) { try { window.external.addFavorite(url, title); } catch (e) { try { window.sidebar.addPanel(title, url, &quot;&quot;); } catch (e) { alert(&quot;抱歉，您所使用的浏览器无法完成此操作。\\n\\n加入收藏失败，请使用Ctrl+D进行添加&quot;); } }}//保存到桌面function toDesktop(sUrl,sName){ try { var WshShell = new ActiveXObject(&quot;WScript.Shell&quot;); var oUrlLink = WshShell.CreateShortcut(WshShell.SpecialFolders(&quot;Desktop&quot;) + &quot;\\\\&quot; + sName + &quot;.url&quot;); oUrlLink.TargetPath = sUrl; oUrlLink.Save(); } catch(e) { alert(&quot;当前IE安全级别不允许操作！&quot;); }} 123&lt;a href=&quot;JavaScript:void(0);&quot; onclick=&quot;SetHome(this,'http://www.xyz.com');&quot;&gt;设为首页&lt;/a&gt;&lt;a href=&quot;JavaScript:void(0);&quot; onclick=&quot;AddFavorite('我的网站',location.href)&quot;&gt;收藏本站&lt;/a&gt;&lt;a href=&quot;JavaScript:void(0);&quot; onclick=&quot; toDesktop(location.href,'我的网站')&quot;&gt;保存到桌面&lt;/a&gt; 实现隐藏手机号码中间4位数1234567891011121314151617// 正则function geTel(tel){ var reg = /^(\\d{3})\\d{4}(\\d{4})$/; return tel.replace(reg, &quot;$1****$2&quot;);}//测试var tel = &quot;17326453333&quot;; console.log(geTel(tel));//173****3333// 通过长度截取// 长度截取function geTel(tel){ return tel.substring(0, 3)+&quot;****&quot;+tel.substr(tel.length-4);}//测试var tel = &quot;17326453333&quot;;console.log(geTel(tel));//173****3333 延迟函数delay123456789101112131415 const delay = ms =&gt; new Promise((resolve, reject) =&gt; setTimeout(resolve, ms)) const getData = status =&gt; new Promise((resolve, reject) =&gt; { status ? resolve('done') : reject('fail') })const getRes = async (data) =&gt; { try { const res = await getData(data) const timestamp = new Date().getTime() await delay(1000) console.log(res, new Date().getTime() - timestamp) } catch (error) { console.log(error) }}getRes(true) // 隔了1秒 分割指定长度的元素数组123456789101112131415const listChunk = (list, size = 1, cacheList = []) =&gt; { const tmp = [...list] if (size &lt;= 0) { return cacheList } while (tmp.length) { cacheList.push(tmp.splice(0, size)) } return cacheList}console.log(listChunk([1, 2, 3, 4, 5, 6, 7, 8, 9])) // [[1], [2], [3], [4], [5], [6], [7], [8], [9]]console.log(listChunk([1, 2, 3, 4, 5, 6, 7, 8, 9], 3)) // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]console.log(listChunk([1, 2, 3, 4, 5, 6, 7, 8, 9], 0)) // []console.log(listChunk([1, 2, 3, 4, 5, 6, 7, 8, 9], -1)) // [] 字符串前面空格去除与替换123const trimStart = str =&gt; str.replace(new RegExp('^([\\\\s]*)(.*)$'), '$2')console.log(trimStart(' abc ')) // abc console.log(trimStart('123 ')) // 123 字符串后面空格去除与替换123const trimEnd = str =&gt; str.replace(new RegExp('^(.*?)([\\\\s]*)$'), '$1')console.log(trimEnd(' abc ')) // abc console.log(trimEnd('123 ')) // 123 获取当前子元素是其父元素下子元素的排位12345678910const getIndex = el =&gt; { if (!el) { return -1 } let index = 0 do { index++ } while (el = el.previousElementSibling); return index} 获取当前元素相对于document的偏移量1234567891011121314const getOffset = el =&gt; { const { top, left } = el.getBoundingClientRect() const { scrollTop, scrollLeft } = document.body return { top: top + scrollTop, left: left + scrollLeft }} 获取元素类型1const dataType = obj =&gt; Object.prototype.toString.call(obj).replace(/^\\[object (.+)\\]$/, '$1').toLowerCase(); 判断是否是移动端1const isMobile = () =&gt; 'ontouchstart' in window fade动画1234567891011121314151617const fade = (el, type = 'in') { el.style.opacity = (type === 'in' ? 0 : 1) let last = +new Date() const tick = () =&gt; { const opacityValue = (type === 'in' ? (new Date() - last) / 400 : -(new Date() - last) / 400) el.style.opacity = +el.style.opacity + opacityValue last = +new Date() if (type === 'in' ? (+el.style.opacity &lt; 1) : (+el.style.opacity &gt; 0)) { requestAnimationFrame(tick) } } tick()} 将指定格式的字符串解析为日期字符串12345678910const dataPattern = (str, format = '-') =&gt; { if (!str) { return new Date() } const dateReg = new RegExp(`^(\\\\d{2})${format}(\\\\d{2})${format}(\\\\d{4})$`) const [, month, day, year] = dateReg.exec(str) return new Date(`${month}, ${day} ${year}`)}console.log(dataPattern('12-25-1995')) // Mon Dec 25 1995 00:00:00 GMT+0800 (中国标准时间) 禁止网页复制粘贴1const html = document.querySelector('html') html.oncopy = () =&gt; false html.onpaste = () =&gt; false input框限制只能输入中文12345678910111213141516171819const input = document.querySelector('input[type=&quot;text&quot;]')const clearText = target =&gt; { const { value } = target target.value = value.replace(/[^\\u4e00-\\u9fa5]/g, '')}input.onfocus = ({target}) =&gt; { clearText(target)}input.onkeyup = ({target}) =&gt; { clearText(target)}input.onblur = ({target}) =&gt; { clearText(target)}input.oninput = ({target}) =&gt; { clearText(target)} 去除字符串的html代码12const removehtml = (str = '') =&gt; str.replace(/&lt;[\\/\\!]*[^&lt;&gt;]*&gt;/ig, '')console.log(removehtml('&lt;h1&gt;哈哈哈哈&lt;呵呵呵&lt;/h1&gt;')) // 哈哈哈哈&lt;呵呵呵 将RGB模式下的颜色转换为十六进制12const RGBToHex = (r, g, b) =&gt; ((r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).padStart(6, '0');let hex = RGBToHex(255, 255, 255); // ffffff 获取数组交集1234const intersection = (list, ...args) =&gt; list.filter(item =&gt; args.every(list =&gt; list.includes(item)))console.log(intersection([2, 1], [2, 3])) // [2]console.log(intersection([1, 2], [3, 4])) // [] 类型强制转换string 强制转换为数字常用 *、+ 将 字符串转为数字 123456789'32' * 1 // 32'ds' * 1 // NaNnull * 1 // 0undefined * 1 // NaN+ '123' // 123+ 'ds' // NaN+ '' // 0+ null // 0+ undefined // NaN 使用 Boolean 过滤数组中的所有假值12const compact = arr =&gt; arr.filter(Boolean)compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]) // [ 1, 2, 3, 'a', 's', 34 ] 取整num | 0 121.3 | 0 // 1-1.9 | 0 // -1 判断奇偶&amp;、% 123456789!!(1 % 2) // true 奇!!(5 % 2) // true 奇!!(2 % 2) // false 偶!!(0 % 2) // false 偶!!(1 &amp; 1) // true 奇!!(5 % 1) // true 奇!!(2 % 1) // false 偶!!(0 % 1) // false 偶 函数函数默认值12func = (l, m = 3, n = 4 ) =&gt; (l * m * n);func(2) //output: 24 强制参数123456mandatory = ( ) =&gt; { throw new Error('Missing parameter!');}foo = (bar = mandatory( )) =&gt; { // 这里如果不传入参数，就会执行manadatory函数报出错误 return bar;} 隐式返回值1234567function calcCircumference(diameter) { return Math.PI * diameter}// 简写为：calcCircumference = diameter =&gt; ( Math.PI * diameter;) 一次性函数123456789var sca = function() { console.log('msg') sca = function() { console.log('foo') }}sca() // msgsca() // foosca() // foo 通过图片 url 获取文件大小 通过Ajax请求获取 通过Performance API 最好的方式就是，只对专门放置资源文件的服务器设置该响应头，或者在主服务器中，针对资源文件的请求加入该响应头，就可以避免这种漏洞了。 字符串字符串比较时间先后123456var a = &quot;2014-08-08&quot;;var b = &quot;2014-09-09&quot;;console.log(a&gt;b, a&lt;b); // false trueconsole.log(&quot;21:00&quot;&lt;&quot;09:10&quot;); // falseconsole.log(&quot;21:00&quot;&lt;&quot;9:10&quot;); // true 时间形式注意补0 在字符串中查找给定的单词，并替换为另一个单词12const findAndReplace = (string, wordToFind, wordToReplace) =&gt; string.split(wordToFind).join(wordToReplace);let result = findAndReplace('I like banana', 'banana', 'apple'); // I like apple 数字精确到指定位数的小数123const round = (n, decimals = 0) =&gt; Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`)round(1.345, 2) // 1.35round(1.345, 1) // 1.3 数字补0操作12345const addZero1 = (num, len = 2) =&gt; (`0${num}`).slice(-len)const addZero2 = (num, len = 2) =&gt; (`${num}`).padStart( len , '0')addZero1(3) // 03addZero2(32,4) // 0032 数组reduce方法同时实现map和filter123456789const numbers = [10, 20, 30, 40];const doubledOver50 = numbers.reduce((finalList, num) =&gt; { num = num * 2; if (num &gt; 50) { finalList.push(num); } return finalList;}, []);doubledOver50; // [60, 80] 统计数组中相同项的个数123456var cars = ['BMW','Benz', 'Benz', 'Tesla', 'BMW', 'Toyota'];var carsObj = cars.reduce(function (obj, name) { obj[name] = obj[name] ? ++obj[name] : 1; return obj;}, {});carsObj; // =&gt; { BMW: 2, Benz: 2, Tesla: 1, Toyota: 1 } 使用解构来交换参数数值12345678910let param1 = 1;let param2 = 2;[param1, param2] = [param2, param1];console.log(param1) // 2console.log(param2) // 1// 交换值var temp = a; a = b; b = tempb = [a, a = b][0]a = a + b; b = a - b; a = a - b 接收函数返回的多个结果1234567async function getFullPost(){ return await Promise.all([ fetch('/post'), fetch('/comments') ]);}const [post, comments] = getFullPost(); 将数组平铺到指定深度123456const flatten = (arr, depth = 1) =&gt; depth != 1 ? arr.reduce((a, v) =&gt; a.concat(Array.isArray(v) ? flatten(v, depth - 1) : v), []) : arr.reduce((a, v) =&gt; a.concat(v), []);flatten([1, [2], 3, 4]); // [1, 2, 3, 4]flatten([1, [2, [3, [4, 5], 6], 7], 8], 2); // [1, 2, 3, [4, 5], 6, 7, 8] 数组的对象解构12345const csvFileLine = '1997,John Doe,US,john@doe.com,New York';const { 2: country, 4: state } = csvFileLine.split(',');country // USstate // New Yourk 获取数组中的最大数字12const maxItemOfArray = (arr) =&gt; arr.sort((a, b) =&gt; b - a)[0];let maxItem = maxItemOfArray([3, 5, 12, 5]); 检查数组的所有项是否相等123const areAllEqual = array =&gt; array.every(item =&gt; item === array[0]);let check1 = areAllEqual([3, 5, 2]); // falselet check2 = areAllEqual([3, 3, 3]); // true 求给定数字的平均值12const averageOf = (...numbers) =&gt; numbers.reduce((a, b) =&gt; a + b, 0) / numbers.length;let average = averageOf(5, 2, 4, 7); 反转一个字符串12const reverseString = str =&gt; [...str].reverse().join('');let a = reverseString('Have a nice day!'); // !yad ecin a evaH 求给定数字的和12const sumOf = (...numbers) =&gt; numbers.reduce((a, b) =&gt; a + b, 0);let sum = sumOf(5, -3, 2, 1); // 5 对象使用解构删除不必要属性12let {_internal, tooBig, ...cleanObject} = {el1: '1', _internal:&quot;secret&quot;, tooBig:{}, el2: '2', el3: '3'};console.log(cleanObject); // {el1: '1', el2: '2', el3: '3'} 正则校验金额123export const isMoney = (s) =&gt; { return /(^[1-9]([0-9]+)?(\\.[0-9]{1,2})?$)|(^(0){1}$)|(^[0-9]\\.[0-9]([0-9])?$)/.test(s)} 邮箱123export const isEmail = (s) =&gt; { return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/.test(s)} 手机号码123export const isMobile = (s) =&gt; { return /^1[0-9]{10}$/.test(s)} 123export const isMobile = (s) =&gt; { return /^1(3|4|5|6|7|8|9)\\d{9}$/.test(s)} 电话号码123export const isPhone = (s) =&gt; { return /^([0-9]{3,4}-)?[0-9]{7,8}$/.test(s)} 是否url地址123export const isURL = (s) =&gt; { return /^http[s]?:\\/\\/.*/.test(s)} 判断类型是否字符串123export const isString = (o) =&gt; { return Object.prototype.toString.call(o).slice(8, -1) === 'String'} 是否数组123export const isArray = (o) =&gt; { return Object.prototype.toString.call(o).slice(8, -1) === 'Array'} 1Array.isArray([1, 2, 3]); 是否数字123export const isNumber = (o) =&gt; { return Object.prototype.toString.call(o).slice(8, -1) === 'Number'} 是否boolean123export const isBoolean = (o) =&gt; { return Object.prototype.toString.call(o).slice(8, -1) === 'Boolean'} 是否函数123export const isFunction = (o) =&gt; { return Object.prototype.toString.call(o).slice(8, -1) === 'Function'} 是否为null123export const isNull = (o) =&gt; { return Object.prototype.toString.call(o).slice(8, -1) === 'Null'} 取消双击后的文本选中123456document.addEventListener('mousedown', (event) =&gt; { if (event.detail &gt; 1) { event.preventDefault(); // ... }}, false); 去除字符串内的文件扩展名1fileName.replace(/\\.[^/.]+$/, &quot;&quot;); Node 获取文件名123const path = require('path');const filename = 'foo.txt';path.parse(filename).name; 防止鼠标选中事件1234&lt;div class=&quot;mask&quot; onselectstart=&quot;return false&quot;&gt;&lt;/div&gt;&lt;div class=&quot;link&quot;&gt; &lt;a href=&quot;javascrip;;&quot;&gt;登录&lt;/a&gt;&lt;/div&gt; 给元素添加了onslectstart=”return false”,就可以防止鼠标选中事件。 给动态添加的元素绑定事件12$(document).on(&quot;click&quot;, &quot;.large&quot;, slide); //jq中的写法//第一个参数表示的是对应事件，第二个是需要绑定事件的元素的id或class，第三个是绑定的对应的事件函数名 常用的全屏居中 JS 函数12345678910111213141516//获取元素function getElement(ele) { return document.getElementById(ele);}//自动居中函数function autoCenter(el) { var bodyX = document.documentElement.offsetWidth || document.body.offsetWidth; var bodyY = document.documentElement.offsetHeight || document.body.offsetHeight; var elementX = el.offsetWidth; var elementY = el.offsetHeight; el.style.left = (bodyX - elementX) / 2 + &quot;px&quot;; el.style.top = (bodyY - elementY) / 2 + &quot;px&quot;;} 在输入框输入完内容并按回车的时候进行判断12345678&lt;input type=&quot;textbox&quot; id=&quot;textbox1&quot; onkeypress=&quot;CheckInfo&quot; /&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; function CheckInfo (){ if (event.keyCode==13) { alert(textbox1.text); } }&lt;/script&gt; Video1234567891011121314151617181920212223242526var elevideo = document.getElementById(&quot;video&quot;);elevideo.addEventListener(‘loadedmetadata‘, function () { //加载数据 //视频的总长度 console.log(elevideo.duration);});elevideo.addEventListener(‘play‘, function () { //播放开始执行的函数 console.log(&quot;开始播放&quot;);});elevideo.addEventListener(‘playing‘, function () { //播放中 console.log(&quot;播放中&quot;);});elevideo.addEventListener(‘waiting‘, function () { //加载 console.log(&quot;加载中&quot;);});elevideo.addEventListener(‘pause‘, function () { //暂停开始执行的函数 console.log(&quot;暂停播放&quot;);});elevideo.addEventListener(‘ended‘, function () { //结束 console.log(&quot;播放结束&quot;);}, false); 以上是我对下列视频及文章的归纳和总结。10个非常实用的JS工具函数√JS实现浏览器：加入收藏、设为首页、保存到桌面的方法功能√【开发小技巧】022—如何通过JS方式实现隐藏手机号码中间4位数 √JS 中可以提升幸福度的小技巧√15条高效的JS技巧，你千万要收藏好了√面试问题之——给你图片的url，你能知道它所占的字节空间吗？ √12 个实用的前端开发技巧总结 √JS判断视频Video的播放、暂停、结束完成及获取长度事件监听处理√ JS生成随机的由字母数字组合的字符串√ Html中换行符\\n的传输、保存、显示？√ 字符串转对象的三种方式√ 工作中常用js的整理12种JS常用获取时间的方式41个最新的JavaScript开发技巧，你必须要知道 15条值得收藏的高效JS技巧15条JS技巧JavaScript中的reduce()的5个用例 解锁各种js数组骚操作，总有你想要的！7个处理JavaScript值为undefined的技巧我和大佬之间差一个 JS 工具函数大全前端常用 60 余种工具方法完美版 js 金钱正则表达式校验取消双击后的文本选中18个有用的JavaScript片段前后端导出/下载excel方法24个解决实际问题的ES6代码段","link":"/2020/06/29/Blog-about-learning-119/"},{"title":"工作中遇到的问题","text":"视频视频下载VueVue2 数据更新，视图不更新this.$set( target, key, value) 相关资料深入响应式原理√从vue源码解析Vue.set()和this.$set()vue中this.$set的用法","link":"/2020/06/17/Blog-about-learning-128/"},{"title":"跨域 从入门到实战","text":"当遇到跨域开发时, 我们如何处理好前后端配置和请求库封装(koa/axios版)","link":"/2020/08/03/Blog-about-learning-129/"},{"title":"Koa2 学习","text":"基础篇书籍视频Koa2 免费视频教程Koa2+Vue2.x 实战电商系统Nodejs 教程 Nodejs+Koa2 入门实战视频教程Nodejs 教程 Koa 教程 Koa2 MongoDb 入门实战视频教程node 版本升级Windows重新安装 node目录查找：Where node Sudo npm install -g nSudo n stable 技术分享文章Koa2 进阶学习笔记Koa.js 设计模式-学习笔记 博客官方文档例子&amp;示例实战项目源码Koa2 源码解读知识点12345678910111213141516171819202122232425const Koa = require('koa');const app = new Koa();app.use((ctx, next) =&gt; { ctx.body = [ { name: 'tom' } ] next()})app.use((ctx, next) =&gt; { console.log('url' + ctx.url); if (ctx.url === '/html') { ctx.type = 'text/html;charset=utf-8' ctx.body = `&lt;b&gt;我的名字是:${ctx.body[0].name}&lt;/b&gt;` }}app.listen(3000)// 路由const router = {}router['/html'] = ctx =&gt; { ctx.type = 'text/html;charset=utf-8' ctx.body = `&lt;b&gt;我的名字是:${ctx.body[0].name}&lt;/b&gt;`}router[ctx.url](ctx) 常⻅见的中间件操作 静态服务app.use(require(‘koa-static’)(__dirname + ‘/‘)) 路路由 12345678910const router = require('koa-router')();router.get('/string', async (ctx, next) =&gt; { ctx.body = 'koa2 string'})router.get('/json', async (ctx, next) =&gt; { ctx.body = { title: 'koa2 json' }})app.use(router.routes()) 日志 1234567app.use(async (ctx,next) =&gt; { const start = new Date().getTime() console.log(`start: ${ctx.url}`); await next(); const end = new Date().getTime() console.log(`请求${ctx.url}, 耗时${parseInt(end-start)}ms`)}) koa 原理","link":"/2020/01/26/Blog-about-learning-13/"},{"title":"效果实现","text":"web页面内容滑动效果事件 touchstart事件：手指触摸时候触发（支持多指触发） touchmove事件：手指在滑动的时候连续地触发。在这个事件发生期间，调用 preventDefault()事件可以阻止滚动，当然也不能滥用否则会影响原有页面的上下滚动等。 touchend事件：手指从屏幕上离开的时候触发 touchcancel事件：当系统停止跟踪触摸的时候触发。关于这个事件的确切出发时间，文档中并没有具体说明。。。不建议使用 相关资料手把手教你实现web页面内容滑动效果√","link":"/2020/08/03/Blog-about-learning-131/"},{"title":"Webpack 从入门到实战","text":"相关资料 《Webpack 从零入门到工程化实战》专栏源码 初学者应该看的 Webpack 完整指南（2020）分享18个webpack插件，你千万要收藏好，留备用【第1711期】Webpack优化——将你的构建效率提速翻倍【Webpack】319- Webpack4 入门手册（共 18 章）（上）【Webpack】320- Webpack4 入门手册（共 18 章）（下）Webpack原理浅析","link":"/2020/08/03/Blog-about-learning-130/"},{"title":"js库","text":"swiper移动触摸滑块我上大学的时候用它做轮播、做微场景 Leaflet地图图块 fullpage创建全屏滚动 anime.js动画库 screenfull.js全屏 moment解析，验证，操作和显示日期 hammer.js检测触摸手势 masonry网格布局插件 d3数据可视化库 slick轮播库 Popper.jspopper 元素 放置位置 day.js解析，验证，操作和显示现代浏览器的日期和时间 lodash现代化的JavaScript实用程序库，提供模块化，性能和附加功能。 zepto.jsZepto是用于现代浏览器的极简JavaScript库，具有与jQuery兼容的API。如果您使用jQuery，您已经知道如何使用Zepto。 jQuerytfjs一个WebGL加速的JavaScript库，用于训练和部署ML模型。 iscroll网页平滑滚动（建议使用 better-scroll） better-scroll解决移动端，各种滚动场景需求的插件 download文件下载 clipboard将文本复制到剪贴板 Print.js打印在 vue 中使用出现，border 无法打印，不能使用浮动布局，会造成文字重叠，文字过长换行导致行文字重叠等。 html2canvas截屏 Canvas2image将画布保存或转换为图像的工具 qrcodejs二维码生成器 js-cookiecookie 的处理 sheetjsEXCEL 表格的预览、读写处理、导出表格等。 jszip一个用于使用 JavaScript 创建，读取和编辑.zip文件的库。 fuse.jsFuse.js是JavaScript中的轻量级模糊搜索。 FileSaver.jsFileSaver.js是在客户端保存文件的解决方案，非常适合在客户端上生成文件的Web应用程序。 dropzoneDropzone.js是一个轻量级的JavaScript库，可将HTML元素转换为dropzone。这意味着用户可以将文件拖放到该文件上，然后该文件通过AJAX上传到服务器。 js-md5JavaScript的简单MD5哈希函数支持UTF-8编码。 JavaScript-MD5JavaScript MD5实现。 pdf.jsPDF.js是使用HTML5构建的可移植文档格式（PDF）查看器。 ts-migrate一种帮助将JavaScript代码快速便捷地迁移到TypeScript的工具 react-content-loader骨架屏 dps网页骨架屏自动生成 number-precision1K 微小且快速的库，用于精确地执行加，减，乘和除运算。 fastclickPolyfill可消除使用触摸UI的浏览器的点击延迟。注意：截至2015年末，大多数移动浏览器-特别是Chrome和Safari-不再具有300ms的触摸延迟，因此fastclick对较新的浏览器没有好处，并且存在将错误引入应用程序的风险。请仔细考虑您是否真的需要使用它。 SVG.js一个轻量级的库，用于操纵和动画SVG，没有任何依赖关系。 lib-flexible可伸缩布局方案。rem 库解决方案 basket.js脚本和资源加载器，用于通过localStorage缓存和加载文件 store使用localStorage和sessionStorage的更好方法 lscache一个基于本地存储的受内存缓存启发的客户端缓存库。 PubSubJSJavaScript的无依赖关系免费发布/订阅 zTree依赖 JQuery 的 树形结构 SortableSortable是一个JavaScript库，用于可重新排序的拖放列表。 Mock假数据 JustAuth第三方授权登录的工具类库 VditorMarkdown 编辑器 相关资料前端常用插件、工具类库汇总，不要重复造轮子啦图像特效库15个非常实用的JavaScript表单验证库20个+强大的翻书效果插件15 个最佳 jQuery 翻书效果插件蚂蚁可视化图表推荐18个基于 HTML5 Canvas 开发的图表库大屏数据可视化工具10个JavaScript图像处理库，收藏好留备用图片处理不用愁，给你十个小帮手JavaScript 数学库、算法库FastClick用法√使用Flexible实现手淘H5页面的终端适配前端高效开发必备的 js 库梳理若川知乎高赞：有哪些必看的 JS 库？网页骨架屏自动生成方案 让我告诉你一些强无敌的 NPM 软件包","link":"/2020/08/04/Blog-about-learning-132/"},{"title":"CSS 库","text":"animate.csscss 动画库 normalize.css初始化 CSS Bootstrap Foundation Semantic UI Pure UIkit Ant DesignBulmaSpectreTailwindShoelaceSkeletonTachyonsMaterial DesignElement WeUI Materialize iView layui Gentelella Admin NES-style VUX Vant Cube UI","link":"/2020/08/04/Blog-about-learning-133/"},{"title":"JavaScript 书写规范及技巧","text":"强类型检查使用 === 而不是 == 1234567891011121314150 == false // true 0 === false // false 2 == &quot;2&quot; // true 2 === &quot;2&quot; // false // example const val = &quot;123&quot;; if (val === 123) { console.log(val); // it cannot not be reached } if (val === &quot;123&quot;) { console.log(val); // it can be reached} 变量命名1234567891011121314151617181920212223// 不推荐let daysSLV = 10;let y = new Date().getFullYear();let ok;if (user.age &gt; 30) { ok = true;}// 推荐const MAX_AGE = 30;let daysSinceLastVisit = 10;let currentYear = new Date().getFullYear();...const isUserOlderThanAllowed = user.age &gt; MAX_AGE;// 不要添加一些额外且不必要的词汇到你的变量名称中。let nameValue;let theProduct;// 推荐let name; let product; 设置原型的构造函数12345678910111213141516171819function Person(name) { this.name = name;} function Student(name) { Person.call(this, name);}Student.prototype = Object.create(Person.prototype);// Student 的原型会被设置为 Person。// 实际上想要将 Student 的原型设置为 Student。// 需要这么写Student.prototype.constructor = Student;// 或者class Student extends Person {} 创建 Web Workers12345678910111213141516&lt;script id=&quot;worker&quot; type=&quot;javascript/worker&quot;&gt; self.onmessage = (e) =&gt; { self.postMessage('msg'); };&lt;/script&gt;&lt;script&gt; const blob = new Blob([ document.querySelector('#worker').textContent ]); const worker = new Worker(window.URL.createObjectURL(blob)); worker.onmessage = (e) =&gt; { console.log(e.data); } worker.postMessage(&quot;hello&quot;);&lt;/script&gt; map 技巧map 里使用 parseInt 会返回 NaN123456// 不要这么写['1','2','3'].map(parseInt)// 可以['1','2','3'].map(Number)['1','2','3'].map(num =&gt; parseInt(num, 10)) 三目运算符12345// 当 x === 1 返回 false 不想调用 doSomethingElse 时x === 1 ? doSomething() : doSomethingElse();// 可以x === 1 &amp;&amp; doSomething(); 清除 Yarn 中的缓存1yarn cache clear innerText 在 IE 有效，其他浏览器无效12const el = document.getElementById('foo');el.textContent = 'foo'; [译] JavaScript 技巧 —— 子代构造函数，文本选择，内联 Workers 等等√【译】JS代码整洁之道——快速最佳实践√JavaScript闭包应用介绍如何精确统计页面停留时长","link":"/2020/08/04/Blog-about-learning-134/"},{"title":"echarts 从入门到实践开发","text":"折线图数据加单位1234567891011121314151617181920212223242526// 显示单个数据tooltip: { show:true, trigger:'item', formatter: function(params){ var relVal = params.seriesName +'&lt;br/&gt;' + params.value + '%'; return relVal }},// 显示多个数据tooltip: { trigger: 'axis', formatter:function(params) { var relVal = params[0].name; for (var i = 0, l = params.length; i &lt; l; i++) { relVal += '&lt;br/&gt;' + params[i].marker + params[i].seriesName + ' : ' + params[i].value+&quot;件&quot;; } return relVal; }},tooltip: { trigger: 'axis', formatter: '{a}{b}{c}'}, 相关资料百度Echarts折线图tooltip里数据添加单位Echarts地图china.js基于VUE + Echarts 实现可视化数据大屏展示效果ECharts 实现地图散点图（上）vue全家桶+Echarts+百度地图，搭建数据可视化系统vue全家桶+Echarts+百度地图，搭建数据可视化系统基于Echarts的中国地图数据展示基于f2从零实现移动端可视化编辑器visualization 标签 github 搜索inmap 地理可视化推荐四款可视化工具，解决99%的可视化大屏需求、qucikBI、superset、redash","link":"/2020/08/04/Blog-about-learning-136/"},{"title":"移动端适配","text":"Web移动端实现自适应缩放界面的方法汇总轻松搞定移动端适配","link":"/2020/08/04/Blog-about-learning-135/"},{"title":"node 从入门到实践开发","text":"工具nvm：node 版本管理工具 ，之前的篇幅有详细介绍过安装以及应用。 pm2：类似 windows 任务管理器 库Koa","link":"/2020/01/26/Blog-about-learning-14/"},{"title":"eslint","text":"eslint 扩展eslint 扩展：standard，airbnb，eslint-config-alloy等。 eslint 扩展做了 在原有的 eslint 的基础上配置些 config（具体规则参数，全局变量，运行环境等） 自定义些自己的 rule，以满足需求 eslint 自身配置已经无法满足业务需求。如 eslint-plugin-vue eslint-plugin-react eslint-plugin-jest 一般特殊场景的自定义规则都使用 eslint-plugin-* 的命名，使用时可以方便的写成 1234567{ plugins: [ 'vue', 'react', 'jest' ] } eslint-config-* 同理，不过配置时需要写成 123{ extends: 'standard'} 社区有些比较热门的代码规范，比如standardjs、airbnb。 Prettier统一代码风格的利器。 相关资料我是如何在公司项目中使用ESLint来提升代码质量的开发 eslint 规则 使用ESLint+Prettier来统一前端代码风格 深入理解 ESLint ESLint 在中大型团队的应用实践ESLint进阶指南ESLint + Prettier 规范前端代码 ESLint和Prettier的混合使用从零构建前端 ESLint 工作流（2020 手把手版）","link":"/2020/08/04/Blog-about-learning-141/"},{"title":"文件预览","text":"pdf 可以通过 object 标签实现预览。 相关资料object、param标签及页面显示PDF文件的方法object对于docx，pptx等，什么是正确的MIME类型？","link":"/2020/08/04/Blog-about-learning-142/"},{"title":"token 过期，刷新 token 处理","text":"token 过期 直接跳转到登录页面，重新登录 如果返回 token失效的信息，自动去刷新token，然后继续完成未完成的请求操作。需要注意多次请求会造成 tonken 多次刷新 相关资料前端请求token过期时,刷新token的处理对于token的认证，如何保证token的及时刷新","link":"/2020/08/04/Blog-about-learning-143/"},{"title":"Vue Router","text":"Vue Router 任何组件内通过 this.$router 访问路由器，可以通过 this.$route 访问当前路由 回退 123goBack() { window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push('/')} 动态路由匹配 12345678910111213const router = new VueRouter({ routes: [ // 动态路径参数 以冒号开头 { path: '/user/:id', component: User } { path: '/user/:username/post/:post_id', component: User } ]})// 接受参数const User = { template: '&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;'}this.$route.params.id 当使用路由参数时，例如从 /user/foo 导航到 /user/bar，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。 12345678910watch: { $route(to, from) { // 对路由变化作出响应... } // 导航守卫 beforeRouteUpdate (to, from, next) { // react to route changes... // don't forget to call next() }} 捕获所有路由 12345678{ // 会匹配所有路径 path: '*'}{ // 会匹配以 `/user-` 开头的任意路径 path: '/user-*'} 当使用一个通配符时，$route.params 内会自动添加一个名为 pathMatch 参数。它包含了 URL 通过通配符被匹配的部分： 123456// 给出一个路由 { path: '/user-*' }this.$router.push('/user-admin')this.$route.params.pathMatch // 'admin'// 给出一个路由 { path: '*' }this.$router.push('/non-existing')this.$route.params.pathMatch // '/non-existing' 路由嵌套 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;const User = { template: ` &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;User {{ $route.params.id }}&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;`}const router = new VueRouter({ routes: [ { path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功， // UserHome 会被渲染在 User 的 &lt;router-view&gt; 中 { path: '', component: UserHome }, // ...其他子路由 { // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'profile', component: UserProfile }, { // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts } ] } ]}) 编程式的导航 声明式 编程式 router-link :to=”…” router.push(…) 12345678910111213// 字符串router.push('home')// 对象router.push({ path: 'home' })// 命名的路由router.push({ name: 'user', params: { userId: '123' }})// 带查询参数，变成 /register?plan=privaterouter.push({ path: 'register', query: { plan: 'private' }})const userId = '123'router.push({ name: 'user', params: { userId }}) // -&gt; /user/123router.push({ path: `/user/${userId}` }) // -&gt; /user/123// 这里的 params 不生效router.push({ path: '/user', params: { userId }}) // -&gt; /user 后退或前进 123456789// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 命名路由 12345678910111213const router = new VueRouter({ routes: [ { path: '/user/:userId', name: 'user', component: User } ]})&lt;router-link :to=&quot;{ name: 'user', params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt;router.push({ name: 'user', params: { userId: 123 }}) 命名视图 123456&lt;div&gt; &lt;h1&gt;User Settings&lt;/h1&gt; &lt;NavBar/&gt; &lt;router-view/&gt; &lt;router-view name=&quot;helper&quot;/&gt;&lt;/div&gt; 123456789101112131415{ path: '/settings', // 你也可以在顶级路由就配置命名视图 component: UserSettings, children: [{ path: 'emails', component: UserEmailsSubscriptions }, { path: 'profile', components: { default: UserProfile, helper: UserProfilePreview } }]} 重定向和别名 1234567891011121314151617181920212223242526const router = new VueRouter({ routes: [ { path: '/a', redirect: '/b' } ]})const router = new VueRouter({ routes: [ { path: '/a', redirect: { name: 'foo' }} ]})const router = new VueRouter({ routes: [ { path: '/a', redirect: to =&gt; { // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 }} ]})const router = new VueRouter({ routes: [ { path: '/a', component: A, alias: '/b' } ]}) 路由组件传参 12345678910111213141516171819202122232425262728 const User = { template: '&lt;div&gt;User {{ $route.params.id }}&lt;/div&gt;' } const router = new VueRouter({ routes: [ { path: '/user/:id', component: User } ] }) // 通过 props 解耦 const User = { props: ['id'], template: '&lt;div&gt;User {{ id }}&lt;/div&gt;' } const router = new VueRouter({ routes: [ { path: '/user/:id', component: User, props: true }, // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项： { path: '/user/:id', components: { default: User, sidebar: Sidebar }, props: { default: true, sidebar: false } } ]}) Vue Router 传参params 传值1234567891011121314151617const router = new VueRouter({ routes: [ // 动态路径参数 以冒号开头 { path: '/user/:id', component: User, name:'user',} ]})// 传值this.$router.push({ name:&quot;'user'&quot;,//这个name就是你刚刚配置在router里边的name params:{ userId:&quot;10011&quot; }})// 取值this.$route.params.userId query 传值123456&lt;template&gt; &lt;router-link :to=&quot;{ path: '/log', query: { name1: 'haha', name2: 'enen' } }&quot; &gt; &lt;/router-link&gt;&lt;/tempalte&gt; 1234567891011// 传值this.$router.push({ path:&quot;/user&quot;,//这个path就是你在router/index.js里边配置的路径 query:{ userId:&quot;10011&quot; }})// 取值this.$router.currentRoute.query.userIdthis.$route.query.userId 相关资料 vue Routervue $router 路由传参的4种方法详解√vue router跳转方法√vite —— 一种尤雨溪开发的新的、更快地 web 开发工具vite","link":"/2020/08/04/Blog-about-learning-144/"},{"title":"node 爬虫","text":"Node 爬虫的方式 采用node,js中的 superagent+request + cheerio 使用Nightmare自动化测试工具。 nightmare 小试123456789101112131415161718192021const Nightmare = require(&quot;nightmare&quot;);const nightmare = Nightmare({ show: true }); // show设置为true，可以看到弹出浏览器出来nightmare .goto(&quot;https://www.baidu.com&quot;) // 打开的页面，这里百度举例 .type(&quot;#kw&quot;, &quot;giscafer webgis入门实战&quot;) // 搜索框的 id 输入的文字 .click(&quot;#su&quot;) // 搜索按钮的id .wait(2000) // 等待时间 .evaluate(() =&gt; { let text_list = []; const nums_text = document.querySelectorAll(&quot;.c-container .t a&quot;); // 爬取数据的元素 nums_text.forEach((value) =&gt; { text_list.push(value.textContent); }); return text_list; }) .end() // 结束 .then(console.log) .catch((error) =&gt; { console.error(&quot;Search failed:&quot;, error); }); 相关资料nightmarenode实现爬虫的几种简易方式node实现爬虫的几种简易方式使用 Nightmare 进行浏览器自动化测试awesome-webgis爬虫集合 InfoSpider爬虫集合 awesome-spider","link":"/2020/08/04/Blog-about-learning-138/"},{"title":"VS Code 插件","text":"REST Client发送HTTP请求 CSS Peek显示 CSS 规则 Beautify自定义编码风格 Auto Rename Tag修改标签 Quokka.jsNight Owl漂亮主题 JavaScript (ES6) code snippets代码补全 相关资料高效编码必备的 7 个 VS Code 插件","link":"/2020/10/03/Blog-about-learning-147/"},{"title":"HTML5 Boilerplate 从入门到实践","text":"HTML5 Boilerplate 简介HTML5 Boilerplate是一个专业的前端模板，用于构建快速，健壮和适应性强的Web应用程序或网站。 相关资料HTML5 Boilerplate特性简介及如何使用实例讲解HTML5 Boilerplate - 让页面有个好的开始HTML5 Boilerplate浅析","link":"/2020/10/04/Blog-about-learning-148/"},{"title":"Meteor 从入门到实践","text":"创建 Meteor 应用Chocolatey 安装（windows 安装）以管理员身份运行命令窗口 123456@&quot;%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin&quot;// 检查是否安装成功choco// 成功提示// Chocolatey v0.10.15// Please run 'choco -?' or 'choco &lt;command&gt; -?' for help menu. Meteor 安装1choco install meteor 创建应用1meteor create simple-todos 相关资料Meteor介绍chocolatey 安装步骤包管理工具set-ExecutionPolicy’ 不是内部或外部命令，也不是可运行的程序 或批处理文安装ChocolateyMeteor 中文文档Meteor 教程Chocolatey 安装Meteor教程","link":"/2020/10/04/Blog-about-learning-149/"},{"title":"微前端 从入门到实战","text":"基于微前端的大型中台项目融合方案","link":"/2020/08/04/Blog-about-learning-146/"},{"title":"ES6、ES7、ES8、ES9、ES10 学习笔记","text":"ES6 的开发环境搭建新的声明方式","link":"/2020/01/27/Blog-about-learning-15/"},{"title":"接口管理","text":"RAP：阿里妈妈前端团队出品的开源接口管理工具RAP第二代 YApi：YApi 是一个可本地部署的、打通前后端及QA的、可视化的接口管理平台 swagger：是一个REST APIs文档生成工具","link":"/2020/08/04/Blog-about-learning-145/"},{"title":"Ionic 从入门到实践","text":"Ionic 准备CordovaAngular npm install -g cordova @ionic/cli vscode 扩展Ionic SnippetsAngular Snippets Ionic 命令12345678910111213141516npm install -g @ionic/cliionic start myApp tabscd myAppionic serveionic g page &quot;User Detail&quot;ionic generate component contact/formionic generate directive ripple --skip-importionic generate service api/userionic capacitor add iosionic cordova prepare iosionic capacitor add androidionic cordova prepare android Ionic 目录结构src/|- app/ |- app-routing.module.ts |- app.component.html |- app.component.spec.ts |- app.component.ts |- app.module.tswww/:静态文件，ionic build –prod 生成的单页面静态资源文件|- assets/|- environments/|- theme/|- global.scss|- index.html|- main.ts|- polyfills.ts|- test.ts|- zone-flags.ts app.module.ts12345678910111213141516171819202122232425262728// 根模块import { NgModule } from '@angular/core';// Angula、Ionic的核心文件import { BrowserModule } from '@angular/platform-browser';import { RouteReuseStrategy } from '@angular/router';import { IonicModule, IonicRouteStrategy } from '@ionic/angular';// Ionic 打包成 app 以后配置启动画面以及导航条的服务import { SplashScreen } from '@ionic-native/splash-screen/ngx';import { StatusBar } from '@ionic-native/status-bar/ngx';// 路由配置文件import { AppRoutingModule } from './app-routing.module';// 引入根组件import { AppComponent } from './app.component';@NgModule({ declarations: [AppComponent], // 声明组件 entryComponents: [],// 配置不会在模板中使用的组件 imports: [BrowserModule, IonicModule.forRoot(), AppRoutingModule],// 引入依赖模块 providers: [ // 配置服务 StatusBar, SplashScreen, { provide: RouteReuseStrategy, useClass: IonicRouteStrategy } ], bootstrap: [AppComponent]})export class AppModule {} 路由文件src/|- app/ |- app-routing.module.ts：主路由配置 |- tabs/ |- tabs-routing.module.ts：页面路由配置 Ionic router 跳转及传参12&lt;!-- 声明式导航 --&gt;&lt;ion-button [routerLink]=&quot;['/button']&quot;&gt;Button&lt;/ion-button&gt; 编程式 123456789&lt;!-- 返回按钮 --&gt; &lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-buttons slot=&quot;start&quot;&gt; &lt;ion-back-button&gt;&lt;/ion-back-button&gt; &lt;/ion-buttons&gt; &lt;ion-title&gt;button&lt;/ion-title&gt; &lt;/ion-toolbar&gt; &lt;/ion-header&gt; 自定义模块 ionic generate component contact/formionic g module contact/form 123456789101112131415// form.module.tsimport { NgModule } from '@angular/core';import { CommonModule } from '@angular/common';// 引入 ionic 组件import { IonicModule } from '@ionic/angular';@NgModule({ declarations: [], imports: [ CommonModule, // 注册 ionic 组件 IonicModule ]})export class FormModule { } 12345678910111213141516171819// contact.module.tsimport { NgModule } from &quot;@angular/core&quot;;import { CommonModule } from &quot;@angular/common&quot;;import { FormsModule } from &quot;@angular/forms&quot;;import { IonicModule } from &quot;@ionic/angular&quot;;import { ContactPageRoutingModule } from &quot;./contact-routing.module&quot;;import { ContactPage } from &quot;./contact.page&quot;;// 引入组件import { FormComponent } from &quot;./form/form.component&quot;;@NgModule({ imports: [CommonModule, FormsModule, IonicModule, ContactPageRoutingModule], // 注册组件 declarations: [ContactPage, FormComponent],})export class ContactPageModule {} 1234567891011&lt;!-- contact.page.html --&gt;&lt;ion-header&gt;&lt;ion-toolbar&gt; &lt;!-- 使用组件 --&gt; &lt;ion-title&gt;contact&lt;/ion-title&gt;&lt;/ion-toolbar&gt;&lt;/ion-header&gt;&lt;ion-content&gt; &lt;app-form&gt;&lt;/app-form&gt;&lt;/ion-content&gt; Ionic UI 组件buttonion-router-outlet Toolbarion-toolbar 导航栏ion-header 头部ion-footer 底部ion-title 导航栏标题ion-buttons 导航栏按钮ion-back-button 返回按钮 ion-listion-listion-list-headerion-virtual-scroll Mediaion-avatarion-iconion-imgion-thumbnail 内置颜色 Ionic Vue12345npm install -g @ionic/cli@latestionic start myApp blank --type vueionic serveionic capacitor add // 添加平台cordova-res -skip-config -copy //生成应用图标和启动画面 nrmnrm 管理 npm 源 123cnpm i -g nrmnrm ls // 查看源nrm use taobao // 使用源 路由跳转1234&lt;!-- 声明式导航 --&gt;&lt;ion-button router-link=&quot;/button&quot;&gt;Button&lt;/ion-button&gt;this.$router.push('/non-existing') 组件内置主题颜色：primary、secondary、tertiary、success、warning、danger、dark、medium、light 等 详细参考：theme\\variables ctrl + 鼠标左键点击引入的组件 可查看内部属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127按钮&lt;ion-button color=&quot;primary&quot;&gt;primary&lt;/ion-button&gt;&lt;ion-button expand=&quot;block&quot;&gt;圆角&lt;/ion-button&gt;&lt;ion-button expand=&quot;full&quot;&gt;方角&lt;/ion-button&gt;&lt;ion-button&gt; &lt;ion-icon slot=&quot;start&quot; name=&quot;star&quot;&gt;&lt;/ion-icon&gt; 图标按钮&lt;/ion-button&gt;顶部导航栏&lt;ion-toolbar&gt; &lt;ion-buttons slot=&quot;start&quot;&gt; &lt;ion-back-button&gt;&lt;/ion-back-button&gt; &lt;/ion-buttons&gt; &lt;ion-title&gt;Back Button&lt;/ion-title&gt;&lt;/ion-toolbar&gt;列表&lt;ion-list&gt; &lt;ion-item lines=&quot;full&quot;&gt; &lt;ion-label&gt;Pokémon Yellow&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item detail&gt; &lt;ion-label&gt;Mega Man X&lt;/ion-label&gt; &lt;/ion-item&gt;&lt;/ion-list&gt;列表分组&lt;ion-list&gt; &lt;ion-item-group&gt; &lt;ion-item-divider&gt; &lt;ion-icon slot=&quot;start&quot; :icon=&quot;add&quot;&gt;&lt;/ion-icon&gt; &lt;ion-label&gt;A&lt;/ion-label&gt; &lt;/ion-item-divider&gt; // 头像 &lt;ion-item&gt; &lt;ion-avatar&gt; &lt;img src=&quot;/assets/icon/favicon.png&quot; /&gt; &lt;/ion-avatar&gt; &lt;ion-label&gt; &lt;h2&gt;姓名：&lt;/h2&gt; &lt;p&gt;身份：&lt;/p&gt; &lt;/ion-label&gt; &lt;/ion-item&gt; // 缩略图 &lt;ion-item&gt; &lt;ion-thumbnail slot=&quot;start&quot;&gt; &lt;img src=&quot;/assets/icon/favicon.png&quot; /&gt; &lt;/ion-thumbnail&gt; &lt;ion-label&gt;Argentina&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;/ion-item-group&gt; // 滑动按钮 &lt;ion-item-sliding&gt; &lt;ion-item-options side=&quot;start&quot;&gt; &lt;ion-item-option @click=&quot;favorite(item)&quot;&gt;Favorite&lt;/ion-item-option&gt; &lt;ion-item-option color=&quot;danger&quot; @click=&quot;share(item)&quot;&gt;Share&lt;/ion-item-option&gt; &lt;/ion-item-options&gt; &lt;ion-item&gt; &lt;ion-label&gt;Item Options&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item-options side=&quot;end&quot;&gt; &lt;ion-item-option @click=&quot;unread(item)&quot;&gt;Unread&lt;/ion-item-option&gt; &lt;/ion-item-options&gt; &lt;/ion-item-sliding&gt;&lt;/ion-list&gt;&lt;script&gt; // 图标引入 import {add} from &quot;ionicons/icons&quot;; export default { setup() { return{ add } } }&lt;/script&gt;// 表单&lt;ion-item&gt; &lt;ion-label position=&quot;fixed&quot;&gt;姓名&lt;/ion-label&gt; &lt;ion-input v-model=&quot;userInfo.name&quot; placeholder=&quot;请输入姓名&quot; /&gt;&lt;/ion-item&gt;// 开关&lt;ion-item&gt; &lt;ion-label&gt;Pepperoni&lt;/ion-label&gt; &lt;ion-toggle value=&quot;pepperoni&quot;&gt; &lt;/ion-toggle&gt;&lt;/ion-item&gt;// 单选&lt;ion-list&gt; &lt;ion-radio-group name=&quot;auto&quot; value=&quot;tesla&quot;&gt; &lt;ion-list-header&gt; &lt;ion-label&gt;Auto Manufacturers&lt;/ion-label&gt; &lt;/ion-list-header&gt; &lt;ion-item&gt; &lt;ion-label&gt;Tesla&lt;/ion-label&gt; &lt;ion-radio value=&quot;tesla&quot;&gt;&lt;/ion-radio&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-label&gt;Ford&lt;/ion-label&gt; &lt;ion-radio value=&quot;ford&quot;&gt;&lt;/ion-radio&gt; &lt;/ion-item&gt; &lt;/ion-radio-group&gt;&lt;/ion-list&gt;// 多选&lt;ion-list&gt; &lt;ion-item v-for=&quot;entry in form&quot;&gt; &lt;ion-label&gt;{{entry.val}}&lt;/ion-label&gt; &lt;ion-checkbox slot=&quot;end&quot; @update:modelValue=&quot;entry.isChecked = $event&quot; :modelValue=&quot;entry.isChecked&quot;&gt; &lt;/ion-checkbox&gt; &lt;/ion-item&gt;&lt;/ion-list&gt;// 选择器&lt;ion-item&gt; &lt;ion-label&gt;Gender&lt;/ion-label&gt; &lt;ion-select placeholder=&quot;Select One&quot;&gt; &lt;ion-select-option value=&quot;f&quot;&gt;Female&lt;/ion-select-option&gt; &lt;ion-select-option value=&quot;m&quot;&gt;Male&lt;/ion-select-option&gt; &lt;/ion-select&gt;&lt;/ion-item&gt;// 多行文本框&lt;ion-textarea&gt;&lt;/ion-textarea&gt; 相关资料[视频]ionic4 ionic5视频教程_ionic4.x ionic5.x入门实战教程-2020年6月更新 Ionic SnippetsIonic 文档Web Components","link":"/2020/10/08/Blog-about-learning-150/"},{"title":"","text":"","link":"/2020/10/12/Blog-about-learning-151/"},{"title":"了解技术","text":"ChatUI服务于智能对话领域的设计和开发体系，助力智能对话机器人的搭建 GoEasy快速打造您的web实时通讯体系GoEasy API，让websocket更简单系统提醒、聊天、用户上下线提醒、客户端同步消息必达 傻瓜式集成 高速稳定 安全可靠 相关资料阿里 ChatUI 开源：让对话美而简单GoEasy","link":"/2020/10/13/Blog-about-learning-152/"},{"title":"Hybrid App 从入门到实践","text":"相关资料H5 手机 App 开发入门：概念篇H5 手机 App 开发入门：技术篇浅谈hybrid技术","link":"/2020/10/13/Blog-about-learning-153/"},{"title":"Github 上一些有趣的仓库","text":"awesome各种内容的合集，里面有前端、后端、语言等等，github 上带 awesome 好像都是集合。 相关资料GitHub 上值得收藏的100个精选前端项目！","link":"/2020/10/16/Blog-about-learning-154/"},{"title":"Tensorflow.js 前端应用从入门到实践","text":"Tensorflow.js 实现垃圾分类操作步骤 加载垃圾分类训练数据 定义模型结构：截断模型 + 双层神经网络 训练模型并保存到文件 前置条件 神经网络等预备知识 理解预训练模型的相关知识 相关资料[视频]Tensorflow.js 实现垃圾分类2-2","link":"/2020/11/01/Blog-about-learning-155/"},{"title":"react 生态","text":"UmiJS：插件化的企业级前端应用框架。 next：react ssr框架","link":"/2020/11/08/Blog-about-learning-157/"},{"title":"被遗忘的 DOM","text":"事件流描述的是从页面中接受事件的顺序。 事件捕获流 事件冒泡流 事件冒泡：即事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播至最不具体的那个节点（文档）。事件捕获：不太具体的节点应该更早接受到事件，而最具体的节点最后接受到事件。 事件处理程序 HTML 事件处理程序： button onclick=”showTextModel()” DOM0 级事件处理程序： var btn = document.getElementById(“btn”); btn.onclick = function(){} btn.onclick = null;//删除事件 DOM2 级事件处理程序：addEventListener() 和 removeEventListener。参数：处理事件名、处理事件程序、布尔值。true 事件捕获时触发，false 事件冒泡时触发。 IE 事件处理程序：attachEvent() 添加事件 detachEvent 删除事件 参数：处理史建明、处理事件程序。IE8 以及更早的浏览器版本只支持事件冒泡。 跨浏览器的事件处理程序 1234567891011var eventUtil = { addHandler: function(element, type , handler){ if(element.addEventlistener){ element.addEventlistene(type,handler,false); }else if(element.attachEvent){ element.attachEvent('on'+type,handler); }else{ element['on'+type] = handler } }} 事件对象在触发 DOM 上的事件时都会产生一个对象 事件对象 eventDOM 中的事件对象type 属性：用于获取事件类型target 属性：用于获取事件目标offsetWidth 属性：水平方向 width + 左右padding + 左右border-widthclientWidth 属性：水平方向 width + 左右paddingstopPropagation()方法 用于阻止事件冒泡preventDefault()方法 阻止事件的默认行为 IE 中的事件对象type 属性：用于获取事件类型srcElement属性：用于获取事件目标window.eventcancelBubble 属性 用于阻止事件冒泡 true 阻止事件冒泡 false 不阻止事件冒泡returnValue 属性 用于阻止事件的默认行为 true 阻止事件默认行为 false 不阻止事件默认行为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var eventUtil={ // 添加句柄 addHandler:function(element,type,handler){ if(element.addEventListener){ element.addEventListener(type,handler,false); }else if(element.attachEvent){ element.attachEvent('on'+type,handler); }else{ element['on'+type]=handler; } }, // 删除句柄 removeHandler:function(element,type,handler){ if(element.removeEventListener){ element.removeEventListener(type,handler,false); }else if(element.detachEvent){ element.detachEvent('on'+type,handler); }else{ element['on'+type]=null; } }, getEvent:function(event){ return event?event:window.event; }, getType:function(event){ return event.type; }, getElement:function(event){ return event.target || event.srcElement; }, preventDefault:function(event){ if(event.preventDefault){ event.preventDefault(); }else{ event.returnValue=false; } }, stopPropagation:function(event){ if(event.stopPropagation){ event.stopPropagation(); }else{ event.cancelBubble=true; } }} 事件类型鼠标事件 click 点击 dblclick 双击 mouseover、mouseout 鼠标移入、移除 mouseenter、mouseleave 鼠标移入、移除 键盘事件 keyDown 按下键盘上任意键时触发 keyUp 释放键盘上的键时触发 keyPress 按下键盘上字符键时触发 节点节点的类型 文档片段节点 12345var frag = document.createDocumentFragment();var li = document.createElement(&quot;li&quot;);li.innerHTML = &quot;List item &quot;;frag.appendChild(li);document.getElementById(&quot;list-node&quot;).appendChild(frag) 判断节点类型 12345678var containerElement = document.getElementById(&quot;container&quot;);containerElement.nodeType == Node.ELEMENT_NODEcontainerElement.nodeType == 1containerElement.nodeName == 'div'containerElement.nodeValue == 'Falldown'containerElement.attributes[0]containerElement.childNodes[0]document.doctype 元素节点的判断 isElement() 判定是否为元素节点 1234567891011121314151617181920var testDiv = document.createElement(&quot;div&quot;);var isElement = function (obj) {if (obj &amp;&amp; obj.nodeType === 1) { //先过滤最简单的 if (window.Node &amp;&amp; obj instanceof Node) { //如果是IE9,则判定其是否Node的实例 return true; //由于obj可能是来自另一个文档对象，因此不能轻易返回false } try { //最后以这种效率非常差但肯定可行的方案进行判定 testDiv.appendChild(obj); testDiv.removeChild(obj); } catch (e) { return false; } return true; } return false;};isElement(document.getElementByID(&quot;test&quot;)); isHTML 判断是不是 HTML 节点 1234567891011121314151617181920212223var testDiv = document.createElement('div');var isElement = function (obj) {if (obj &amp;&amp; obj.nodeType === 1) {//先过滤最简单的 if( window.Node &amp;&amp; (obj instanceof Node )){ //如果是IE9,则判定其是否Node的实例 return true; //由于obj可能是来自另一个文档对象，因此不能轻易返回false } try {//最后以这种效率非常差但肯定可行的方案进行判定 testDiv.appendChild(obj); testDiv.removeChild(obj); } catch (e) { return false; } return true;} return false;}var isHTMLElement(el){ if(isElement){ return isXML(el.ownerDocument); } return false;} isXML 1234567891011121314151617181920212223242526272829303132333435//Sizzle, jQuery自带的选择器引擎var isXML = function (elem) {var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement; return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;};console.log(isXML(document.getElementById(&quot;test&quot;)));//但这样不严谨，因为XML的根节点，也可能是HTML标签，比如这样创建一个XML文档try { var doc = document.implementation.createDocument(null, &quot;HTML&quot;, null); console.log(doc.documentElement); console.log(isXML(doc));} catch (e) { console.log(&quot;不支持creatDocument方法&quot;);}//我们看看mootools的slick选择器引擎的源码：var isXML = function (document) {return ( !!document.xmlVersion || !!document.xml || toString.call(document) == &quot;[object XMLDocument]&quot; || (document.nodeType == 9 &amp;&amp; document.documentElement.nodeName != &quot;HTML&quot;));};//精简版var isXML = window.HTMLDocument? function (doc) { return !(doc instanceof HTMLDocument);} : function (doc) { return &quot;selectNodes&quot; in doc;};var isXML = function (doc) { // 判断返回大小写区分 xml 和 html return (doc.createElement(&quot;p&quot;).nodeName !== doc.createElement(&quot;P&quot;).nodeName);}; contains 判断是否是其子节点 12345678910111213141516171819 var pNode = document.getElementById(&quot;p-node&quot;); var cNode = document.getElementById(&quot;c-node&quot;).childNodes[0]; alert(pNode.contains(cNode)); function fixContains(a, b) { try { while ((b = b.parentNode)){ if (b === a){ return true; } } return false; } catch (e) { return false; }}var pNode = document.getElementById(&quot;p-node&quot;);var cNode = document.getElementById(&quot;c-node&quot;).childNodes[0];alert(fixContains(pNode, cNode)); 浏览器渲染引擎的基本渲染流程解析 HTML 构建 DOM 树（构建 DOM 节点） -&gt; 构建渲染树（解析样式信息） -&gt; 布局渲染树（布局 DOM 节点） -&gt; 绘制渲染树（绘制 DOM 节点） domReady1window.onload domReady 实现策略在页面的 DOM 树创建完成后（也就是 HTML 解析第一步完成）即触发，而无需等待其他资源的加载。即 DOMReady 实现策略：1、支持 DOMContentLoaded 事件的，就使用 DOMContentLoaded 事件2、不支持的，就用来自 Diego Perini 发现的著名 Hack 兼容。兼容原理大概就是，通过 IE 中的 document.docuemntElement.doScroll(‘left’) 来判断 DOM 树是否创建完毕。 实现 domReady1234567891011121314151617181920212223242526272829303132333435363738394041424344function myReady(fn){ //对于现代浏览器，对DOMContentLoaded事件的处理采用标准的事件绑定方式 if ( document.addEventListener ) { document.addEventListener(&quot;DOMContentLoaded&quot;, fn, false); } else { IEContentLoaded(fn); } //IE模拟DOMContentLoaded function IEContentLoaded (fn) { var d = window.document; var done = false; //只执行一次用户的回调函数init() var init = function () { if (!done) { done = true; fn(); } }; (function () { try { // DOM树未创建完之前调用doScroll会抛出错误 d.documentElement.doScroll('left'); } catch (e) { //延迟再试一次~ setTimeout(arguments.callee, 50); return; } // 没有错误就表示DOM树创建完毕，然后立马执行用户回调 init(); })(); //监听document的加载状态 d.onreadystatechange = function() { // 如果用户是在domReady之后绑定的函数，就立马执行 if (d.readyState == 'complete') { d.onreadystatechange = null; init(); } } }} DOM 节点继承层次 HTML 嵌套规则HTML存在许多种类型的标签，有的标签下面只允许特定的标签存在，这就叫做 HTML 嵌套规则。 不按 HTML 嵌套规则写，浏览器就不会正确解析，会将不符合嵌套规则的节点放到目标节点的下面，或者变成纯文本。 块状元素：一般是其他元素的容器，可容纳内联元素和其他块状元素，块状元素排斥其他元素与其位于同一行，宽读高度起作用。常见块状元素为 div 和 p。 内联元素：内联元素只能容纳文本或者其他内联元素，它允许其他内联元素与其位于同一行，但宽度高度不起作用。常见内联元素为 a。 块状元素与内联元素嵌套规则 1、块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其他内联元素。2、块元素不能放在 p 元素内。3、有几个特殊的块级元素只能包含内联元素，不能包含块级元素。：h1 ~ h64、块级元素与块级元素并列、内联元素与内联元素并且 相关资料[视频]DOM事件探秘√[视频]DOM探索之基础详解篇√ 盘点HTML字符串转DOM的各种方法及细节 javascript中的offsetWidth、clientWidth、innerWidth及相关属性方法前端必读：浏览器内部工作原理[转] 主流JS框架中DOMReady事件的实现如何检查JavaScript对象是否为DOM对象？ 相关代码DOM","link":"/2020/11/02/Blog-about-learning-156/"},{"title":"ES6的开发环境搭建","text":"使用Babel把ES6编译成ES5 运行以下命令安装软件包 12npm install --save-dev @babel/core @babel/cli @babel/preset-envnpm install --save @babel/polyfill 在项目根目录中创建.babelrc文件 12345678910111213141516{ &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;targets&quot;: { &quot;edge&quot;: &quot;17&quot;, &quot;firefox&quot;: &quot;60&quot;, &quot;chrome&quot;: &quot;67&quot;, &quot;safari&quot;: &quot;11.1&quot;, }, &quot;useBuiltIns&quot;: &quot;usage&quot;, } ] ]} 运行下面命令，将src目录中的所有代码编译到distnpx babel src -d dist 以上是我对下列视频及文章的归纳和总结。ES6 免费视频教程 参考资料:ES6的开发环境搭建 相关代码仓库:ES6","link":"/2020/01/27/Blog-about-learning-16/"},{"title":"源码阅读","text":"相关资料阅读前端项目源码的正确姿势√作为一名前端开发人员，有哪些值得一读的js代码？如何阅读大型前端开源项目的源码经典万字长文前端面试题集锦+源码阅读","link":"/2020/12/01/Blog-about-learning-159/"},{"title":"变量的解构赋值","text":"解构赋值语法是一种 JavaScript 表达式。通过解构赋值，可以将属性值从对象/数组中取出，赋值给其他变量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179// 解构数组var foo = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];var [one, two, three] = foo;console.log(one); //'one'console.log(two); //'two'console.log(three); // 'three'var a, b;[a, b] = [1, 2];console.log(a); // 1console.log(b); // 2// 默认值var a, b;[a = 5, b = 7] = [1];console.log(a); // 1console.log(b); // 7// 交换变量var a = 1;var b = 3;[a, b] = [b, a];console.log(a); // 3console.log(b); // 1// 解析一个从函数返回的数组function f() { return [1, 2];}var a, b;[a, b] = f();console.log(a); // 1console.log(b); // 2// 忽略某些值function f() { return [1, 2, 3];}var [a, , b] = f();console.log(a); // 1console.log(b); // 3// 将剩余数组赋值给一个变量var [a, ...b] = [1, 2, 3];console.log(a); // 1console.log(b); // [2,3]// 用正则表达式匹配提取值function parseProtocol(url) { var parsedURL = /^(\\w+)\\:\\/\\/([^\\/]+)\\/(.*)$/.exec(url); if (!parsedURL) { return false; } console.log(parsedURL); // [&quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;, &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;en-US/Web/JavaScript&quot;] var [, protocol, fullhost, fullpath] = parsedURL; return fullhost;}console.log( parseProtocol(&quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;); // &quot;https&quot;);// 解构对象var o = {p:42,q:true};var {p,q} = o;console.log(p); // 42console.log(q); // true// 无声明赋值var a,b;({a,b} = {a : 1,b : 2})// 给新的变量名赋值var o = {p:42,q:true};var {p:foo,q:bar} = o;console.log(foo); // 42console.log(bar); // true// 默认值var {a = 10,b = 5} = {a : 3};console.log(a);console.log(b);// 解构嵌套对象和数组const metadata = { title: 'Scratchpad', translations: [ { locale: 'de', localization_tags: [], last_edit: '2014-04-14T08:43:37', url: '/de/docs/Tools/Scratchpad', title: 'JavaScript-Umgebung' } ], url: '/en-US/docs/Tools/Scratchpad'};let { title: englishTitle, // rename translations: [ { title: localeTitle, // rename }, ],} = metadata;console.log(englishTitle); // &quot;Scratchpad&quot;console.log(localeTitle); // &quot;JavaScript-Umgebung&quot;// For of 迭代和解构var people = [ { name: 'Mike Smith', family: { mother: 'Jane Smith', father: 'Harry Smith', sister: 'Samantha Smith' }, age: 35 }, { name: 'Tom Jones', family: { mother: 'Norah Jones', father: 'Richard Jones', brother: 'Howard Jones' }, age: 25 }];for (var {name: n, family: {father: f}} of people) { console.log('Name: ' + n + ', Father: ' + f); // &quot;Name: Mike Smith, Father: Harry Smith&quot; // &quot;Name: Tom Jones, Father: Richard Jones&quot;}// 从作为函数实参的对象中提取数据function userId({id}) { return id;}function whois({displayName: displayName, fullName: {firstName: name}}){ console.log(displayName + &quot; is &quot; + name);}var user = { id: 42, displayName: &quot;jdoe&quot;, fullName: { firstName: &quot;John&quot;, lastName: &quot;Doe&quot; }};console.log(&quot;userId: &quot; + userId(user)); // &quot;userId: 42&quot;whois(user); // &quot;jdoe is John&quot; 以上是我对下列视频及文章的归纳和总结。ES6 免费视频教程 参考资料:MDN 解构赋值ECMAScript 6 入门-变量解构赋值 相关代码仓库:ES6","link":"/2020/01/28/Blog-about-learning-18/"},{"title":"Mysql 从入门到实践开发","text":"存储数据的方法 内存：速度快；但容量有限、非永久存储。 自定义结构的文件：使用简单直接，但不便于大量数据查找 Excel/Access等格式化文件：使用广泛；灵活性不足 专用文件服务器：网络存储/云存储，可靠性高；操作复杂 数据库服务器：存取效率高，尤其合适海量数据；操作复杂 常见的关系型数据库 SQList微型数据库，常用于移动设备 MySQL开发中小型数据库，可用于各种操作系统 MariaDB PostagreSQL开源中小型数据库 OracleOracle公司开发的中大型数据库，可用于各种操作系统 DB2IBM公司开发的中大型数据库，常于IBM服务器搭配 关系型数据库结构Server = &gt; Database - &gt; table -&gt; row - &gt; column 数据库的好处 实现数据持久化 使用完整的管理系统统一管理，易于查询 数据库软件的种类 关系型数据库（relational DB） 非关系型数据库 数据库的相关概念DB：数据库（database）：存储数据的“仓库”。它保存了一系列有组织的数据。DBMS：数据库管理系统（Database Management System）。数据库是通过 DBMS 创建和操作的容器SQL：结构化查询语言。（Structure Query Language）：专门用来数据库通信的语言。 SQL 的优点：1、通用性2、简单易学 数据库的特点1、将数据放到表中，表再放到库中。2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。3、表由列组成，也称为字段。所有表都是一个或多个列组成的。4、表中的数据是按行存储的。 MySQL 产品的特点优点： 成本低；开源，免费。 性能高：执行很快 简单：容易安装和使用 DBMS 分为两类： 基于共享文件系统的 DBMS（Access） 基于客户机 —— 服务器的 DBMS (MySQL、Oracle、SqlServer) MySQL 卸载卸载程序 MySQL ServerMySQL 的安装路径删掉 MySQL 文件夹ProgramData下的 MySQL 删掉运行 regedit 打开注册表，清理注册表 MySQL 安装经典安装：服务端外加自带客户端自定义安装完全安装：所有的 选择 自定义安装 配置 C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin\\MySQLInstanceConfig.exe 开发选择第一个就行，越往下占用内存越多 实际应用过程中需要改端口防止攻击，学习不用改就行。 字符集选最后一个，然后选择 utf8。 勾选添加至环境变量，启动命名。 设置 root 密码。 配置文件：C:\\Program Files\\MySQL\\MySQL Server 5.5\\my.ini MySQL 服务第一种启动方式 第二种启动方式：管理员运行命令行停止：net stop mysql启动：net start mysql MySQL 的登录和退出 第一中点击 MySQL 5.5 command line client 进入输入 root 密码。 第二种命令行mysql.exe -h服务器地址 -P服务器端口 -u登陆用户名 -p登陆密码进入客服端 mysql.exe -uroot -p 退出 quit; 如果登录不了检查环境变量并配置。 Mysqld.exedemon：守护者、守护程序、服务器程序 mysql管理命令 MySQL管理命令 SQL管理命令 MySQL 的常见命令quit; 退出服务器的连接show databases; 显示数据库use 数据库名称; 进入/切换数据库show tables; 显示表desc 表名; 描述一下指定表的列（描述表头）show tables from mysql; 查看其他库的所有表select databases(); 查看当前所在库create table 表名( 创建表 Uid INT, name VARCHAR(64), Age INT, Phone VARCHAR(64));select verslon() 登录到 MySQL 查看服务器版本mysql –version 未登录 MySQL 查看服务器版本mysql -V MySQL 的语法规范（1）所有的SQL语句必须以 ; 分号结尾。（2）SQL语句不区分大小写。习惯上，系统预定义的关键字都大写，非关节字都小写。（3）SQL中可以加注释 单行注释（#…）和多行注释（/……/）。（4）SQL语法错误，后续所有的语句不会再执行。 图形化用户界面客户端DQL 语言SELECT ename FROM emp;select ename,birthday FROM emp;SELECT * FROM emp; DML 语言DDL 语言TCL 语言#丢掉数据库jd，如果存在的话 exists 存在DROP DATABASE IF EXISTS jd;#新建一个数据库 ：jd CREATE DATABASE jd; #进入指定数据库 USE jd; #创建一个员工信息表的表emp INSERT INTO emp VALUES (1,'abc',50,2018:10:28); 解决MySQL存储中文乱码 sql脚本文件另存为的编码 客户端链接服务器使用的编码 服务器端数据库存储数据使用的编码 解决方法：保持编码统一 SET NAMES UTF8; CREATE DATABASE jd CHARSET=UTF8; 常用的SQL语句 （1）增：INSERT INTO 表 VALUES(值，值，……) （2）删：DELETE FROM emp WHERE lid=10； （3）改：UPDATE 表 SET 列=值，列=值 WHERE lid=9; （4）查：SELECT * FROM emp; MySQL中的列类型 （1）数值类型 —— 可用，可不用引号括起来 1汉字=2字节 1字节（Byte）= 8 字位 = 8个二进制数 1字位（bit）= 1个二进制数 1b = 8b 1KB = 1024 B 1MB = 1024 kB 1GB = 1024 MB TINYINT占1个字符8个二进制数 +-11 11 11 1 转10进制十进制是127所以范围-128到127 1位存正负号 FLOAT (M,D) 计算时可能产生四舍五入 DOUBLE(M,D) 计算时可能产生四舍五入 BOOL等价于TINYINT 布尔 取值为 TRUE（1）/FALSE（2） 注意：MySQL没有真正意义上的布尔类型 TINYINT （2）日期时间类型 —— 必须用引号括起来 （3）字符串类型 —— 必须用引号括起来 CHAR ：比VARCHAR操作速度更块 VARCHAR ：比 CHAR更节约空间 MySQL中的列约束 （1）主键约束 —— PRIMARY KEY 不能重复、不能有出现NULL值，排序，只有一个主键 （2）非空约束 —— NOT NULL 不能出现NULL （3）唯一约束 —— UNIQUE 不能出现重复的值，但可以出现 NULL，且允许多个NULL，（两个NULL值是不等的） （4）检查约束 —— CHECK 检查新插入的数据是否满足指定条件 MySQL不支持。 （5）默认值约束 —— DEFAULT Student（sid INT,set CHAR(1) DEFAULT ‘男’）； （1）INSERT INTO student VALUES(10 DEFAULT); （2）INSERT INTO student(sid) VALUES(20); （6）外键约束 —— FOREIGN KEY…… REFERENCES 自增列 AUTO_INCREMENT 只能用于主键整形 允许手动赋值 项目中如何存储日期时间数据 存储的是距离计算机元年的毫秒数，使用BIGINT类型。 给列取别名 select ename AS 姓名,salary AS 工资 from emp; AS 关键字可以省略 select ename 姓名,salary 工资 from emp; 只显示不同的值/合并相同的项 select distinct sex from emp; 查询时执行运算符 select salary*12 from emp; 查询的结果排序 asc -&gt; ascend 升序 desc -&gt; descend 降序 默认asc order by 可以按照 数值、日期、字符串（字符的编码）来排序 select * from emp order by salary asc; 条件查询 sql语句中支持的比较运算符：= 、!=、 &gt; 、&lt;、 &gt;=、 &lt;= select * from emp where eid=5; null不能和任何值进行等于/不等于判定，包括null自己。可以使用is null 和 is not null and (并且) or(或者) between… and… &gt;= 第1个值 &lt;= 第2个值 not between… and… 模糊条件查询 示例：查询出姓名中含有字母e的员工信息 SELECT * FROM emp WHERE ename LIKE '%e%'; 练习：查询出姓名以e结尾的员工信息 SELECT * FROM emp WHERE ename LIKE '%e'; 练习：查询出姓名中倒数第2个字符为e的员工信息 SELECT * FROM emp WHERE ename LIKE '%e_'; 通配符 描述 % 替代一个或多个字符 _ 仅代替一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或者 不在字符列中的任何单一字符 [!charlist] 分页查询 SELECT * FROM emp LIMIT start,count; start 开始的值 count 查询的数量 综合 SELECT * FROM emp WHERE ... ORDER BY... LIMIT… 聚合查询/分组查询 聚合函数 count() /sum()/avg()/max()/min() 查询所有员工的数量 select count(eid) from emp; select count(*) from emp; //推荐写法 所有员工的工资总和 select sum(salary) from emp; 所有员工的平均工资 select avg(salary) from emp; 查询出工资最高的员工工资最高的是多少 select max(salary) from emp; 查询出工资最高的员工工资最低的是多少 select min(salary) from emp; 分组查询 查询出每个部门的员工数量是多少 select deptId,count(*) from emp group by deptld; year(…)获取日期中的年份 month(…)获取日期中的月份 day(…)获取日期中的日 查询出1991年出生员工的所有信息 select * from emp where year(birthday)=1991; 多表查询 select ename,dname from emp,dept where deptld=did; 内联表 inner join…on.. select ename,dname from emp inner join dept on deptld=did; outer可以省略 左外链接 left outer join…on.. Select ename,dname from emp left outer join dept on deptld=did; 右外链接 left outer join…on.. Select ename,dname from emp right outer join dept on deptld=did; 全连接full join 显示左侧和右侧所有记录——mysql不支持 合并 union 合并相同的项 union all 不合并相同项（select ename from emp_us）union (select ename from emp_cn) 相关资料[视频]MySQL_基础+高级篇- 数据库 -sql -mysql教程_mysql视频_mysql入门_尚硅谷P21navicat 用户指南","link":"/2020/11/11/Blog-about-learning-158/"},{"title":"CSS 单位","text":"em 根据父元素的字体大小变化。 12345678910111213&lt;style&gt; body{ font-size: 14px; } div{ font-size: 1.2em; }&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;test&quot;&gt; Test &lt;/div&gt;&lt;/body&gt; rem 根据根元素的字体大小变化。 12345678&lt;style&gt; body{ font-size: 14px; } div{ font-size: 1.2rem; }&lt;/style&gt; vw 显示窗口的宽度vh 显示窗口的高度vmin 和 vmax 宽度和高度的最大值或最小值有关（如果宽度为1100px高度为700px 那么 1vmin 是 7px，1vmax 是 11px 反之亦然。） 123456&lt;style&gt; body{ width: 100vw; height: 100vh; }&lt;/style&gt; ex和ch单位 这两个单位只也依赖于font-family，因为它们被定为基于特殊字体的法案。 相关资料CSS的一些单位，如rem、px、em、vw、vh、vm√七个你可能不了解的CSS单位 √","link":"/2020/08/04/Blog-about-learning-2/"},{"title":"Gulp 从入门到实践开发","text":"Gulp 特点任务化基于流 Gulp 有自己的内存 livestyle针对样式前端实时可视化编辑 操作步骤 安装浏览器的插件-livestyle，开启 livestyle 安装编辑器的插件 Sublime 安装 livestyle 通过 http-server 启动页面 livereload支持文件修改实施展示 安装浏览器的插件-livereload，开启 livereload 安装 livereload npm i -g livereload livereload 启动服务 livereload 结合 Gulp1234567891011// gulpfile.jsvar gulp = require(&quot;gulp&quot;);var livereload = require(&quot;gulp-livereload&quot;);gulp.task('watch',function(){ // 启动 livereload 监听 livereload.listen(); gulp.watch('./*.html',function(file){ console.log(file) gulp.src(file.path).pipe(livereload) })}) Browser-SyncBrowser-Sync 本质是启动代理服务器，代理服务器监听文件变化，通过 TCP 长连接，仅仅对变化的文件进行实时的同步livereload 本质是 F5 的操作 安装 browser-sync npm install -g browser-sync 启动 browser-sync browser-sync start –server –files “**” Browser-Sync 结合 Gulp12345678910111213141516171819// gulpfile.jsvar gulp = require(&quot;gulp&quot;);var browserSync = require('browser-sync').create();// 静态服务器gulp.task('browser-sync', function() { browserSync.init({ server: { baseDir: &quot;./&quot; } });});// 代理gulp.task('browser-sync', function() { browserSync.init({ proxy: &quot;你的域名或IP&quot; });}); 方案名称 安装和配置 使用限制 最佳应用场景 其他附加功能 liveStyle 浏览器插件、编辑器插件 仅限于样式文件 开发中针对样式的微调和重样式的前端项目 无 liveReload 浏览器插件、编辑器插件 任何文件，单向修改 简单的 web 项目 gulp、grunt支持 BrowserSync node.js插件 任何文件，单向修改 所有业务场景优先考虑，特别是响应式 web 开发必选 gulp、grunt 支持、网络设置、交互同步等 相关资料[视频]前端实时可视化开发工具体验√[视频]尚硅谷前端Gulp教程，自动化构建工具gulpnpm在项目目录安装插件需要使用sudo√gulp-livereloadBrowsersync中文官网","link":"/2020/03/21/Blog-about-learning-20/"},{"title":"新的声明方式","text":"声明方式var 声明语句声明一个变量，并可选地将其初始化为一个值。 语法： 1var varname1 = [= value1][, varname2][= value2]...[, varnameN][=valueN]; varname变量名。变量名可以定义为任何合法标识符。valueN变量的初始化值。默认值是 undefined。 描述：变量声明，无论发生在何处，都在执行任何代码之前进行处理。用var声明的变量的作用域是它当前的执行上下文。重新声明一个 JavaScript 变量，它将不会丢失其值。将赋值给未声明变量的值在执行赋值时将其隐式地创建为全局变量（它将成为全局对象的属性）。 声明和未声明变量之间的差异是： 声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的。 123456789function x(){ y = 1; // 在严格模式（strict mode）下会抛出 ReferenceError 异常 var z = 2;}x();console.log(y); // 打印 “1”console.log(z); // 抛出 ReferenceError: z 未在 x 外部声明 声明变量在任何代码执行前创建，而非声明变量只有在执行赋值操作的时候才会被创建。 1234console.log(y);y = 1; console.log(y);// 打印 Error: y is not defined 123console.log(y); // undefined 变量的初始化值。默认值是 undefined。var y = 1; console.log(y); // 1 声明变量是它所在上下文环境的不可配置属性，非声明变量是可配置的（如非声明变量可以被删除）。 12345678var a = 1;b = 2;delete this.a; // 在严格模式（strict mode）下抛出TypeError，其他情况下执行失败并无任何提示。delete this.b;console.log(a, b); // 抛出ReferenceError。// 'b'属性已经被删除。 由于这三个差异，未能声明变量将很可能导致意想不到的结果。因此，建议始终声明变量，无论它们是在函数还是全局作用域内。 而且，在 ECMAScript 5 严格模式下，分配给未声明的变量会引发错误。 变量提升由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。 123456bla = 2;var bla;// 可以隐式地（implicitly）将以上代码理解为：var bla;bla = 2; 因此，建议始终在作用域顶部声明变量（全局代码的顶部和函数代码的顶部），这可以清楚知道哪些变量是函数作用域（本地），哪些变量在作用域链上解决。重要的是，提升将影响变量声明，而不会影响其值的初始化。当到达赋值语句时，该值将确实被分配： 12345678910111213function do_something() { console.log(bar); // undefined var bar = 111; console.log(bar); // 111}// is implicitly understood as: function do_something() { var bar; console.log(bar); // undefined bar = 111; console.log(bar); // 111} 声明并初始化两个变量： 1var a = 0, b = 0; 给两个变量赋值成字符串值： 123456789var a = &quot;A&quot;;var b = a;// 等效于：var a, b = a = &quot;A&quot;;// 留意顺序var x = y, y = 'A';console.log(x + y); // undefinedA 多个变量的初始化 12345678910var x = 0;function f(){ var x = y = 1; // x在函数内部声明，y不是！}f();console.log(x, y); // 0, 1// x 是全局变量。// y 是隐式声明的全局变量。 隐式全局变量和外部函数作用域 12345678910111213141516171819202122var x = 0; // x是全局变量，并且赋值为0。console.log(typeof z); // undefined，因为z还不存在。function a() { // 当a被调用时， var y = 2; // y被声明成函数a作用域的变量，然后赋值成2。 console.log(x, y); // 0 2 function b() { // 当b被调用时， x = 3; // 全局变量x被赋值为3，不生成全局变量。 y = 4; // 已存在的外部函数的y变量被赋值为4，不生成新的全局变量。 z = 5; // 创建新的全局变量z，并且给z赋值为5。 } // (在严格模式下（strict mode）抛出ReferenceError) b(); // 调用b时创建了全局变量z。 console.log(x, y, z); // 3 4 5}a(); // 调用a时同时调用了b。console.log(x, z); // 3 5console.log(typeof y); // undefined，因为y是a函数的本地（local）变量。 let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。 语法： 1let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]]; var1, var2, …, varN变量名。必须是合法的标识符。value1, value2, …, valueN变量的初始值。可以是任意合法的表达式。 描述：let 允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与 var 关键字不同的是，var 声明的变量只能是全局或者整个函数块的。 var 和 let 的不同之处在于后者是在编译时才初始化。 就像const 一样，let不会在全局声明时（在最顶部的范围）创建window 对象的属性。 作用域规则let声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于var声明的变量的作用域是整个封闭函数。 1234567891011121314151617function varTest() { var x = 1; { var x = 2; // 同样的变量! console.log(x); // 2 } console.log(x); // 2}function letTest() { let x = 1; { let x = 2; // 不同的变量 console.log(x); // 2 } console.log(x); // 1} 在函数或代码顶部，let 不会在全局对象里新建一个属性。var声明会给全局对象新增属性。 1234var x = 'global';let y = 'global';console.log(this.x); // 'global'console.log(this.y); // 'undefined' 模仿私有成员在处理构造函数的时候，可以通过 let 声明而不是闭包来创建一个或多个私有成员。 123456789101112131415161718192021222324252627282930313233343536var Thing;{ let privateScope = new WeakMap(); let counter = 0; Thing = function() { this.someProperty = 'foo'; privateScope.set(this, { hidden: ++counter, }); }; Thing.prototype.showPublic = function() { return this.someProperty; }; Thing.prototype.showPrivate = function() { return privateScope.get(this).hidden; };}console.log(typeof privateScope);// &quot;undefined&quot;var thing = new Thing();console.log(thing);// Thing {someProperty: &quot;foo&quot;}thing.showPublic();// &quot;foo&quot;thing.showPrivate();// 1 可以使用var创建和闭包具有相同隐私模式的局部变量，但是它们需要函数作用域（通常是模块模式中的IIFE），而不仅仅是上面示例中的块作用域。 重复声明在同一个函数或块作用域中重复声明同一个变量会引起SyntaxError。 123456789101112131415if (x) { let foo; let foo; // SyntaxError thrown.}let x = 1;switch(x) { case 0: let foo; break; case 1: let foo; // SyntaxError for redeclaration. break;} 然而，需要特别指出的是，一个嵌套在 case 子句中的块会创建一个新的块作用域的词法环境，就不会产生上诉重复声明的错误。 1234567891011let x = 1;switch(x) { case 0: { let foo; break; } case 1: { let foo; break; }} 暂存死区与通过 var 声明的有初始化值 undefined 的变量不同，通过 let 声明的变量直到它们的定义被执行时才初始化。在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。 123456function do_something() { console.log(bar); // undefined console.log(foo); // ReferenceError var bar = 1; let foo = 2;} 暂存死区与 typeof与通过var声明的变量, 有初始化值 undefined和只是未声明的变量不同的是，如果使用typeof检测在暂存死区中的变量, 会抛出ReferenceError异常: 123456// prints out 'undefined'console.log(typeof undeclaredVariable);// results in a 'ReferenceError'console.log(typeof i);let i = 10; const常量是块级作用域，很像使用 let 语句定义的变量。常量的值不能通过重新赋值来改变，并且不能重新声明。 语法:const name1 = value1 [, name2 = value2 [, … [, nameN = valueN]]];nameN常量名称，可以是任意合法的标识符。valueN常量值，可以是任意合法的表达式。 描述:此声明创建一个常量，其作用域可以是全局或本地声明的块。 与var变量不同，全局常量不会变为窗口对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。 示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 注意: 常量在声明的时候可以使用大小写，但通常情况下全部用大写字母。 // 定义常量MY_FAV并赋值7const MY_FAV = 7;// 报错MY_FAV = 20;// 输出 7console.log(&quot;my favorite number is: &quot; + MY_FAV);// 尝试重新声明会报错 const MY_FAV = 20;// MY_FAV 保留给上面的常量，这个操作会失败var MY_FAV = 20; // 也会报错let MY_FAV = 20;// 注意块范围的性质很重要if (MY_FAV === 7) { // 没问题，并且创建了一个块作用域变量 MY_FAV // (works equally well with let to declare a block scoped non const variable) let MY_FAV = 20; // MY_FAV 现在为 20 console.log('my favorite number is ' + MY_FAV); // 这被提升到全局上下文并引发错误 var MY_FAV = 20;}// MY_FAV 依旧为7console.log(&quot;my favorite number is &quot; + MY_FAV);// 常量要求一个初始值const FOO; // SyntaxError: missing = in const declaration// 常量可以定义成对象const MY_OBJECT = {&quot;key&quot;: &quot;value&quot;};// 重写对象和上面一样会失败MY_OBJECT = {&quot;OTHER_KEY&quot;: &quot;value&quot;};// 对象属性并不在保护的范围内，下面这个声明会成功执行MY_OBJECT.key = &quot;otherValue&quot;;// 也可以用来定义数组const MY_ARRAY = [];// It's possible to push items into the array// 可以向数组填充数据MY_ARRAY.push('A'); // [&quot;A&quot;]// 但是，将一个新数组赋给变量会引发错误MY_ARRAY = ['B'] 总结归纳使用var声明建议建议始终在全部代码的顶部和函数代码的顶部声明变量. 使用var需要注意：声明提前/变量提升。（变量声明在任意代码执行之前处理）未声明的变量是全局变量，未声明的变量赋值才会被创建。全局声明时，创建 window 对象的属性 12var a;console.log(typeof a ,typeof b); // undefined undefined 使用let需要注意：同一个函数或块作用域不能重复声明。暂存死区（通过 let 声明的变量直到它们的定义被执行时才初始化）。不会创建window 对象的属性 123console.log(typeof undeclaredVariable); // undefinedconsole.log(typeof i); // undefinedlet i = 10; 使用const建议：建议变量名全部用大写字母。例如MY_FAV 使用const需要注意：同一个函数或块作用域不能重复声明。不能重新赋值。声明同时指定值，值只读引用，值是对象时可改变。 以上是我对下列视频及文章的归纳和总结。ES6 免费视频教程 参考资料:MDN varMDN letMDN varECMAScript 6 入门-let和const 命令ES6的开发环境搭建 相关代码仓库:ES6","link":"/2020/01/28/Blog-about-learning-17/"},{"title":"Taro 从入门到实战","text":"配置文件更改端口号和域名： config/index.js 12h5: { devServer:{ host: 'localhost', port: 8888}, 更改 appid:project.config.json（小程序独有的配置文件） 1&quot;appid&quot;: &quot;touristappid&quot;, 项目目录dist（编译结果的目录）config（配置目录）config/dev.js(开发时配置)config/index.js（默认配置）config/prod.js（打包时配置）src(源码目录)src/pages（页面文件目录）/index 页面目录src/app.jsx（项目入口文件）src/app.js（项目总通用样式）package.jsonproject.config.json 常用生命周期钩子函数render()方法是必须的。当被调用时，render 方法必须返回一个 Taro 组件（可以是内置组件也可以是自定义组件）或一个 falsy 的值。render() 函数应该纯净，意味着其不应该改变组件的状态，其每次调用都应返回相同的结果，同时不直接和浏览器/小程序交互。若需要和浏览器/小程序交互，将任务放在 componentDidMount() 阶段或其他的生命周期方法。保持 render() 方法纯净使得组件更容易思考。在 React/Nerv 中，render() 可以返回多种数据结构，但 Taro 暂时只支持两种。因为 Taro 必须把 JSX 编译成微信小程序模板。当 return 的值为 falsy 时，实际上会编译成小程序的 wx:if 标签。 componentWillMount()组件在装载发生前被立刻调用。避免在该方法中引入任何的副作用或订阅。对于这些使用场景，我们推荐使用 constructor() 来替代。这是唯一的会在服务端渲染调起的生命周期钩子函数。componentWillMount() 在小程序里对应的生命周期是 onLoad。 componentDidMount()在组件被装载后立即调用。初始化使得 DOM 节点应该进行到这里。若你需要从远端加载数据，这是一个适合实现网络请求的地方。在该方法里 setState() 将会触发重新渲染。 componentWillUnmount()在一个组件被 卸载(unmounted) 和 销毁(destroyed) 之前立即被调用。 在此方法中执行任何必要的清理，例如使计时器无效，取消网络请求，清除一些可能会造成内存泄露的事件等。在小程序中，一个挂在到 Page 组件的组件并不会执行 componentWillUnmount() 方法，只有当他挂载的 Page 组件被销毁时，该组件才会执行 componentWillUnmount() 方法。 componentDidShow()在微信/百度/字节跳动/支付宝小程序中这一生命周期方法对应 onShow，在 H5/RN 中同步实现程序启动，或从后台进入前台显示时触发，微信小程序中也可以使用 Taro.onAppShow 绑定监听在此生命周期中通过 this.$router.params，可以访问到程序初始化参数参数与 componentWillMount 中获取的基本一致。百度小程序 componentDidHide()在微信/百度/字节跳动/支付宝小程序中这一生命周期方法对应 onHide，在 H5/RN 中同步实现程序从前台进入后台时触发，微信小程序中也可以使用 Taro.onAppHide 绑定监听。 componentDidCatchError(String error)在微信/百度/字节跳动/支付宝小程序中这一生命周期方法对应 onError，H5/RN 中尚未实现程序发生脚本错误或 API 调用报错时触发，微信小程序中也可以使用 Taro.onError 绑定监听 componentWillUpdate(nextProps, nextState)当接收到新的 props 或 state 时，componentWillUpdate() 在渲染之前立即被调用。在更新发生之前，使用这个方法可以作为执行准备更新的一个好机会。这个方法在第一次渲染时不会被调用。注意，这里不能调用 this.setState() 。 如果你需要更新 state 以响应 props 更改，请改用 componentWillReceiveProps()。 componentDidUpdate() 在更新发生后立即被调用。 这个方法在第一次渲染时不会被调用。 shouldComponentUpdate当你清楚在某些情况下组件不需要被重新渲染时，可以通过在 shouldComponentUpdate 钩子里返回 false 来跳过本次渲染流程。检查此次 setState 是否进行 render 调用，一般用来多次的 setState 调用时，提升 render 的性能。 componentWillReceiveProps() 在已经装载的组件接收到新属性前调用。若你需要更新状态响应属性改变，你可能需对比 this.props 和 nextProps 并在该方法中使用 this.setState() 处理状态改变。注意即使属性未有任何改变，Taro 可能也会调用该方法，因此若你想要处理改变，请确保比较当前和之后的值。在装载期间，Taro 并不会调用带有初始属性的 componentWillReceiveProps 方法。调用 this.setState 通常不会触发 componentWillReceiveProps。 钩子函数的执行顺序：componentWillMount()render()componentDidMount() setState() 状态更新一定是异步的。 组件通讯父子组件通信属性通信props 只读取 1234567891011121314151617// welcome.jsclass Welcome extends Component { render() { return ( &lt;View&gt; &lt;Text&gt;Hello, {this.props.name}&lt;/Text&gt; &lt;/View&gt; ); }}// app.jsclass App extends Component { render() { return &lt;Welcome name=&quot;Wallace&quot; /&gt;; }} 传引用类型 1234567891011121314151617181920212223// welcome.jsclass Welcome extends Component { let { list } = this.props; render() { return ( &lt;View&gt; &lt;Text&gt;Hello, {list.name}&lt;/Text&gt; &lt;/View&gt; ); }}// app.jsstate = { // eslint-disable-next-line react/no-unused-state list: { name: &quot;张三&quot; }};class App extends Component { render() { return &lt;Welcome list={this.state.list} /&gt;; }} 默认值 123456// welcome.jsWelcome.defaultProps = { list:{ name:'默认值' }} componentWillReceiveProps 路由路由配置 app.jsx 123config = { pages: [&quot;pages/index/index&quot;]}; 路由跳转 Taro.navigateTo(被浏览器记录)Taro.redirectTo(不给记录)Taro.switchTab（跳转到 tabar 页面）Taro.navigateBack（返回）Taro.reLaunch（指定页面）Taro.getCurrentPages（指定返回层级） 路由传参 123456Taro.navigateTo({ url: '/pages/page/path/name?id=2&amp;type=test'})componentWillMount () { console.log(this.$router.params) // 输出 { id: 2, type: 'test' }} 资源的引用样式文件、图片、js 文件 123456789101112131415161718192021222324// js 导出方法export function getData() { console.log(111);}export function setData() { console.log(222);}// ----function setData (){ console.log(333);}export default setData;// js 引入import { setData } from &quot;../../utils/test&quot;;setData()// ----import setData from '../../utils/test' 图片引入 1&lt;Image src={require(&quot;../../&quot;)} /&gt; 12import bg from &quot;../../&quot;;&lt;Image src={bg} /&gt;; 样式大写 PX 不会被转换成 rem 条件渲染12345678910// 三元运算符class LoginStatus extends Component { render() { const isLoggedIn = this.props.isLoggedIn; return ( &lt;View&gt;{isLoggedIn ? &lt;Text&gt;已登录&lt;/Text&gt; : &lt;Text&gt;未登录&lt;/Text&gt;}&lt;/View&gt; ); }} 列表渲染1234const numbers = [...Array(100).keys()]; // [0, 1, 2, ..., 98, 99]const listItems = numbers.map(number =&gt; { return &lt;Text className=&quot;li&quot;&gt; 我是第 {number + 1} 个数字&lt;/Text&gt;;}); Children 与组合12345678910111213141516171819202122class Dialog extends Component { render() { return ( &lt;View className=&quot;dialog&quot;&gt; &lt;View className=&quot;header&quot;&gt;Welcome!&lt;/View&gt; &lt;View className=&quot;body&quot;&gt;{this.props.children}&lt;/View&gt; &lt;View className=&quot;footer&quot;&gt;-- divider --&lt;/View&gt; &lt;/View&gt; ); }}class App extends Component { render() { return ( &lt;View className=&quot;container&quot;&gt; &lt;Dialog&gt; &lt;View className=&quot;dialog-message&quot;&gt;Thank you for using Taro.&lt;/View&gt; &lt;/Dialog&gt; &lt;/View&gt; ); }} 事件处理Taro 事件绑定属性的命名采用驼峰式写法 向事件处理程序传递参数 123456789handleClick(param,event) { console.log(param,event);}&lt;view&gt; &lt;Button onClick={this.handleClick.bind(this, this.state.name)}&gt;event&lt;/Button&gt;&lt;/view&gt; 阻止事件冒泡event.stopPropagation(); 内置环境变量process.env.TARO_ENV 以上是我对下列视频及文章的归纳和总结。千锋 Taro 开发框架手把手教你写个小程序定时器管理库","link":"/2020/01/31/Blog-about-learning-19/"},{"title":"零基础玩转微信小程序","text":"小程序基础⼩程序结构⽬录小程序原生框架小程序模板语法小程序内置组件小程序生命周期小程序自定义组件小程序项目 以上是我对下列视频及文章的归纳和总结。零基础玩转微信小程序p7","link":"/2020/02/06/Blog-about-learning-24/"},{"title":"28天PHP零基础入门到精通教程","text":"搭建环境Web 程序的访问流程 浏览器发起访问 -&gt; DNS 解析域名 -&gt; 服务器 -&gt; 服务 静态网站访问 动态网站访问 安装 Apache 软件 获取 Apache 安装软件 安装 Apache 选择安装模式：使用自定义模式 选择安装路径 目录说明 httpd.exe 的详细应用 服务器进程：运行之后才能够工作 用来查看 Apache 具有哪些功能以及配置文件是否有错：httpd 或 httpd.exe（文件所在目录） 查看使用的模块：httpd -M 验证配置文件是否有效：httpd -t 配置默认站点让 Apache 确定服务器上访问的位置：网站文件夹所在位置 conf/httpd.conf：DocumentRoot 方便用户使用名字访问对应的网站：给文件夹对应一个别名 conf/httpd.conf：ServerName 端口可以单独实现：conf/httpd.conf：Listen 凡是涉及到 Apache 配置文件的修改，那么需要重启 Apache 才能生效。实现 DNS 域名解析：通常默认站点都是本地 DNS：hosts 文件 安装与配置 PHP 安装 PHP 语言 获取 PHP 安装文件，建议去官网 解压缩安装：将解压包放到：E:/server/，重命名 PHP5 PHP 的目录结构说明 PHP.exe 的应用PHP.exe 可以解析 PHP 代码转变成 HTML 代码从而让浏览器可以解析的。 通过 CMD 控制器进入到 PHP.exe 所在目录 通过 php.exe 运行命令来指定解析的 PHP 脚本。php.exe -f php 文件所在路径 配置 Apache 加载 PHP 模块 Apache 加载 PHP 模块：在 Apache 的主配置文件中加载对应的 PHP 提供的模块LoadModule php5_module PHP 所提供的模块链接所在路径。 Apache 分配工作给 PHP 模块：是 PHP 代码就交给 PHP 处理：文件后缀判断.php 结尾肯定是 PHP 代码。AddType application/x-httpd-php.php 将 PHP 的配置文件加载到 Apache 配置文件中：共同生效。在 Apache 中指定 PHP 配置文件所在路径PHPIniDir php.ini 所在路径 php.ini 文件默认是不存在的，是以 development 和 production 格式存在，需要格式化将 development 文件复制一份，改成 php.ini 说明：PHP 的配置文件已经加入到 Apache 的配置项中，意味着 php.ini 的修改需要 Apache 重启才会生效。 安装与配置 MySQL获取 MySQL 安装软件 双击安装即可 选择 custom，自定义安装：选择安装路径软件安装目录：server/mysql 数据安装目录：server/mysql/data 在完成安装之后，要实现配置 选择详细配置 选择开发环境：默认的 选择功能：默认 并发设置(建议手动) 配置访问环境：默认 字符集设定：系统字符集 服务安装：将 mysql 作为 windows 下的一个服务启动 输入 root（超级管理员）的用户密码 等待配置：4 个都要勾上 以上是我对下列视频及文章的归纳和总结。28 天 PHP 零基础入门到精通教程","link":"/2020/02/09/Blog-about-learning-25/"},{"title":"彻底弄懂bind，apply，call三者的区别","text":"为什么要改变 this 指向？例子： 123456789var name = 'lucy';let obj = { name : &quot;martin&quot;, say : function(){ console.log(this.name); }}obj.say(); // martin this指向obj对象setTimeout(obj.say,0); // lucy ，this 指向 window 对象 可以观察到，正常情况下 say 方法中的 this 是指向调用它的 obj 对象的，而定时器 setTimeout 中的 say 方法中 this 是指向 window 对象的（浏览器中），这是因为 say 方法在定时器中是作为回调函数来执行的，因此回到主线执行时是在全局执行上下文的环境中执行的，但我们需要的是 say 方法中 this 指向对象 obj 对象，因此我们需要修改 this 的指向。 apply 方法apply 接受两个参数，第一个参数是 this 的指向，第二个参数是函数接受的参数，以数组的形式传入，且当第一个参数为 null、undefined 的时候，默认指向 window（浏览器中），使用 apply 方法改变 this 指向后原函数会立即执行，且此方法只是临时改变 this 指向一次。 日常用法：改变 this 指向 示例：回调函数绑定 this 指向 123456789101112var name = 'martin';var obj = { name : 'lucy', say : function(year,place){ console.log(this.name + ' is ' + year + ' born from ' + place); }}var say = obj.say; setTimeout(function() { say.apply(obj, [&quot;1996&quot;, &quot;Chia&quot;]); // lucy is 1996 born from Chia，this 改变指向 obj }, 0);say('1996','China'); // martin is 1996 born from China，this 指向 window，说明 apply 只是临时改变一次 this 指向 小技巧：改变参数传入方式 示例：求数组中的最大值： 12var arr = [1,10,5,8,3];console.log(Math.max.apply(null,arr)) // 10 其中 Math.max 函数的参数是以参数列表，如：Math.max(1,10,5,8,3)的形式传入的，因此我们没法直接把数组当做参数，但是 apply 方法可以将数组参数转换成列表参数传入，从而直接求数组的最大值。 callcall 方法的第一个参数也是 this 的指向，后面传入的是一个参数列表（注意和 apply 传参的区别）。当一个参数为 null 或 undefined 的时候，表示指向 window （浏览器中），和 apply 一样，call 也只是临时改变一次 this 指向，并立即执行。 示例： 123var arr = [1,10,5,8,3];console.log(Math.max.call(null,arr[0],arr[1],arr[2],arr[4])); // 10console.log(Math.max.call(null, ...arr)); // 10 call 以参数列表的形式传入，而 apply 以参数数组的形式传入。 bind 方法bind 方法 和 call 很相似，第一个参数也是 this 的指向，后面传入的也是一个参数列表（但是这个参数列表可以分多次出入，call 则必须一次性传入所有参数），但是它改变 this 指向后不会立即执行，而是返回一个永久改变 this 指向的函数。 示例： 123var arr = [1,10,5,8,12];var max = Math.max.bind(null,arr[0],arr[1],arr[2],arr[3]);console.log(max(arr[4])); // 12 ，分两次传参 可以看出，bind 方法可以分多次传参，最后函数运行时会把所有参数连接起来一起放入函数运行。 实现 bind 方法（面试题） 简易版： 123456789Function.prototype.bind = function(){ var _this = this; var context = arguments[0]; var arr = [].slice.call(arguments,1); return function(){ arg = [].concat.apply(arg,arguments); _this.apply(context,arg); }} 完美版 1234567891011121314151617181920212223242526272829303132// 实现 bind 方法Function.prototype.bind = function(oThis){ if(typeof this !== 'function'){ // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable'); } var aArgs = Array.prototype.slice.call(arguments,1), fToBind = this, fNOP = function(){ fBound = fucntion(){ // this instanceof fBound === true 时，说明返回的 fBound 被当做 new 的构造函数调用 return fToBind.apply(this instanceof fBound ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)) ); } // 维护原型关系 if (this.prototype) { // 当执行Function.prototype.bind()时, this为Function.prototype // this.prototype(即Function.prototype.prototype)为undefined fNOP.prototype = this.prototype; } // 下行的代码使fBound.prototype是fNOP的实例,因此 // 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例 fBound.prototype = new fNOP(); return fBound; }; var arr=[1,11,5,8,12]; var max=Math.max.bind(null,arr[0],arr[1],arr[2],arr[3]); console.log(max(arr[4])); //12 }} apply、call、三者的区别三者都可以改变函数的 this 对象指向。三者第一个参数都是 this 要指向的对象，如果没有这个参数或参数为 undefined 或 null，则默认指向全局 window。三者都可以传参，但是 apply 是数组，而 call 是参数列表，且 apply 和 call 是一次性传入参数，而 bind 可以分为多次传入。bind 是返回绑定 this 之后的函数，便于稍后调用； apply、call 则是立即执行。 以上是我对下列文章的复制粘贴。详细请看下列文章。彻底弄懂 bind，apply，call 三者的区别JS中的call、apply、bind方法详解","link":"/2020/02/12/Blog-about-learning-26/"},{"title":"九个Console命令，让 JS 调试更简单","text":"显示信息的命令123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;常用console命令&lt;/title&gt; &lt;script&gt; console.log(&quot;hello&quot;); console.info(&quot;信息&quot;); console.error(&quot;错误&quot;); console.warn(&quot;警告&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 占位符console 上述的集中度支持 printf 的占位符格式，支持的占位符：字符串（%s）、整数（%d 或 %i）、浮点数（%f）和对象（%o） 123&lt;script&gt; console.log(&quot;%d年%d月%d日&quot;, 2011, 3, 26);&lt;/script&gt; 信息分组12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;常用 console 命令&lt;/title&gt; &lt;script&gt; console.group(&quot;第一组信息&quot;); console.log(&quot;第一组第一条:我的博客(http://www.ido321.com)&quot;); console.log(&quot;第一组第二条:CSDN(http://blog.csdn.net/u011043843)&quot;); console.groupEnd(); console.group(&quot;第二组信息&quot;); console.log(&quot;第二组第一条:程序爱好者QQ群： 259280570&quot;); console.log(&quot;第二组第二条:欢迎你加入&quot;); console.groupEnd(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 查看对象的信息console.dir() 可以显示一个对象所有的属性和方法。 12345678&lt;script&gt; var info = { blog : 'http://www.ido321.com', QQGroup : 259280570, message : '程序爱好者喜迎你的加入' } console.dir(info);&lt;/script&gt; 显示某个节点的内容console.dirxml() 用来显示网页的某个节点 （node）所包含的 html/xml 代码。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;常用 console 命令&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id = 'info'&gt; &lt;h3&gt;我的博客：www.ido321.com&lt;/h3&gt; &lt;p&gt;程序员爱好者：259280570，欢迎你的加入&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var info = document.getElementById('info'); console.dirxml(info); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 判断变量是否是真console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。 123456&lt;script&gt; var result = 1; console.assert(result); var year = 2014; console.assert(year == 2018);&lt;/script&gt; 追踪函数的调用轨迹console.trace() 用来追踪函数的调用轨迹。 12345678910111213141516171819&lt;script&gt; function add(a, b) { console.trace(); return a + b; } var x = add3(1, 1); function add3(a, b) { return add2(a, b); } function add2(a, b) { return add1(a, b); } function add1(a, b) { return add(a, b); }&lt;/script&gt; 计时功能console.time()和 console.timeEnd()，用来显示代码的运行时间。 1234567&lt;script type=&quot;text/javascript&quot;&gt; console.time(&quot;A&quot;); for (let i = 0; i &lt; 10000; i++) { console.log(i); } console.timeEnd(&quot;A&quot;); &lt;/script&gt; 性能分析性能分析（Profiler）就是分析程序各个部分的运行时间，找到瓶颈所在，使用的方法是 console.profile(); 123456789101112131415161718&lt;script&gt; function All() { alert(11); for (var i = 0; i &lt; 10; i++) { funcA(1000); } funcB(10000); } function funcA(count) { for (var i = 0; i &lt; count; i++) {} } function funcB(count) { for (var i = 0; i &lt; count; i++) {} } console.profile(&quot;性能分析器&quot;); All(); console.profileEnd();&lt;/script&gt; 以上是我对下列文章的复制粘贴。详细请看下列文章。九个 Console 命令，让 js 调试更简单","link":"/2020/02/13/Blog-about-learning-27/"},{"title":"2019Vue、Vuejs最详细教程-入门到项目实战","text":"指令v-once只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有子节点将被视为静态内容并跳过。这可以用于优化更新性能。 12345678910111213&lt;!-- 单个元素 --&gt;&lt;span v-once&gt;This will never change: {{msg}}&lt;/span&gt;&lt;!-- 有子元素 --&gt;&lt;div v-once&gt; &lt;h1&gt;comment&lt;/h1&gt; &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt;&lt;!-- 组件 --&gt;&lt;my-component v-once :comment=&quot;msg&quot;&gt;&lt;/my-component&gt;&lt;!-- `v-for` 指令--&gt;&lt;ul&gt; &lt;li v-for=&quot;i in list&quot; v-once&gt;{{i}}&lt;/li&gt;&lt;/ul&gt; 通过 v-once 创建低开销的静态组件 渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once attribute 以确保这些内容只计算一次然后缓存起来。 示例： 12345678Vue.component('terms-of-service', { template: ` &lt;div v-once&gt; &lt;h1&gt;Terms of Service&lt;/h1&gt; ... a lot of static content ... &lt;/div&gt; `}) 再说一次，试着不要过度使用这个模式。当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的 —— 再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 v-once 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。 v-cloak这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 示例： 123[v-cloak] { display: none;} 123&lt;div v-cloak&gt; {{message}}&lt;/div&gt; 不会显示，直到编译结束。 v-slot 以上是我对下列视频及文章的归纳和总结。2019Vue、Vuejs 最详细教程-入门到项目实战","link":"/2020/02/15/Blog-about-learning-29/"},{"title":"webgl 从入门到实践开发","text":"canvanssvg 以上是我对下列视频及文章的归纳和总结 Three.js和其它webgl框架CreateJS 新司机开车指南√ CreateJS 新司机开车指南 Pixijs","link":"/2020/08/04/Blog-about-learning-3/"},{"title":"Vue 项目性能优化 — 实践指南","text":"代码层面的优化v-if 和 v-show 区分使用场景v-if 是真正的条件渲染,因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做 —— 直到条件第一次变为真时，才会开始渲染条件块。v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 需要非常频繁地切换，则使用 v-show 较好，如果在运行时条件很少改变，则使用 v-if 较好。 computed 和 watch 区分使用场景computed：是计算属性，依赖其他属性值，并且 computed 的值有缓存，只有它依赖的属性值发生变化，下一次获取 computed 的值时才会重新计算 computed 的值。 watch:更多是观察的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 需要进行数值计算，并且依赖于其他数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次取值时，都要重新计算；需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许当我们执行异步操作（访问一个 API）,限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的。 v-for 遍历必须为 item 添加 key，且避免同时使用 v-ifv-for 遍历必须为 item 添加 key 在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制准确找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff。 v-for 遍历避免同时使用 v-if v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应当替换成 computed 属性。 长列表性能优化Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何更改，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。 123456789export default { data: () =&gt; ({ users: {} }), async created() { const users = await axios.get(&quot;/api/users&quot;); this.users = Object.freeze(users); }}; 事件的销毁Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如： 123456created() { addEventListener('click', this.click, false)},beforeDestroy() { removeEventListener('click', this.click, false)} 图片资源懒加载对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件： 安装插件 1npm install vue-lazyload --save-dev 以上是我对下列文章的复制粘贴。详细请看下列文章。Vue 项目性能优化 — 实践指南","link":"/2020/02/14/Blog-about-learning-28/"},{"title":"直播从入门到实践开发","text":"大前端技能ES6、react、vue、webpack、angluar 服务类node.jsexpress.jskoa.js 3d 数据图像three.js 二维图像d3.jsraphael.jsechart.js 视频video.jshls.jsflv.js 直播直播原理 hls 对应的是 ts格式的视频，只有苹果浏览器支持mp4、webm 偏点播 hls、flv偏直播 直播协议HLS 协议 tm视频格式 延时RTMP 协议 flv 视频格式 配置复杂HTTP-FLV协议 flv 视频格式 低延时、 HLS协议 live playlist（动态列表）直播event playlist（静态列表）vod playlist（全量列表）点播 延时跟 m318 文件跟切片有关系 RTMP 协议RTMP 是 Real Time Messaging Protocol （实时消息传输协议）的首字母缩写。该协议基于 TCP，是一个协议族，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种。RTMP 是一种设计用来进行实时数据通信的网络协议，主要用来在 Flash、AIR 平台和支持 RTMP 协议的流媒体/交互服务器之间进行音视频和数据通信。主播客户端使用。flv视频格式。 采集端用 web 来做 协议是 webrtc。 HTTP-FLV协议 接合二者优点flv 视频格式建立长连接建立 HTTP 协议 1、可以在一定程度上避免防火墙的干扰（例如：有的机房只允许 80 端口通过）2、可以很好的兼容 HTTP 302 跳转，做到灵活调度3、可以使用 HTTPS 做加密通道4、很好的支持移动端（android,ios） video属性和方法 贴图 poster控制条 controls自动播放 autoplay循环播放 loop预加载 preload音量 volume播放地址设置静音 muted播放时间设置 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!-- 控制条 无下载无全屏 --&gt;&lt;video controls controlslist=&quot;nodownload nofullscreen&quot;&gt;&lt;/video&gt;&lt;!-- 贴图 --&gt;&lt;video poster='./poster.jpg'&gt;&lt;/video&gt;&lt;!-- 自动播放 --&gt;&lt;video autoplay&gt;&lt;/video&gt;&lt;!-- 静音 非静音状态下的视频是不允许自动播放的 --&gt;&lt;video muted&gt;&lt;/video&gt;&lt;!-- 循环播放 --&gt;&lt;video loop&gt;&lt;/video&gt;&lt;!-- 预加载 --&gt;&lt;video preload&gt;&lt;/video&gt;&lt;!-- 音量控制 --&gt;&lt;video id=&quot;_volume&quot;&gt;&lt;/video&gt;&lt;script&gt; var v = document.getElementById('_volume') v.volume = 0.5&lt;/script&gt;&lt;!-- 控制播放时间 --&gt;&lt;script&gt; var v = document.getElementById('_volume') v.currentTime = 60 //单位秒&lt;/script&gt;&lt;!-- 切换视频地址 --&gt;&lt;script&gt; var v = document.getElementById('_volume') v.src = './test-2.mp4' //单位秒&lt;/script&gt;&lt;!-- 备用地址 --&gt;&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; 您的浏览器不支持Video标签。&lt;/video&gt;&lt;script&gt; var v = document.getElementById('_volume') setTimeout(function(){ console.log('src',v.currentSrc); },1000)&lt;/script&gt; 事件 视频查找时长变化元数据加载视频下载监听可播放监听播放监听暂停监听查找开始查找结束视频加载等待视频结束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;video id=&quot;_volume&quot;&gt;&lt;/video&gt;&lt;script&gt; var v = document.getElementById('_volume'); console.log(v.duration); // 视频开始加载 v.addEventListener('loadstart',function(e){ console.log('loadstart'); }) // 监听事长变化 v.addEventListener('durationchange',function(e){ console.log('loadstart'); // 查看视频时长 console.log(v.duration); }) // 获取到视频的源数据 v.addEventListener('loadedmetadata',function(e){ console.log('loadedmetadata'); }) // 加载下一帧 v.addEventListener('loadeddata',function(e){ console.log('loadeddata'); }) // 正在下载 v.addEventListener('progress',function(e){ console.log('progress'); }) // 视频可以播放 v.addEventListener('canplay',function(e){ console.log('canplay'); }) // 视频可以流程播放了 v.addEventListener('canplaythrough',function(e){ console.log('canplaythrough'); }) // canplay、canplaythrough 之后允许播放 // 播放触发 v.addEventListener('play',function(e){ console.log('play'); }) // 暂停 v.addEventListener('pause',function(e){ console.log('pause'); }) // 监听播放位置改变 v.addEventListener('seeking',function(e){ console.log('seeking'); }) // seeking 结束 v.addEventListener('seeked',function(e){ console.log('seeked'); }) // waiting 等待 视频无法解码 v.addEventListener('waiting',function(e){ console.log('waiting'); }) // 当音频/视频在已因缓冲而暂停或停止后已就绪时 v.addEventListener('playing',function(e){ console.log('playing'); }) // 当目前的播放位置已更改时 v.addEventListener('timeupdate',function(e){ console.log('timeupdate'); }) // 返回音频/视频的播放是否已结束 v.addEventListener('ended',function(e){ console.log('ended'); }) // 返回表示音频/视频错误状态的 MediaError 对象 v.addEventListener('error',function(e){ console.log(v.error.code); })&lt;/script&gt; 直播源的制作方法一 nginx + ffmpeg 1、安装 nginx、ffmpeg2、配置 nginx3、准备视频4、利用 ffmpeg 推流 安装 Nginx Mac: brew install nginx-full –with-rtmp-modulewindows：http://nginx.org/en/download.html windows 下载如下nginx/Windows-1.18.0 pgp 安装 ffmpeg Mac：brew install ffmpegwindows：https://ffmpeg.org/download.htmlffmpeg下载 ffmpeg ffmpeg 检查是否安装 命令行输入 ffmpeg 配置 nginx 12345678910111213141516171819202122232425262728293031location /hls { types { application/vnd.apple.mpegurl m3u8; video/mp2t ts; } root /usr/local/var/www; add_header Cache-Control no-cache;}rtmp { server { # rtmp 直播流配置 application rtmplive { # 开启 live on; # 最大连接数 max_connections 1024; } # hls 直播流配置 application hls { # 开启 live on; hls on; # 文件存储地址 hls_path /usr/local/var/www/hls hls_fragment 5s; } }} 启动 nginx 的配置不报错，退出的时候报错，报错信息是以下内容nginx: [emerg] unknown directive “rtmp” in D:\\nginx-1.18.0/conf/nginx.conf:9网上说用记事本打开会增加 utf8-bom 什么的格式导致，但是我下来了nginx-rtmp-module 中的测试例子仍报错。网上资料显示说下载自带 rtmp 模块的 nginx 版本 如 nginx 1.7.11.3 Gryphon。网上资料说下载 nginx 1.8.1版本然后下载 nginx-rtmp-module 启动命令 ./sbin/nginx -s reload，尝试了下，启动不了 ………… 问题搁置 推流 ffmpeg -re -i IPX-451.mp4 -vcodec libx264 -acodec aac -f flv rtmp://localhost:1935/rtmplive/rtmffmpeg -re -i IPX-451.mp4 -vcodec libx264 -acodec aac -f flv rtmp://localhost:1935/hls/stream 下载 vlc播放器验证推流过程 方法二 集成服务 1、下载服务2、安装服务3、准备源视频4、开启服务5、利用 ffmpeg 推流 启动 server 下服务 open server 推流命令 ffmpeg -re -i IPX-451.mp4 -c copy -f flv rtmp://localhost:1935/live/movie 验证地址 RTMP：rtmp://localhost:1935/live/movieFLV：http://127.0.0.1:7001/live/movie.flvHLS：http://127.0.0.1:7002/live/movie.m3u8 H5 直播video.js：自定义UI、快捷键、弹幕、播放 HLShls.js：HLS 类型的直播点播、小巧flv.js：HTTP-FLV协议 全局安装 eslint npm i eslint -g 配置eslint –init 相关资料[视频]H5与小程序直播开发视频教程√ 如何开发一款H5小程序直播 DPlayer：视频播放器xgplayer：具有解析器的HTML5视频播放器，可节省流量nginx-rtmp-module：基于NGINX的媒体流服务器H5与小程序直播开发视频 源码：具有解析器的HTML5视频播放器，可节省流量 videojs 的插件和皮肤 超简单的FFmpeg安装方法√vue : 无法加载文件 C:\\Users\\XXX\\AppData\\Roaming\\npm\\vue.ps1，因为在此系统上禁止运行脚本√windows下nginx的rtmp配置加载问题 unknown directive “rtmp”√使用nginx-rtmp-module搭建RTMP直播服务器√关于HLS直播流HTML页面播放解决√ HTML5视频直播及H5直播扫盲大前端介绍与直播原理前端中的直播[使用flv.js做直播](https://github.com/gwuhaolin/blog/issues/3web前端 html5 直播功能开发使用flv.js快速搭建html5网页直播html5-dash-hls-rtmp关于flv.js 在ios端播放时候id兼容问题直播中前端技术","link":"/2020/02/06/Blog-about-learning-23/"},{"title":"2020年 最新前端学习路线","text":"核心技能 HTML编写网页结构 CSS美化页面盒子模型、布局方式（Flexbox，Grid） JavaScript事件、交互、数据处理基础语法、ES 新规范 网络基础域名、服务器、Linux、服务器程序、HTTP 协议 进阶技能 响应式布局 兼容性调整 UI 框架Bootstrap、Semantic UI、Tailwind CSS SEO Node.js npm/yarn CSS 预编译工具Sass、Less 自动化工具Grunt、Gulp React、Vue、AngluarAnt Design、Element UI 模块化 CSSCSS Modules、styled-components 工程化工具Webpack、Parcel 测试工具Jest、Enzyme 高级技能 TypeScriptAnt Desiqn，Element UI 移动开发React Native，Taro，Uni-App 桌面开发Electron、Proton Native 静态网站生产工具Heox、Gatsby，Docusaurus SSR（服务端渲染）Next.js，Nuxt.js GraphQl 性能优化 安全 工作与团队技能 Git &amp; Github Docker CI ESLint / Prettier 新技术 WebAssemblyWeb Assembly 是浏览器新支持的编程语言，用于辅助 JavaScript。可以用它的编辑器编译其他语言，用来编写更强大的功能，它目前支持 c++ 和 rust Web ComponentsWeb Components 是类似 React、Vue 开发的方式，是 JavaScript 原生支持的方式，不再需要依赖额外的库。它的核心概念有 Custom element （自定义元素），Shadow DOM （影子 DOM）、HTML templates （HTML 模板） 最佳实践设计模式、组件设计原则、代码结构 持续进步精进技能、关注新闻、学好英语 以上是我对下列视频及文章的归纳和总结。2020 年最新前端学习路线","link":"/2020/03/05/Blog-about-learning-31/"},{"title":"千锋HTML5高级教程-移动端WebApp及混合App开发","text":"P1 移动 m 站开发知识点概述1.本地存储+多媒体2.touch.js（移动端触摸事件库） + swiper.js（移动端触摸滑动插件） + animate.css（CSS3 动画库） + iScroll.js（移动端区域滚动插件）3.Gulp + webpack 前端工程化 + Sass 开发 UI 核心函数4.嵌入地图与地理定位（H5 Navigator.geolocation）5.Touch 端项目实战开发 P2 微信场景应用制作微信场景微场景是指使用 HTML5 编码的绚烂的页面，可以翻页、可以呈现各种动态、3D、简单交互效果，根据编程不同可以承载各种商业目的：比如活动召集、论坛邀请函、优惠券发放、新品品牌发布等等，微场景只是移动端的一个载体。 微信场景的应用与制作微信场景的制作工具：易企秀、MAKA、兔展 优点：1、模板丰富2、制作简单 缺点：1、会出现制作工具的 logo 水印和广告2、创意受模板和所提供的技术的限制，不能实现产品的深度定制，缺乏竞争力。 定制化的程序开发 优点：1、可以深度定制，提升产品的创意和个性2、技术使用更灵活，可以实现客户需求3、性能可以通过程序员把控，用户体验更佳 使用前端技术 swiper、animation、three.js、canvas 等。 P3 Angular 项目实战Angular 介绍Angular 是 Google 提供的一套基于 MVC 结构的 JavaScript 开发工具，是一套开源的项目框架。 为什么学习 Angular1、CRUD 每个公司企业必然会有的项目2、效率高，节省人力物力财力 Angular 组成部分1、指令2、过滤器3、模板4、路由5、服务 P4 Ionic 项目实战Ionic 介绍Ionic Framework Ionic 是一款创建 Native App 的 SDK 应用现状流行的 Web 开发技术：HTML + CSS + JavaScript 构建 Ionic 是很多 Framework 中的一种。 Ionic 入门理解： AngularCordovaGulpSassNodeBowerGitIonic Framework Ionic 入门学习: 1、Ionic 安装2、Ionic 创建 App3、Ionic CSS4、Ionic JavaScript Ionic 案例1、侧边栏项目2、Cordova 拍照 + 扫描二维码3、Ionic 打包原生 App P5 Vue.js 项目实战Vue.js 介绍Vue.js 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。 1、简洁2、轻量3、快速4、数据驱动5、模块友好6、组件化 为什么学习 Vue.js1、前后端分离已经是业界所共识的一种开发/部署模式了，数据渲染的担子就落在了前端，Vue 的声明式渲染以及数据驱动可以帮助我们轻松应对。2、渐进式的框架，轻松应对开发者的各种业务需求与使用场景。3、结合 Vue 的第三方 UI 框架，可以快速交付 PC 端与移动端产品4、企业对于 Vue 需求量与日俱增。 学习 Vue.js1、Vue.js 基础2、模块化3、单文件组件4、路由5、与服务器通信6、状态管理7、单元测试8、生产发布 Vue.js 项目实战技术栈：VueVue-RouterVueXWebpackES6/7SassAxios P6 React 项目实战学习 React 需要具备1、对 React 语法已经有了初步的理解2、对 ES6 编程已经有了实质性的操作3、对 Node 有一定的了解 为什么学习 ReactReact 框架是由 Facebook 开发，是一个典型的 MVC 框架 虽然它仅仅是 MVC 中的 View 层，但使用起来，即轻量并且高效，目前已经很多公司在使用这个框架。 什么是 Ant DesignAnt Design 是一个由阿里旗下蚂蚁金服 UED 团队开发，基于 React 的 UI 设计框架，其思想和 Google 开源 Material Design 是非常相似。 Create React App推荐 create-react-app 进行 Ant Design 项目的搭建，create-react-app 是目前比较普遍使用的一个为 React 构建项目的脚手架工具，当然它完全可以配合 webpack 以满足各类工程化需求。 create-react-app 使用yarn create react-app my-appcd my-appyarn startyarn add antd P7 微信小程序开发微信小程序简介微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。 小程序技术栈HTML5CSS3JavaScriptES P8 React Native 开发React Native 介绍React Native 是 Facebook 推出，强大，开源的 HTML5 跨平台移动 App 开发框架，它能大幅度减少跨平台移动应用开发的工作量，并且代码结构清晰、简单易懂。 App 开发方式原生 开发周期长、开发成本高、维护成本高、代码复用率低、学习成本高、无法热更新 混合开发 跨平台、开发周期短、开发成本低、代码复用率高、维护成本低、学习成本低、可以热更新 学习 React NativeReact Native 的语法基于 React。 React Native 环境搭建原生组件 TextInput、ScrollView、ListView、Touchable 触摸交互组件等异步执行（数据交互）触摸事件处理弹性盒（FlexBox）页面布局兼容通用标准和扩展性React Native 项目开发 P9 微信公众号开发公众号简介微信公众号是开发者或商家在微信公众平台上申请的应用账号，商家可在微信平台上实现和特定群体的文字、图片、语言、视频的全方位沟通、互动。形成了一种主流的线上线下微信互动营销方式。 临时云服务新浪云、阿里云 微信网页开发 微信网页授权 微信网页开发样式库 微信 JS-SDK 说明文档 微信 Web 开发者工具 微信网页授权授权授权的权限为服务号网页授权安全域名开发者 IDaccess_token 是公众号的全局唯一接口调用凭证网页授权请求 URL P10 Cordova 混合开发混合开发原理WebViewJavaScriptBridge 是移动 UIView 和 HTML 交互通信的桥梁，实现 Native Code 和 JavaScript 的互相调用的桥梁。替代了 WebView 的自带 JavaScriptInterface 的接口，使开发更加灵活和安全。 Cordova 混合开发混合开发优点 一次编译多平台运行，iPhone、Android、Palm、Symbian、WP7、WP8、Bada 和 Blackberry 都可以无障碍适应，只需要简单操作轻松打包。开发速度快，只需要掌握前端开发知识，并不一定需要了解各个平台的 Native 开发语言也可以开发轻量级移动应用。 发布应用以后，其软件内容可以做到热更新操作，即更新操作不需要进行再次内容审查操作，节省上线时间。 由于前端技术本身的跨平台性，决定了使用该技术以后发布的移动应用其各个平台 UI 表现将会保持绝对的一致性。 基础操作// 创建项目cordova create MyAppcd MyApp// 添加平台cordova platform add browser// 运行项目cordova run browser// 打包cordova build ios// 查看平台cordova platform ls P11 MUI HTML5 混合开发MUI 简介MUI 框架是一个方便开发出高性能 App 的框架，也是目前最接近原生 App 效果的框架。特点：轻、小、界面风格原生化 MUI 概述1、使用 MUI UI 组件构建移动端页面2、MUI 基本 API 的使用3、窗口管理4、事件管理5、上下拉刷新6、网络请求 为什么学习 MUI1、最接近原生 App 体验的高性能前端框架2、原生 UI H5+在你的原生应用中内嵌 H5 + SDK，替代手机默认的 WebView ，无论使用 Hybrid 开发模式，还是在原生 App 中构建 web 应用生态，都将能体验到更强大的内核动力。 H5 H5+ 概述1、调用摄像头实现拍照功能2、实现二维码扫描功能3、实现摇一摇功能4、实现分享到朋友圈功能5、地理定位6、第三方登录7、推送8、支付 为什么学习 H5+1、增强版的手机浏览器引擎，让 HTML5 达到原生水平2、能力：原生 40万 API 支持 P12 Node 全栈开发为什么学习 Node1、使用 JavaScript2、更好的使用前端开发工具（webpack、gulp）3、先进的设计理念，异步化模型4、企业需求 学习 Node1、Node.js2、MySQL3、MongoDB4、Express5、项目实战6、socket7、测试工具 mocha P13 Egret 游戏开发Egret WingEgret EngineDragonBonesEgret Feather 相关文章：H5游戏开发：游戏引擎入门推荐 P14 Java 项目开发Java 特点 Java 具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。 Java 可以编写桌面应用程序、Web 应用程序、分布式系统和嵌入式系统应用程序等。 整站静态化Java FreeMarker 后端模板 FreeMarker 语法： 变量输出${param} 条件判断&lt;#if ${isAdmin}&gt;管理员界面&lt;#if&gt; 循环 123&lt;#list animals as being&gt; &lt;li&gt;${being.name}&lt;/li&gt;&lt;#list&gt; 整站静态化的意义对于 SEO 友好方便部署 CDN，提高页面的访问速度减少服务器负载 P15 PHP 项目开发PHP 项目开发PHP 基础 PHP 函数库、PHP 常规操作原生项目开发第三方产品应用 ECShop、DedeCMS、WordPress P16 Android 项目开发Android 应用介绍Android 是一种基于 Linux 的自由及开源代码的操作系统，主要使用于移动设备。 为什么学习 Android 应用开发Android 手机市场占比 87.5%Android 岗位人才需求Android 手机用户量巨大 学习 Android 应用开发1、Android 基础与环境搭建2、Android UI 基础与进阶3、核心组件的应用4、数据存储相关组件5、移动开发主流界面6、View 深入开发7、Android 与 H5 的混合开发模式8、Android 与 React Native 的混合开发模式9、打包 Android 应用 以上是我对下列视频及文章的归纳和总结。千锋 HTML5 高级教程-移动端 WebApp 及混合 APP 开发_1 阶段课程体系","link":"/2020/02/15/Blog-about-learning-30/"},{"title":"vue 从入门到实践开发","text":"Vue 官网选项 / 数据props 123456789101112131415161718&lt;script&gt; Vue.component('child',{ props:['content'], props:{ content: Number content: [Number,String], content: { type: String, required:true, default:'default value' }, validator: function(value){ return value.length &gt; 5 } }, template:&quot;&lt;div&gt;{{content}}&lt;/div&gt;&quot; })&lt;/script&gt; Prop Prop 大小写 静态动态Prop传递、Prop 类型及Prop 验证 单向数据流 非 Prop 的继承和禁用继承 自定义事件 事件名 自定义组件的 v-model（model） 原生事件绑定到组件（.native、$listeners-表单类元素） .sync修饰符-实现类似双向绑定效果 123&lt;div id=&quot;root&quot;&gt; &lt;child @click.native=&quot;handleClick&quot;&gt;&lt;/child&gt;&lt;/div&gt; 选项 / DOMel 选项 / 组合mixins 实例 propertyvm.$slots 实例方法 / 数据vm.$watch vm.$set vm.$delete 实例方法 / 事件vm.$emit this.$parent this.$children this.$root 指令常用指令 v-ifv-showv-for 12// :key 标识组件的唯一性// 操作数组更新视图的 push、pop、shift、unshift、splice、sort、reverse 或改变引用地址 v-bindv-modelv-textv-html v-once 只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 123456789101112/* 通过 v-once 创建低开销的静态组件渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once attribute 以确保这些内容只计算一次然后缓存起来，就像这样：*/Vue.component('terms-of-service', { template: ` &lt;div v-once&gt; &lt;h1&gt;Terms of Service&lt;/h1&gt; ... a lot of static content ... &lt;/div&gt; `}) 组件封装123456789101112&lt;!--ref refs 的使用--&gt;&lt;table&gt; &lt;tr is=&quot;row&quot;&gt;&lt;/tr&gt;&lt;/table&gt;&lt;ul&gt; &lt;li is=&quot;row&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; Vue.component('row',{ template:'&lt;tr&gt;&lt;td&gt;this is a row&lt;td&gt;&lt;tr&gt;' })&lt;/script&gt; 12345678910111213141516&lt;!--ref refs 的使用--&gt;&lt;div ref=&quot;hello&quot; @click=&quot;handleClick&quot;&gt; hello world &lt;counter ref=&quot;one&quot; @change=&quot;handleChange&quot;&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el:'#root', methods:{ handleClick:function(){ this.$refs.hello // 获取 Dom 节点 this.$refs.one // 获取 子组件的引用 } } })&lt;/script&gt; 123456789101112131415161718192021222324252627282930// 非父子组件间传值（Bus/总线/发布订阅模式/观察者模式）&lt;div id=&quot;root&quot;&gt; &lt;child content=&quot;Dell&quot;&gt;&lt;/child&gt; &lt;child content=&quot;Lee&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; Vue.prototype.bus = new Vue() Vue.component('child',{ data: function(){ return { selfContent: this.content } }, props:{ content:String }, template:'&lt;div @click=&quot;handClick&quot;&gt;{{selfContent}}&lt;/div&gt;', methods:{ handleClick: function(){ this.bus.$emit('change',this.selfContent) } }, mounted:function(){ var this_ = this this.bus.$on('change',function(msg){ this_.selfContent = msg }) } })&lt;/script&gt; 12345678910111213141516171819202122232425262728&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;child&gt; &lt;template slot-scope=&quot;props&quot;&gt; &lt;h1&gt; {{props.item}} &lt;/h1&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.component('child',{ data:function(){ return { list:[1,2,3,4] } }, template:` &lt;div&gt; &lt;ul&gt; &lt;slot v-for=&quot;item of list&quot; :item=item&gt; &lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt; ` })&lt;/script&gt; 属性选择器[class*=’hm-icon-‘] 全局组件、局部组件父子组件传值，非父子组件传值全部样式、局部样式样式绑定、vuecli vue create ui 界面 组件化独立的、可复用的 组件化实现功能模块的复用高执行效率开发单页面复杂应用 如何拆分300行原则复用原则业务复杂性原则 组件化带来的问题组件状态管理(vuex)多组件的混合使用、多页面、复杂业务(vue-router)组件间的传参、消息（props,emit/on ） 风格指南 vue-routervuex 集成 vue单页面、多页面引入Vue.js复杂单页面应用 Vue cli 工具 vue.config 配置 webpack部署 vuecli2 vuecli3 npm root -g 全局安装目录npm i -Snpm i -Dnpm init -y ? = npm init -f vuerouterrouterviewrouterlinkrouter children hash、history $emit :传方法 PubSubJS 订阅发布 1234567891011// 订阅import PubSub from 'pubsub-js'mounted(){ PubSub.subscribe('add',(msg,data)=&gt;{ this.addMenu(data); })} // 发布import PubSub from 'pubsub-js'PubSub.publist('add',menu) vue-resource axios 过渡动画 transition 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to{ opacity: 0; } .v-enter-active, .v-leave-active{ transition: opacity 3s; }&lt;/style&gt;&lt;div id=&quot;root&quot;&gt; &lt;transition&gt; &lt;div v-if=&quot;show&quot;&gt; hello world &lt;/div&gt; &lt;/transition&gt;&lt;/div&gt; 动画 123456789101112131415161718192021222324252627&lt;style&gt; @keyframes bounce-in { 0% { transform: scale(0) } 50% { transform: scale(1.5) } 100% { transform: scale(1) } } .fade-enter-active { transform-origin: left center; animation: bounce-in 1s; } .fade-leave-active { transform-origin: left center; animation: bounce-in 1s reverse; }&lt;/style&gt;&lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;show&quot;&gt; keyframes &lt;/div&gt;&lt;/transition&gt; redirect css router-link-active 路由嵌套 keep-alive 路由传参 模拟数据 vue.config.js derServer before 指令封装 Vue 核心知识Vue.component 缺点1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;ol&gt; &lt;todo-item v-for=&quot;item in groceryList&quot; v-bind:todo=&quot;item&quot; v-bind:key=&quot;item.id&quot; &gt;&lt;/todo-item&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12&quot;&gt;&lt;/script&gt; &lt;script&gt; Vue.component('todo-item', { props: ['todo'], template: '&lt;li&gt;{{ todo.text }}&lt;/li&gt;' }) var app = new Vue({ el: '#app', data: { groceryList: [ { id: 0, text: '蔬菜' }, { id: 1, text: '奶酪' }, { id: 2, text: '随便其它什么人吃的东西' } ] } }) &lt;/script&gt;&lt;/body&gt; 全局定义：强制要求每个 component 中的命名不得重复 字符串模板：缺乏语法高亮，在 HTML 有多行的时候，需要用到丑陋的 \\ 不支持 CSS：意味着当 HTML 和 JavaScript 组件话时，CSS 明显被遗漏 没有构建步骤：限制只能使用 HTML 和 ES5 JavaScript，而不能使用预处理器，如 Pug（formerly Jade）和 Babel .vue 单文件组件的优势 完整语法高亮 CommonJS 模块 组件作用域 CSS 核心概念Vue 组件 = Vue 实例 = new Vue（options） 属性 事件 插槽 组件的组成-属性 推荐组件属性传值写法 12345678910111213141516171819202122232425262728&lt;script&gt; export default{ name: 'PropsDemo', inheritAttrs: false, // title 会自动挂载到元素上 ，false 会取消自动挂载 props:{ name: String, type:{ validator: function(value) { // 这个值必须匹配下列字符串中的一个 return ['success','warning','danger'].includes(value); } }, list:{ type: Array, // 对象或数组必须从一个工厂函数获取 default: () =&gt; [] }, isVisible:{ type: Boolean, default: false }, item: { type: Object, default: () =&gt; ({}), }, } }&lt;/script&gt; 组件的组成-事件 阻止冒泡.stop 修饰符e.stopPropagation(); 组件的组成-插槽 推荐使用 v-slot 双向绑定 和 单向数据流双向绑定：model 的更新触发 view 的更新，同时 view 的更新也会触发 model 的更新。单向数据流：model 的更新触发 view 的更新 双向绑定 or 单向数据流 Vue 是单向数据流，不是双向绑定 Vue 的双向绑定不过是语法糖 Object.defineProper 是用来做响应式更新的，和双向绑定没关系 123456789101112131415&lt;template&gt; &lt;PersonalInfo v-model=&quot;phoneInfo&quot; :zip-code.sync=&quot;zipCode&quot;&gt;&lt;/PersonalInfo&gt; // 最终编译 &lt;PersonalInfo :phone-info=&quot;phoneInfo&quot; :zip-code=&quot;zipCode&quot; @change=&quot;val =&gt; (phoneInfo = val)&quot; @update:zipCode=&quot;val =&gt; (zipCode = val)&quot;&gt;&lt;/PersonalInfo&gt;&lt;/template&gt;&lt;script&gt; export default{ model:{ prop: &quot;phoneInfo&quot;, // 默认 value event: &quot;change&quot; // 默认 input } }&lt;/script&gt; 虚拟 DOM 及 key 属性的作用key 有利于虚拟 DOM 的复用 触发组件的更新数据驱动 数据来源（单向的） 来自父元素的属性 来自组件的状态 data 来自状态管理器，如 Vuex、Vue.observable 状态 data vs 属性 props 状态是组件自身的数据 属性是来自父组件的数据 状态的改变未必触发更新 属性的改变未必触发更新 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div class=&quot;index-container&quot;&gt; {{name}} {{info}} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { this.name = name; return { info: {}, b:1 } }, computed: {}, mounted() {}, methods: { handleDataChange(){ // 不触发组件更新 this.name = 'vue' + Date.now(); this.b = 2; }, // 不触发组件更新 handleAttributesChange(){ this.info.number = 1; } }}&lt;/script&gt; 响应式更新 data return 内的数据，对象属性定义，并且在视图中展现更改时会触发组件的更新。 计算属性 computed 和 监听 watch计算属性 computed 减少模板中计算逻辑 数据缓存 依赖固定的数据类型（响应式数据） 1234567891011121314151617181920// setter 和 getterdata(){ return{ firstName: 'Dell', lastName: 'Lee' } },computed:{ fullName:{ get:function(){ return this.firstName + &quot; &quot; + this.lastName }, // 设置的时候触发 set:function(value){ var arr = value.split(&quot; &quot;) this.firstName = arr[0]; this.lastName = arr[1]; } }} 监听 watch 更加灵活、通用 watch 中可以执行任何逻辑，如函数节流、Ajax 异步获取数据、甚至操作 DOM 12345678910111213watch:{ // 属性监听 &quot;b.c&quot;:function(oldval,val){ } // 深度监听 obj:{ handle:function(oldVal,val){ } deep:true } } 生命周期的应用场景和函数式组件 Vue 生态vue cliVue loadervue routervuexvue ssrPWAVue3 与Vue2.x相比，mount 50% 提升，内存占用小 120%核心代码 + Composition API：13.5kb，最小11.75kb所有 Runtime：22.5kb（Vue2 是 32kb） Vue3.0新特性按需加载 &amp; 组合APITS 支持，新增：Fragment、Teleport、Suspense性能提示 1.3 ~ 2X 按需加载基础： Virtual DOM , 响应式算法非常用功能，按需加载，e.g.v-model，Transition Compiler 原理篇静态 Node 不再作更新处理（hoistStatic -&gt; SSR 优化）静态绑定的class， id 不再作更新处理结合打包 Hint，进行更新分析（动态绑定）事件监听器 Cache 缓存处理 （cacheHandlers）hoistStatic 自动针对多静态节点进行优化，输出字符串按需加载 setuptoRefs生命周期 prettier-eslint Vue2.x升级90%以上代码可与vue2.0复用Composition API 作为新增 API 不会影响旧的逻辑代码Mixin不再推荐 新增功能Fragment —— 不受根节点限制，渲染函数可接受 ArrayTeleport —— 类似 Portal ，随用随取，e、g弹窗、ActionsSuspense —— 嵌套的异步依赖，e、g、async、setup() 更好的 Typescript 支持更好的静态检查更好的编程体验，类型推导，包括 Props单模板文件进行类型检查 + 自动补全 更好的 Vue 生态利用自定义渲染引擎、小程序 Runtime 跟进NativeScript、WebGL（Vugel）、Three.js自家生态：Vuex、VueRouter、Cli、DevTools 更新建议小规模尝试，小项目尝试Vue2.x 项目如果已经稳定，不推荐更新 Vite 开发Vite 是一个 HTTP 服务器，特殊的地方： 可以在单文件中书写 ES6语法 支持热更新（请求的内容才会被打包/更新） Rollup 打包 1234yarn create vite-app &lt;project-name&gt;cd &lt;project-name&gt;yarnyarn dev @vue/cli-plugin-pwa 安装 1vue add @vue/pwa 12// src/main.jsimport './registerServiceWorker' 生成文件src/registerServiceWorker.jspublic/robots.txtpublic/img/icons/ 没生成以上文件卸了插件重新装。 该插件加入的 service worker 只会在生产环境下 (即只在运行 npm run build 或 yarn build 时) 开启。在开发环境下开启 service worker 并不推荐，因为它会导致之前的缓存资源被使用而未包含最新的本地改变。取而代之的是，在开发环境下引入 noopServiceWorker.js。这个 service worker 文件会重置之前在相同主机和端口注册过的任何 service worker，有效地达到了 no-op 的目的。如果你需要本地测试一个 service worker，构建应用并在构建目录运行一个简单的 HTTP 服务器。这里推荐使用浏览器隐私模式以避免浏览器缓存带来的问题。 我想要在 手机上测试下，但是pwa 只能在 localhost 或者 http 下才行，下载 Openssl 生成证书，但是也不行，浏览器不信任。 mkcert 也可以生成证书，pc端 浏览器是正常的，但是移动端浏览器是不信任的。最后花生壳解决。 pwa 入门与实践使用的是 HTTP Server serve 静态文件服务 1serve -s dist vue.config.js 配置 1234567891011121314151617181920pwa: { name: '豆瓣app', themeColor: '#4DBA87', msTileColor: '#000000', appleMobileWebAppCapable: 'yes', appleMobileWebAppStatusBarStyle: 'black', iconPaths: { favicon32: './public/img/icons/favicon-32x32.png', favicon16: './public/img/icons/favicon-16x16.png', appleTouchIcon: './public/img/icons/apple-touch-icon-152x152.png', maskIcon: './public/img/icons/safari-pinned-tab.svg', msTileImage: './public/img/icons/msapplication-icon-144x144.png' }, workboxPluginMode: 'InjectManifest', // 需要推送 Push 没得选 workboxOptions: { swSrc: './public/service-worker.js', // 本地sw.js相对路径 importWorkboxFrom: 'disabled', exclude: [/\\.html$/, /\\.css.map$/, /sw.js$/] } } service-worker.js 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const CACHE_NAME = 'cache_v1' // 定义缓存名称// 缓存资源self.addEventListener('install', async event =&gt; { // 开启一个 cache，得到 cache 对象 // cache 存储资源 const cache = await caches.open(CACHE_NAME) await cache.addAll([ '/', '/manifest.json', '/img/7acb0a46f21fbe096b63cbbd84291b338744ebf8074a.6947db6b.jpg', '/css', '/js' ]) await self.skipWaiting() // 等待 spkipWaiting 结束，才进入到 active})// 删除旧资源self.addEventListener('activate', async event =&gt; { const keys = await caches.keys() // 清除旧的资源，获取所有资源的 key keys.forEach(key =&gt; { if (key !== CACHE_NAME) { caches.delete(key) } }) await self.clients.claim() // 立即受控})// 拦截请求self.addEventListener('fetch', async event =&gt; { const req = event.request const url = new URL(req.url) // 只缓存同源内容 if (url.origin !== self.origin) { return } if (req.url.includes('/api')) { event.respondWith(networkFirst(req)) } else { event.respondWith(cacheFirst(req)) }})// 网络优先async function networkFirst(req) { const cache = await caches.open(CACHE_NAME) try { // 先从网络读取最新的资源 const fresh = await fetch(req) // 获取数据 更新缓存 cache.put(req, fresh.clone()) return fresh } catch (e) { // 去缓存中读取 const cached = await cache.match(req) return cached }}// cache 优先，一般适用于静态资源async function cacheFirst(req) { const cache = await caches.open(CACHE_NAME) const cached = await cache.match(req) if (cached) { return cached } else { const fresh = await fetch(req) return fresh }} 开发工具（开发中有用的库或UI组件）awesome-vue：vue相关的资源集合。 sortablejs：可拖拽的列表。 lockr：用于localStorage的最小API包装器。 lodash：Lodash消除了处理数组，数字，对象，字符串等的麻烦，从而使JavaScript变得更容易。 moment：moment 是一个轻量级的JavaScript date库，用于解析、验证、操作和格式化日期。 dayjs：Moment.js 的 2kB 轻量化方案，拥有同样强大的 API。 NativeScript： JavaScript访问本机 API。 cordova：使用HTML、CSS、JS进行移动 App 开发多平台共用一套代码。 vue-currency-filter：一个货币过滤器别看他的 star 少，但是他确实解决我的问题，他能帮助我加上千位符，并且加上小数点后两位还可以加货币符号，对于我这个菜鸟来说他太棒了。 Vue-Socket.io：Vuejs和Vuex的Socket.io实现 NProgress：纳米级进度条。带有逼真的le流动画，以说服您的用户正在发生某些事情！ vue-progress-path：进度条。 vue-awesome-swiper：轮播图。 vue-sticky-nav:用于移动端的吸顶导航组件。 v-charts：基于 Vue2.0 和 ECharts 封装的图表组件。但看到 star 数和好多开源项目都有使用，应该不会太差。 vuex-persistedstate：在页面重新加载之间坚持并重新补充您的Vuex状态。 RVerify.js:轻量级的图像旋转验证插件。 vue-monoplasty-slide-verify:一个Vue插件以滑动验证。 vue-drag-verify：这是一个Vue组件，可以滑动以解锁以进行登录或注册。这用于保护您的Web应用程序免受机器人攻击。 zx-verify：图形验证码组件。 vue-virtual-scroller：快速滚动，可浏览任意数量的数据。 v-hotkey：快捷键绑定到组件上 vue-awesome-swiper：vue 轮播组件 vue-core-image-upload：用于图像裁剪和上传 vue-quill-editor：富文本编辑器 Vue.D3.tree：Vue组件，用于基于D3.js布局显示树 liquor-tree：基于Vue.js的树组件 pdf-vue：vue.js pdf查看器 pdfjs-dist：PDF.js库的通用构建。 mint-ui：vue 的移动 UI 组件库。 vant：基于 Vue 构建的轻量级移动 UI 组件。 vuetify：Material 样式的 Vue UI 组件库。 ant-design-vue：基于蚂蚁设计和 Vue 的企业级 UI 组件。 DataV：Vue 大屏数据展示组件库。 开源项目vue2-happyfrivue-sellvue2-elmvue2-element-touzi-adminvue-element-admind2-adminvuxuniapp-admin vue-cli4-config：vue-cli4配置vue.config.js持续更新 iview-admin：基于 iView 的 Vue 2.0 管理管理系统模板。 vue2-manage：基于 vue + element-ui 的后台管理系统。 vue2-demo：vue 基于 Genesis + TS + Vuex 实现的 SSR demo。 genesis：基于 Vue SSR 的微型前端、微型服务。 vue-manage-system：基于vue + element的后台管理系统解决方案。 bootstrap-vue：BootstrapVue 为 Vue 提供最全面的。 vue2-management-platform：vue2.0+ elementUI 后台管理平台 vuepress：简约的 Vue 供电静态站点生成器。好多人用它做博客。 vue-h5-template:基于 vue-cli4.0 + webpack 4 + vant ui + sass+ rem 适配方案+axios 封装，构建手机端模板脚手架。 ant-design-vue-pro：开箱即用的中台前端/设计解决方案。 源码解析vue：vue源码逐行注释分析+40多m的vue源码程序流程图思维导图 （diff部分待后续更新）。 learnVue：Vue.js源码分析。 基于vue的可视化编辑器Vue-Layout：基于UI组件的Vue可视化布局工具。vue-design：使用Vue和Electron成为最佳的网站可视化构建器。vue-page-designer：Vue组件，用于拖放来设计和构建移动网站。X-Page-Editor-Vue：基于 Vue 的可视化布局编辑器插件。 可视化编辑pl-drag-template：一个h5可视化编辑器项目quark-h5：一个h5可视化编辑器项目vue-json-schema-form：可视活动编辑器、h5编辑器。 webpack 构建 Vue 应用运行项目可能出现的错误 1234567output：{ publicPath: '/public/'}historyApiFallback: { index: '/public/index.html'} 升级 webpack 4 123456789101112131415npm uninstall webpack webpack-dev-server npm i webpack webpack-dev-server -D // webpack 4.29.0 webpack-dev-server 3.1.14npm install -g babel-upgrade // 升级使用npx babel-upgrade --write // 写入升级配置删除重复配置npm inpm i webpack-cli -D加入 mode 配置项将 loader 全部卸载升级npm i vue-loader@14.2.4 -Dnpm i webpack@4.28.4 -Dnpm i @babel/plugin-proposal-object-rest-spread -Dnpm i vue-loader@15.6.2 -D 搭建 Vue 后台vue-element-admin 手摸手系列目录结构12345678910111213141516171819202122232425262728├── build // 构建相关 ├── config // 配置相关├── src // 源代码│ ├── api // 所有请求│ ├── assets // 主题 字体等静态资源│ ├── components // 全局公用组件│ ├── directive // 全局指令│ ├── filtres // 全局 filter│ ├── icons // 项目所有 svg icons│ ├── lang // 国际化 language│ ├── mock // 项目mock 模拟数据│ ├── router // 路由│ ├── store // 全局 store管理│ ├── styles // 全局样式│ ├── utils // 全局公用方法│ ├── vendor // 公用vendor│ ├── views // view│ ├── App.vue // 入口页面│ ├── main.js // 入口 加载组件 初始化等│ └── permission.js // 权限管理├── static // 第三方不打包资源│ └── Tinymce // 富文本├── .babelrc // babel-loader 配置├── eslintrc.js // eslint 配置项├── .gitignore // git 忽略项├── favicon.ico // favicon图标├── index.html // html模板└── package.json // package.json views 和 api两个模块一一对应，方便维护。公共的 api 单独放置。 components放置全局公用组件，页面级组件建议放置各自的 views 文件下。 store不要为了用 vuex 而用 vuex！ alias为文件夹添加别名 ESLintESLint 配置eslint规则 封装 axios多环境前后端交互跨域问题corsdev 环境可以通过 webpack-dev-server的proxy来解决，nginx反代理 前后端的交互问题swagger 是一个REST APIs文档生成工具 前端自行 mockmock servermockjs + rapeasy-mock 字体图标iconfont router-view优化需要利用 pm2 进行 nodejs 生命周期的管理webpack dllAggressiveSplittingPlugin 权限验证 登录：当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个 token，拿到 token 之后（我会将这个 token 存贮到cookie中，保证刷新页面后能记住用户登录状态），前端会根据 token 再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。 权限验证：通过 token 获取用户对应的 role，动态根据用户的 role 算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。 上述所有的数据和操作都是通过vuex全局管理控制的。(补充说明：刷新页面后 vuex的内容也会丢失，所以需要重复上述的那些操作)接下来，我们一起手摸手一步一步实现这个系统。 Vue 思考题 子组件为何不可以修改父组件传递的 Prop,如果修改了，Vue 是如何监控到属性的修改并给出警告的？ this.$emit 的返回值是什么？ 相同名称的插槽是合并还是替换？ 为什么不能用 index 作为 key ？ 数组有哪些方法支持响应式更新，如不支持如何处理，底层原理如何实现的？ MVVM 模式MVP 模式 Model 模型层 View（视图层） Presenter(控制器) 12345678910111213141516171819202122232425262728293031&lt;!-- jQ 演示 MVP 设计模式 --&gt;&lt;div&gt; &lt;input id=&quot;input&quot; type=&quot;text&quot;/&gt; &lt;button id=&quot;btn&quot;&gt;提交&lt;/button&gt; &lt;ul id=&quot;list&quot;&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; function Page(){ } $.extend(page.prototype,{ init: function(){ this.bindEvents() }, bindEvents: function(){ var btn = $(&quot;#btn&quot;); btn.on('click',$.proxy(this.handleBtnClick,this)) }, handleBtnClick: function(){ var inputElem = $(&quot;#input&quot;); var inputValue = inputElem.val(); var ulElem = $(&quot;#ul&quot;); ulElem.append('&lt;li&gt;'+inputValue+'&lt;/li&gt;') inputElem.val(&quot;&quot;) } }) var page = new Page(); page.init()&lt;/script&gt; MVVM 模式Model 模型层 View（视图层） VM(控制器) 相关资料Vue.js 从入门到精通（含Vue3.0正式版）Vue.js从入门到全栈开发 [视频]vue2.5入门√ [视频]3小时速成 Vue2.x 核心技术√ [视频]动力学院vue 教程√ [视频]vue.js 教程√ [视频]vue-cli全集√ [视频]Vue+Webpack打造todo应用√ [视频]【黑马程序员】VUE进阶-从0到1搭建UI组件库（1-3） [视频]Vue2.5-2.6-3.0 开发去哪儿网App 从零基础入门到实战项目开发[视频]从0开始搭建大型Vue项目 p12 [视频]vue后台管理系统[视频]通俗易懂的Vue +Elment-UI后台管理系统[视频]Vue之父尤雨溪深度解读Vue3.0开发思路附 在线视频 Prop√.sync 修饰符√sync修饰符示例√ cordova+vue 项目打包成Android（apk）应用√ 关于cordova+vue打包apk文件无法访问数据接口√ CORDOVA+VUE打包APK文件无法访问数据接口√ 谈谈 Vue 开发过程中用到的插件√Vue style里面使用@import引入外部css, 作用域是全局的解决方案√借助axios的拦截器实现Vue.js中登陆状态校验的思路√不吹不黑也不撕，我们就简简单单谈谈Vue√为什么Vue中的slot不能应用v-show指令√困扰99%前端程序员的Vue问题，全在这了（含代码）√使用vue开发移动端管理后台√Vue 项目棘手问题的解决方案 √Vue应用部署到服务器的正确方式√Vue的全局组件√Error: Node Sass version 5.0.0 is incompatible with ^4.0.0√错误：gyp ERR! find Python√解决：npm install报错gyp ERR&amp;！ stack Error： Can‘t find Python executable python√Sass尚不支持您当前的环境:Windows 64位√vue-cli中 如何引入全局的js√ 如何在自定义的js文件中获取vuex中state实时变化的值√ vue中如何利用js如何检测网络状况，监听网络状态√ pdf.js实战，含水印、电子签章解决方案√ 45个实用Vue.js 开源项目√ 关闭ESlint 语法检测配置方法√ vue中computed计算属性传入参数√ vue用命令直接修复ESLint√ vue中实现回到顶部功能√ vue使用Moment插件格式化时间√ vue-cli4最新版中怎么引入jQuery√ vue引入zTree入门√ 关于 element ui vue-element-admin 如何设置三级路由，只显示一个子菜单√ element el-table resetfields() 不生效√ vue项目elementUI预览图片√ elementUI table组件会出现空白部分，怎么解决√ Element-UI的点击按钮实现图片预览功能√ Vue项目打包部署总结 分享8个非常实用的Vue自定义指令 Vuex Module√ 手摸手，带你用vue撸后台 系列一（基础篇）√ vue 长按与点击事件√vue移动端在线签名√vue在移动端实现电子签名手写板√使用vue实现一个电子签名组件√ 模仿element-ui封装vue组件库（一）√模仿element-ui封装vue组件库（二）√模仿element-ui封装vue组件库（三）√ natapp：内网穿透工具√ 花生壳：内网穿透工具√ Windows安装使用Openssl√ 内网穿透的几种方式 FastTunnel frp openssl基本原理 + 生成证书 + 使用实例 mkcert：生成证书。 如何在本地自建 ssl 证书给 localhost 使用并通过 Chrome 和 Safari 浏览器的验证？ @vue/cli-plugin-pwa√ 基于vue-cli3创建的项目引入PWA（一）√ 基于vue-cli3创建的项目引入PWA（二）√ 浅析 vue-router 源码和动态路由权限分配vue3源码解析和最佳实践10个简单的技巧让你的 vue.js 代码更优雅 从零开始搭建一个简单的基于webpack的vue开发环境让Jenkins自动布署你的Vue项目 Vue源码系列-Vue中文社区 [代码]使用vue实现一个电子签名组件 代码包教包会，手摸手使用Vue3重构vue2项目（实用）egg+vue+mongodb实践开发在线文档管理平台——水墨文档 Weex demo 网易严选Weex UiWeex实战开发Weex 入门这一篇就够了 最全Vue知识点（基础到进阶，覆盖vue3）前端黑科技！结合 Vue 让首页秒开 一枚程序媛，献上开箱即用的 vue+vant 方案element-ui的upload组件的clearFiles方法的调用移动端吸顶导航组件的实现Vue UI库ElementUI 组件库之外，供我们选择的 Vue 组件库还有很多！Vue3开源组件库，今天“它们”来了Vue 前端可视化活动编辑器__Vue.jsVue + Koa从零打造一个H5页面可视化编辑器——Quark-h5 Vue中组件之间8种通信方式，值得收藏vue组件间通信六种方式（完整版）数据动态过滤技巧在 Vue 项目中的实战9个适用于React，Vue，Angular的Bootstrap UI组件库Vue 项目性能优化 — 实践指南（网上最全 / 详细）vue全家桶开发的一些小技巧和注意事项vue / react的UI库都在用的几个DOM API揭秘vue/react组件库中5个”作者不造的轮子”vue踩坑总结 &amp; 优化点NutUIVue 项目性能优化 — 实践指南（网上最全 / 详细）尤雨溪自述：打造Vue 3.0背后的故事搭建一个vue-cli4+webpack移动端框架（开箱即用） Vue 中多个组件可以共享数据和方法 Mixin 的用法vue全家桶开发的一些小技巧和注意事项Vue这些修饰符帮我节省20%的开发时间10个Vue开发技巧助力成为更好的工程师(二) 讲道理：为什么 Vue 中不要用 index 作为 key？（diff 算法详解）实现微前端，你需要了解的 Vue Genesis 渲染器封装 axios 拦截器实现用户无感刷新 access_token总结我对Vue项目上线做的一些基本优化10个简单的技巧让你的 vue.js 代码更优雅 Vue3.0前置，还不知道这些就来不及啦Vue+Node+高德地图+Echart做一款出行可视化全栈webappVue最全知识点，面试必备（基础到进阶，覆盖vue3.0，持续更新整理，欢迎补充讨论）10个Vue开发技巧助力成为更好的工程师vue+router+axios 实现后台管理系统登录拦截(权限控制) 【Vue3官方教程】🎄万字笔记 | 同步导学视频 总结我对Vue项目团队开发的一些基本配置封装分享","link":"/2020/08/04/Blog-about-learning-139/"},{"title":"PWA 从入门到实践开发","text":"了解 PWAPWA（Progressive Web App）渐进式 Web 应用程序Webpack、Rollup 等打包工具Babel、PostCss 等转译工具Typescript 等可转编译为 JavaScript 的编程语言React 、Angular、Vue等现代 web 前端框架同构 JavaScript 应用 Web 应用体验依然不佳 网页资源下载带来的网络延迟 Web 应用依赖于浏览器作为入口 没有好的离线使用方案 没有好的消息通知方案 PWA（Progressive Web App） 显著提高应用加载速度 Web 应用可以在离线环境下使用 Web 应用能像原生应用一样被添加到主屏 Web 应用能在未被激活时发起推送通知 Web 应用与操作系统集成能力进一步提高 PWA 和原生 App 的差异 ‘’ 安装方式 访问入口 通知服务 开发迭代 PWA 在线、自动安装 图标、URL 通知服务 Web，一次开发，多平台可用，无须发版 普通 NavtiveApp 应用商店 图标、相关调起 可通知服务 分平台，需发版 PWA 的支持情况 Chrome、Oprea、Firefox 都已经实现了 PWA 所需的所有关键技术，Edge所有特性都已经处于【正在开发中】的状态。 Safari，尤其是在 iOS 上，四个关键 API 都未得到支持，而且由于平台限制，第三方浏览器也无法在 iOS 上支持。 庆幸的是 Service Worker 与 Web App Manifest 纷纷列入了【正在考虑】的API 中，相信在不久的将来在 iOS 上也能体验 PWA。 PWA 特性 渐进增强 响应式用户界面 不依赖网络连接 类原生应用 持续更新 安全 可发现 再次访问 可安装 可连接性 PWA关键技术 Web APP Manifest Service Worker Cache Storage API Push Notification Web APP ManifestWeb APP Manifest，即通过一个清单文件向浏览器暴露 web 应用的元数据，包括名字、icon的 URL 等，以备浏览器使用，比如在添加至主屏或推送通知时暴露给操作系统，从而增强 web 应用与操作系统的集成能力。 可以添加到桌面，有唯一的图标和名称 有启动时界面，避免生硬的过渡 隐藏浏览器相关UI,比如地址栏等 使用 Web APP Manifest 在项目目录下创建一个 manifest.json 文件 在 index.html 中引入 manifest.json 文件 在 manifest.json 文件中提供常见的配置 需要在 https 协议 或者 http://localhost 下访问项目 1&lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot;&gt; 通过 http-server 开启本地服务，访问 index.html 文件 常用属性 name：用于指定应用的名称，安装横幅提示的名称，和启动画面中的文字。 short_name：应用的短名称，用于主屏幕显示 icons：用于指定可在各种环境中用作应用程序图标的图像对象数组，144×144 scope：定义了 web 应用的浏览作用域，比如作用域外的 URL 就会打开浏览器而不会在当前 PWA 里继续浏览。 start_url：定义了一个 PWA 的入口页面。 orientation：锁定屏幕旋转 theme_color/background_color：主题色与背景色，用于配置一些可定制的操作系统 UI 以提高用户体验，比如 Android 的状态栏、任务栏等。 display：用于指定 web app 的显示模式 Service Worker 一旦被 install，就永远存在，除非被手动 unregister 用到的时候可以直接唤醒，不用的时候自动睡眠 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态） 离线内容开发者可控 必须在 HTTPS 环境下才能工作 异步实现，内部大都是通过 Promise 实现 演变过程 LocalServer Application Cache Service Worker Service Worker 生命周期 install 事件会在 service worker 注册成功的时候触发，主要用于缓存资源 activate 事件会在 service worker 激活的时候触发，主要用于删除旧的资源 fetch 事件会在发送请求的时候触发，主要用于操作缓存或者读取网络资源 如果 sw.js 发生了改变，install 事件会重新触发activate 事件会在 install 事件后触发，但是如果现在已经存在 service worker 了，那么就处于等待状态，直到当前 service worker 终止。可以通过 self.skipWaiting() 方法跳过等待，返回一个 promise 对象。可以通过 event.waitUntil() 方法扩的参数是一个 promise 对象，会在 promise 结束后才会结束当前生命周期函数，防止浏览器在异步操作之前流停止了生命周期。service worker 激活后，会在下一次刷新页面的时候生效，可以通过 self.clients.claim() 立即获取控制权。 Service Worker 使用 在 window.onload 中注册 service worker，防止与其他资源竞争 navigator 对象中内置 service worker 属性 service worker 在老版本的浏览器中不支持，需要进行浏览器兼容 if(‘serviceWorker’ in navigator){} 注册 service worker navigator.serviceWorker.register(‘./sw.js’) ，返回一个 promise 对象 12345678910111213141516171819202122232425262728293031323334353637window.onload = function(){ if('serviceWorker' in navigator){ navigator.serviceWorker.register('./sw.js').then(resitration =&gt; {console.log(resitration)}) .catch(err =&gt; { console.log(err); }) }}// sw.js// self.addEventListener('install',event)=&gt;{}self.oninstall = (e) =&gt; { // 会让 service worker 跳过等待，直接进入 activate 状态 // 等待 skipWaiting 结束，才进入到 activate e.waitUntil(self,skipWaiting()); e.waitUntil( caches.open('installation').then(cache =&gt; cache.addAll([ './', './styles.css', './script.js' ])) )}self.onactivate = (e) =&gt;{ // 表示 service worker 激活后，立即获取控制权 // self.clients.claim(); e.waitUntil(self.clients.claim());}// 使用离线缓存self.onfetch = (e)=&gt;{ const fetched = fetch(e.request); const cached = caches.match(e.request) e.respondWith( fetched.catch(_ =&gt; { cached}) )} Service Worker 缓存策略 Cache StoragecacheStorage：接口表示 Cache 对象的存储。配合 service worker 来实现资源的缓存 cache 基本使用caches api：类似于数据库的操作 caches.open(cacheName).then(function(cache){})：用于打开缓存，返回一个匹配 cacheName 的 cache 对象的 promise，类似于连接数据库 caches.keys()：返回一个 promise 对象，包括所有的缓存的 key（数据库名） caches.delete(key)：根据 key 删除对应的缓存（数据库） cache 对象常用方法（单条数据的操作） cache 接口为缓存的 Request/Response 对象提供存储机制 cache.put(req,res)：把请求当成 key，并且把对应的响应存储起来 cache.add(url)：根据 url 发起请求，并且把响应结果存储起来. cache.addAll(url)：抓取一个 url 数组，并且把结果都存储起来 cache.match(req)：获取 req 对应的 response 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 引入了引用程序清单文件 --&gt; &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello pwa&lt;/h1&gt; &lt;script&gt; window.addEventListener('load', async () =&gt; { if ('serviceWorker' in navigator) { try { const registration = await navigator.serviceWorker.register( './sw.js' ) console.log('注册成功', registration) } catch (e) { console.log('注册失败') } } }) /* 如果页面一进来，我们发下用户没有联网，给用户一个通知 */ if (Notification.permission === 'default') { Notification.requestPermission() } if (!navigator.onLine) { new Notification('提示', { body: '你当前没有网络，你访问的是缓存' }) } // offline: 断线 window.addEventListener('online', () =&gt; { new Notification('提示', { body: '你已经连上网络了，请刷新访问最新的数据' }) }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516// manifest.json{ &quot;name&quot;: &quot;豆瓣APP-PWA&quot;, &quot;short_name&quot;: &quot;豆瓣APP&quot;, &quot;start_url&quot;: &quot;/index.html&quot;, &quot;icons&quot;: [ { &quot;src&quot;: &quot;images/logo.png&quot;, &quot;sizes&quot;: &quot;144x144&quot;, &quot;type&quot;: &quot;image/png&quot; } ], &quot;background_color&quot;: &quot;skyblue&quot;, &quot;theme_color&quot;: &quot;yellow&quot;, &quot;display&quot;: &quot;standalone&quot;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// sw.js// 主要就是缓存内容const CACHE_NAME = 'cache_v2'self.addEventListener('install', async event =&gt; { // 开启一个cache, 得到了一个cache对象 const cache = await caches.open(CACHE_NAME) // cache对象就可以存储的资源 // 等待cache把所有的资源存储起来 await cache.addAll(['/', '/images/logo.png', '/manifest.json', '/index.css']) await self.skipWaiting()})// 主要清除就的缓存self.addEventListener('activate', async event =&gt; { // 会清除掉旧的资源, 获取到所有的资源的key const keys = await caches.keys() keys.forEach(key =&gt; { if (key !== CACHE_NAME) { caches.delete(key) } }) await self.clients.claim()})// 注释：fetch事件会在请求发送的时候触发// 判断资源是否能够请求成功，如果能够请求成功，就响应成功的结果，如果断网，请求失败了，读取caches缓存即可self.addEventListener('fetch', async event =&gt; { // 请求对象 // 给浏览器响应 event.respondWith(networkFirst(event.request))})// 网络优先async function networkFirst(req) { try { // 先从网络读取最新的资源 const fresh = await fetch(req) return fresh } catch (e) { // 去缓存中读取 const cache = await caches.open(CACHE_NAME) const cached = await cache.match(req) return cached }} Push Notification Push API 的出现则让推送服务具备了向 web 应用推送消息的能力 Push API 不依赖 web 应用与浏览器 UI 存活，所以即使是在 web 应用与浏览器未被用户打开的时候，也可以通过后台进程接受推送消息并调用 Notification API 向用户发出通知。 Notification.permission 可以获取当前用户的授权情况 Default：默认的，未授权 Denied：拒绝的，如果拒绝了，无法再次请求授权，也无法弹窗提醒 Granted：授权的，可以弹窗提醒 通过 Notification.requestPermission() 可以请求用户的授权 通过 **new Notification(‘title’,{body:””,icon:””})**可以显示通知 在授权通过的情况下，可以在 service worker 中显示通知 self.registration.showNotification(‘你好’,{body:’msg’}) 12345678910111213141516// sw.jsself.addEventListener('push',event =&gt; { event.waitUntil( // process the event and display a notification. self.registration.showNotification('Hey'); )})self.addEventListener('notificationclick',event =&gt; { // Do something with the event event.notification.close();})self.addEventListener('notificationclose',event =&gt; { // Do something with the event}) 常见的缓存策略 对于不同的数据，需要不同的缓存策略 本地的静态资源，缓存优先 对于需要动态更新的数据，网络优先 避免缓存跨域资源 由于更新机制的问题，如果 service worker 缓存了错误的结果，将会对 web 应用造成灾难性的后果。 响应状态码为200；避免缓存304、404、50×等常见结果。 响应类型为 basic 或者 cors;即只缓存同源、或者正确地跨域结果；避免缓存错误的响应和不正确的跨域请求响应。 相关资料[视频]PWA 入门√[视频]PWA-3小时带你实现渐进式WebAPP√深入浅出pwa√Chrome PWA应用 安装和卸载√Workbox Webpack插件√PWA之 workbox 学习√ 渐进式 Web 应用（PWA）下一代 Web 应用模型 — Progressive Web AppPWA系列 – 分享PWA在阿里体系内的实践经验PWA 介绍及快速上手搭建一个 PWA 应用深入浅出 pwa傻傻分不清的 ManifestPWA 介绍及快速上手搭建一个 PWA 应用十分钟让你完成一个可以安装到桌面的网页饿了么的 PWA 升级实践PWA 在饿了么的实践经验现代化 Web 开发实践之 PWA 源码 黑马 H5豆瓣 PWA 开源servehttp-servervue-cli3 PWAworkbox通用 PWA 构建器基于 Webpack 模板的 Vue-Cli 的 PWA 模板awesome-pwa 集合使用VUE.JS构建实时PWA关于Nuxt.js的零配置PWA解决方案Vue店面 PWAdemo-progressive-web-app项目不维护了 百度 基于vue 的 pwa 解决方案 Lavas","link":"/2020/08/04/Blog-about-learning-140/"},{"title":"微信小程序开发入门与实践","text":"内容简介整本书围绕着 Orange Can 项目展开，讲解 API、组件用法、技巧以及常见的误区说明并附带一些小程序开发的经验。 Orange Can 项目分为 文章阅读 文章列表 文章详情 评论 电影资讯 设置 通过 Orange Can 你将学会 swiper组件的裁剪模式 image组件的裁剪模式 缓存的使用技巧 列表渲染 数据绑定 模板 对小程序页面的生命周期有大致了解 如何调用服务器数据 template 模板的使用技巧 获取硬件设备信息、罗盘与重力感应的应用 扫描二维码 用户登录、用户信息校验、解析用户加密数据、获取用户openId、发送模板消息、微信支付 音乐播放、录音、分享等 通过 Orange Can 你将有能力构建出一个内容型的小程序应用。本书还提供部分服务器的PHP代码，主要供用户登录、校验、解析加密数据、模板消息、微信支付等功能调用。 推荐序本书作者：雷磊推荐序撰写人：石墨文档联合创始人 陈旭 前沿作者的平台信息微信公众号：小楼昨夜又秋风知乎专栏：小楼昨夜又秋风知乎ID：七月在夏天 本书源码开发者社区 第1章 微信小程序简介1.1 什么是微信小程序小程序的特性 小程序没有“官方的”应用市场 小程序不能被关注，小程序没有粉丝这个概念。 小程序没有群发消息和主动推送消息的能力。 微信中没有明显的小程序入口，但是发现有一个【小程序】栏，它会记录用户曾经用过的历史小程序 获取和使用小程序的途径 扫描二维码、有限能力的搜索、群聊分享、小程序栏 长按进入小程序 小程序名称不能和公众号相同 有一定的分享能力，可以分享给朋友和群聊，但不能分享到朋友圈 同一个公司的公众号和小程序可以相互发现。公众号里可以看到该公司的小程序，同时，小程序里也可以看到该公司的公众号。 1.2 什么类型的应用适合用小程序开发“简单的”、“低频的”、“对性能要求不高的”应用适合用小程序来开发。小程序特别适合做线下的场景化应用，官方的一切措施都是为了将小程序导向线下。 1.3 小程序与原生App（iOS、Android）的优劣对比Web App相对于其他两种App，Web App具有开发简单、高效，更新灵活、跨平台，大量的网页应用稍作调整即可放在移动端运行。但缺点与优点并存，Web App性能、体验极差（对，是极差），无法使用照相机、系统通知、本地缓存等原生特性。 Native AppNative App具有性能、体验非常良好，组件支持完善、接口丰富等特点。但Native App最大的缺点在于，不能跨平台，有多少个平台就要开发多少个版本，现在主要有iOS和Android两个主流平台。 Hybrid AppHybrid App具有接近于Native App的体验、开发效率高、跨平台等特性。 相比于Native App，小程序具有Hybrid App的一些优势：跨平台（对于iOS和Android两个平台只需要开发一套程序）。具备接近于Native App的体验（注意只是接近）。对原生组件有访问能力。具备缓存能力。上手容易，开发逻辑较为简单。 小程序独有的特点 小程序在设计时就做了很多约定式的规范：比如简单的文件结构、默认的文件命名、内置好的Tab栏与导航栏等，这让小程序的初学者更容易上手和理解。 开发环境很干净，你无须安装任何除开发工具外的其他软件。当然现在这个工具简陋的可怕，很多常见的IDE功能都不具备，但相比于其他Hybrid App的环境要求，小程序这点真的很棒。 发布和部署流程非常简单，几乎是“傻瓜式”，点击几下就可以将应用发布到腾讯云。 小程序之所以在公布后引起了互联网圈儿和开发者们极高的关注度，原因并不在技术上，无数开发者、创业者看中的是微信天然的关系链与获客能力。这也是小程序最大的优势。 小程序独有的缺点： 小程序为了简化复杂性，做了一些UI上的设计规范，确实方便了很多对UI要求不高的应用。但这也限制了那些对UI要求极高的产品发挥。 小程序很遗憾地不支持现有的HTML DOM结构，而是自己给出了一系列的组件，造就了一个封闭的开发环境，这直接导致了现有的经典JavaScript框架、类库都无法使用。小程序现在的生态几乎是荒芜一片，等待着开发者们去耕耘（挑战与机遇并存，正因为没有，才有机会）。如果你想用小程序实现一组图形来展现股票或者天气的曲线，目前来看，相当烦琐。你无法使用经典的echart或者highchart，你只能自己用Canvas来一点点地绘制。 截止到笔者编写本书时，小程序还不支持WebView，这是相当头疼的一个问题。 小程序只实现了模板化并没有实现自定义组件。通常希望把这个组件的标签、样式以及业务逻辑打包在一起，然后可以放在项目中多个地方使用。外部客户端调用组件时，只需要传入组件所需要的参数，由组件自己来完成数据获取、转化、绑定并和UI层通信等操作。 1.4 小程序会淘汰原生App吗不会。小程序的定位也非常明确——做低频和业务逻辑不复杂的应用，原生App与小程序之间更多地将是一种互补的关系，绝对谈不上取代。 1.5 Web前端的未来从信息的角度讲，移动端主要负责信息的输出，而PC端主要负责信息的输入。 不可或缺的 Web前端开发者： 混合式App是现在的主流App，一个App很难只用Objective-C或者Java来开发，必然会有Web技术介入。 大多数移动端应用也都有一个对应的Web网站。 现在的公司做营销和推广都离不开微信，无论是H5页面还是做微信服务号、企业号都是纯粹的Web技术。 1.6 Web前端开发者与小程序微信小程序更多的是App或者Web网页的另一个流量入口，但绝不会替代原生App或者Web网页（至少很长一段时间内是这样，未来小程序怎么发展还有待观察）。正如我们描述的微信对现在公司营销的重要性，小程序也将成为Web前端开发者应该掌握的一门技术。 1.7 MINA框架与微信小程序信小程序并不是一项技术或者一个框架，微信小程序是一个生态，与之对应的应该是iOS生态和Android生态，其中微信小程序又与iOS生态极为相似，它们都非常封闭，而且审核非常严格（微信小程序的审核比苹果还要严格）。而MINA是小程序的一个框架，它提供了小程序运行所需要的接口、模型和机制。 1.8 微信小程序beta测试版测试版本的概念非常重要，可以让开发者预先知道下个版本的更新内容，建议开发者应该第一时间使用测试版本测试一下自己的小程序。 第2章 小程序环境搭建与开发工具介绍2.1 微信Web开发者工具下载及安装微信Web开发者工具 AppID代表微信小程序的ID号，必须拥有微信小程序账号才可以申请这个ID号。 2.3.1 编辑选项卡wifi 一栏，可以选择不同的网络环境。 2.3.2 调试选项卡【区域1】模拟器同编辑选项卡功能一样。【区域2】展示了小程序经编译后生成的文件和文件结构。【区域3】是编译后的文件内容查看区，可以在这个区域的文件里设置调试断点。【区域4】调试功能区，可以在这里查看变量状态与数值、断点设置情况、变量作用域等。这个区域和Chrome浏览器里的调试工具几乎一样，调试的方法和快捷键也是相同的。【区域5】信息输出区域，这个区域会显示程序运行的错误信息、警告信息以及用户自己打印的相关信息（通过console.log()输出的信息）。 如何在小程序中调试？可以在【区域3】中点击每行代码前的行号设置断点。当代码运行到断点处后，将停止。常用快捷键有【F10】单步执行，【F11】进入方法，【F8】继续运行到下一个断点。更多快捷键可自行在【区域4】中查看。 在整个调试选项卡中，最重要的部分还是【区域2】和【区域3】顶部的6个功能模块儿。【Sources】Sources Panel是默认的panel，用于显示当前项目的脚本文件。【Console】Console Panel用于调试和输出信息，开发者也可以在这里输入代码。panel在【Sources】模块中同样存在。当点击【Console】后，consolePanel将变大，使开发者可以浏览到更多信息。。【Network】Network Panel主要用于观察和显示网络连接的相关情况。这里的NetworkPanel和Chrome浏览器里的Network Panel几乎一样。【Storage】Storage Panel用于显示当前项目的数据缓存情况。【AppData】AppData Panel用于显示项目中被激活的所有页面的数据情况，这些数据主要是用来做数据绑定。【Wxml】Wxml Panel是非常重要的一个功能模块，这个模块类似于Chrome调试工具下的Elements模块，主要用于调试Wxml标签和相关CSS样式，调试方法同Chrome一样。如果你是一个前端新手，那么建议好好地摸索一下这个功能模块的调试技巧，绝大多数和样式、标签相关的问题，都需要依靠这个Panel来调试。 2.3.3 项目选项卡项目选项卡主要用来管理和设置项目。 项目选项卡主要有3大功能：显示当前项目细节、预览及上传项目以及项目配置。 显示项目细节顶部显示了项目名称和App ID。如果我们新建项目时选择的是“无AppID”，则这里将会固定地显示一个“touristappid”；如果你设置了项目的AppID，则这里会显示项目的AppID。 预览及上传项目预览按钮可以实现在真机上运行小程序，但前提条件是你必须有一个微信小程序账号。 项目配置开启ES6转ES5小程序支持使用ES6来编写代码。如果使用ES6来编写代码，框架会默认使用babel将开发者的代码转换为ES5代码（这样做的主要原因是为了保持对三端：iOS、Android和开发工具模拟器的良好兼容性）。 开启上传代码时样式自动补全开启此选项，开发工具会自动检测并补全缺失样式，保证在iOS 8上的正常显示。 开启代码压缩上传开启此选项，开发工具在上传代码时将会帮助开发者压缩JavaScript代码，减小代码包体积。 监听文件变化，自动刷新开发者工具开启此选项后，如果代码发生了改变（需要Ctrl+S先保存），小程序开发工具会自动帮助开发者刷新调试模拟器，从而提高开发效率。也就是说，开发者不再需要手动地点击编译按键即可实时预览小程序运行效果。 开发环境不校验请求域名以及TLS版本开启此选项，开发工具将不会校验安全域名以及TLS版本，帮助在开发过程中更好地完成调试工作。在开发工具里如果选取了“无AppID”模式，那么开发工具的安全限制级别非常低，不需要使用https访问服务器，也不会校验TLS版本。但如果我们填入了“AppID”，那么默认情况下开发工具的校验行为会和真机环境保持一致，比如，必须使用https访问服务器且服务器域名必须加入到微信小程序账号中的可信任域名列表中。如果我们不想接受这样的限制，又想使用“AppID模式”，那么需要把“开发环境不校验请求域名以及TLS版本”这一项给勾选上。 ES6转ES5的转换，只会帮助开发者处理语法上的问题，新的ES6的API例如Promise等需要开发者自行引入Polyfill或者别的类库。同时，为了提高代码质量，在开启ES6转换功能的情况下，默认启用JavaScript严格模式。开发者可以自己查阅资料了解什么是JavaScript的严格模式。 2.3.8 快速打开官方API文档小程序提供了一个快速打开官方文档的方法，即点击开发工具左上角的【帮助】→【关于】，在弹出的“关于”对话框中点击【点击打开文档】，即可马上进入官方API文档。 官方API文档除了用于经常查阅API外，推荐大家在版本更新后第一时间去查看更新内容。最新的更新内容对我们开发者来说尤其重要，更新内容通常会出现在官方API文档的【工具】→【下载】以及【历史更新日志】里。 2.3.9 开发工具的更新微信小程序开发者工具将自动更新，无须开发者手动更新。每次启动开发工具后，如果有新版本则会自动提示下载。在Windows下，如果开发者重启开发工具后依然没有自动更新，请退出开发工具，右键点击开发工具图标，选择【以管理员身份运行】。以上解决方案在Windows 10下测试可行。如果以上方案都不可用，请前往官网下载并安装最新版本的开发工具。 2.3.10 常用小程序快捷键1、格式调整Ctrl+S：保存文件Ctrl+[，Ctrl+]：代码行缩进Ctrl+Shift+[，Ctrl+Shift+]：折叠打开代码块Ctrl+C Ctrl+V：复制粘贴，如果没有选中任何文字则复制粘贴一行Shift+Alt+F：代码格式化Alt+Up，Alt+Down：上下移动一行Shift+Alt+Up，Shift+Alt+Down：向上向下复制一行Ctrl+Shift+Enter：在当前行上方插入一行Ctrl+Shift+F：全局搜索 2、光标相关Ctrl+End：移动到文件结尾Ctrl+Home：移动到文件开头Ctrl+i：选中当前行Shift+End：选择从光标到行尾Shift+Home：选择从行首到光标处Ctrl+Shift+L：选中所有匹配Ctrl+D：选中匹配Ctrl+U：光标回退 3、界面相关Ctrl+\\：隐藏侧边栏Ctrl+m：打开或者隐藏模拟器 第3章 从第一个简单的“Welcome”页面开始小程序之旅本章涉及内容：小程序的基本文件结构CSS的使用限制自适应单位rpx全局样式App.json配置文件Flex布局 3.1 认识小程序的基本文件结构 根目录下面有3个文件：app.js、app.json和app.wxss。一个小程序项目必须有这3个描述App的文件，它们必须放在应用程序的根目录下，否则小程序会提示找不到app.json文件。 这3个文件是应用程序级别的文件。接着是和这3个应用程序级别文件平行的pages文件夹。一个小程序由若干个页面文件构成。 wxml文件类似于我们熟悉的HTML文件，用来编写页面的标签和骨架，不同的是wxml文件里的标签元素不可以使用HTML标签，只能使用小程序自己封装的一些组件，这些组件也是我们后面要重点学习的知识。wxss文件的作用类似于我们熟悉的CSS文件，用于编写小程序的样式，实际上小程序的样式编写语言就是CSS，只是把.css文件换成了.wxss文件。json文件用来配置页面的样式与行为。js文件类似于我们前端编程中的JavaScript文件，用来编写小程序的页面逻辑。以上4种类型的页面文件的文件名称必须相同，这是要注意的一个地方。utils文件夹，这个文件夹用来存放一些公共的js文件。 3.2 开始动手编写第一个小程序页面在app.json 中注册 welcome 页面 如果有多个页面，需要将每个页面的路径加入到pages这个数组下，否则小程序不会加载这些页面。页面的添加或者删除都需要在pages数组下面增减对应的页面路径，否则小程序会报错。 即使welcome.js文件是一个空文件，依然需要在welcome.js中主动调用一下Page()方法。即使你目前不想在.json文件中配置任何属性，也需要加入一个空的{}，以保证小程序能正确执行。 如果app.json文件下pages数组里的页面路径，指向的是一个不存在的文件，那么MINA框架会自动创建这个页面的4个文件。 3.3 构建welcome页面的元素和样式 这段代码总共使用了3个微信小程序的组件，分别是view、text和image组件。view组件通常作为容器来使用，类似于HTML中的div标签；text组件用来显示一段文本，类似于HTML中的span标签；image组件用来显示一张图片，类似于HTML中的img标签。 图片默认宽度300px、高度225px 相对路径与绝对路径在小程序中同样有相对路径和绝对路径的区别。它以“/”开头，“/”代表根目录。 1&lt;image src=&quot;../../images/avatar/avatar-1.png&quot;&gt;&lt;/image&gt; 路径中的“..”表示向上一级。 真实项目中，图片资源尽量不要存储在小程序的目录中，因为小程序的大小不能超过1MB，超过则无法真机运行和发布项目。应该将图片都存放在服务器上，让小程序通过网络来加载图片资源。 3.4 小程序所支持的CSS选择器 同时需要注意的是，本地资源在wxss中是无法使用的。比如background-image，如果使用的是本地图片，则无法显示，可以使用网络图片来代替本地图片。 3.5 Flex布局Flex布局是W3C组织在2009年提出的一个新的布局方案，其宗旨是让页面的样式布局更加简单，并且可以很好地支持响应式布局。这并不是小程序所独有的技术，它本身是CSS语法的一部分。只不过早期时候，主流的浏览器对Flex布局的支持并不完善，造成了很多开发者不知道有这种布局的存在或者使用非常少，我们还是习惯使用传统的position和float属性来布局。但传统的布局方式有它的缺陷，比如像垂直居中就不是那么容易实现，Flex可以很好地解决这些问题。 这里推荐一个学习方法。编程里的知识点是非常细小而琐碎的，学习不同的知识应该掌握不同的方法。对于学习CSS这类知识，笔者认为较好的学习方法应该是在实践中学习。比如Flex布局的学习，我们首先应当大致浏览一下整个Flex的知识树，知道Flex解决了什么问题，有什么特点，大致有几类属性就够了。当我们在做项目遇到布局问题时，脑海里就能意识到Flex可能可以解决这个问题。接着我们抱着试试看的心态，带着目的去查找Flex布局的相关资料，即解决了问题，又能在实践中加深对Flex布局的理解，这比单纯死记硬背效果要好很多。人脑总是对形象化的东西记忆特别深刻，所以我们应当尽量在实践中学习知识。当然，也有可能Flex不能解决问题，但你查找和尝试解决问题的这个过程本身就是很好的学习手段。 小程序自适应单位rpx简介在小程序里，长度单位既可以使用rpx，也可以使用px。使用rpx可以使组件自适应屏幕的高度和宽度，但使用px不会。要透彻地理解rpx需要对移动端分辨率有一定的了解，比如物理分辨率px、逻辑分辨率pt等概念。 建议以iPhone 6的宽度750个物理像素作为标准，来做设计图。在此宽度下，这张设计图里每个元素的尺寸转换到小程序样式时，转换比例为1物理像素=1rpx=0.5px。rpx和px就是小程序样式里可以使用的两种长度单位。 最后，我们为什么要强调最好是在iPhone 6的尺寸下做设计图呢？因为只有在iPhone 6的尺寸下，设计图里的1个像素才满足下面的转换关系：1物理像素=1rpx=0.5px如果不以iPhone 6的标准来做设计图，也是可以的。但非iPhone 6的尺寸下，设计图与rpx、px的转换关系就不是整数倍的，计算起来比较麻烦，所以建议设计图最好以iPhone 6的尺寸标准来设计，这样换算起来很方便。这也是官方建议的一个设计标准。 如果我们足够细心，可以看到小程序的模拟器选择项下，给出了每种机型的分辨率。要强调的是，这里的分辨率指的是逻辑分辨率pt，而非物理分辨率。以iPhone 6为例，模拟器里给出的分辨率是：375×667；Dpr：2它的意思是：iPhone 6的水平方向有375个逻辑像素点，而竖直方向有667个逻辑像素点，每个逻辑像素点包含2个物理像素点。开发者一定要注意逻辑像素和物理像素的区别。我们通常在PS里做的设计图，它的像素可以简单理解为物理像素。再次提醒开发者，1物理像素不等于1px。假设有一张图片在操作系统下显示宽度为750个像素，我们现在想让这个图片水平方向充满整个页面。如果你直接在页面里（iPhone 6模拟机型下）将图片宽度设置为750px，这是不对的。正确的设置方法为750rpx或者375px，才能让图片水平填满小程序。因为，iPhone 6下：1物理像素=1rpx=0.5px。 3.7 全局样式文件 app.wxss把公共样式放在 app.wxss 文件内。 3.8 页面的根元素pagepage代表着整个页面的容器，如果想对页面整体做样式或者属性设置，那么应该考虑page这个页面的根元素。 3.9 app.json中的window配置项设置window的属性navigationBarBackgroundColor值为#ECC0A8 第4章 文章列表页面本章涉及内容：swiper组件构建banner轮播图以及swiper组件的其他属性详细介绍image组件的4种缩放模式与9种裁剪模式数据绑定常用事件 4.1 文章列表页面元素分析及准备工作文章页面主体部分由两部分构成，上半部分是一个轮播图，下半部分是文章列表。 轮播图效果，小程序已经提供了一个现成的组件——swiper。小程序启动后显示的首页，由app.json文件里pages数组的第一个元素决定。 4.2 swiper组件同时，需要注意的是，swiper组件的直接子元素只可以是swiper-item，如果放置其他组件，则会被自动删除。但swiper-item下是可以放置其他组件或者元素的。 4.3 Boolean值的陷阱vertical=”false”vertical=”true”vertical=”aaa”vertical=”bbb”从上面的属性举例中找出原因了:false并不是Boolean类型，而是一个字符串。只要不是空字符串，那么在JavaScript里都会认为这是一个true。 不加入vertical属性vertical=” “vertical=”false“以上小程序都会认为vertical属性设置成了false 4.4 构建文章列表的骨架和样式4.5 image组件的4种缩放模式与9种裁剪模式4种缩放模式和9种裁剪模式如果从理论上完全精确理解，还是有稍许的难度的。但这里笔者建议各位开发者，没有必要完全从理论上搞清楚这些模式。当遇到具体问题时，尝试多去更换几个属性，找到最适合自己需求的属性即可。 如果觉得本书不错，推荐购买下《微信小程序开发入门与实践》，我只是摘录总结了这本书的部分内容。 相关资料Flex 布局教程：语法篇页面配置全局配置swiperimagesitemap 配置","link":"/2020/03/21/Blog-about-learning-21/"},{"title":"Node.js 在有赞的实践分享","text":"Node 服务化为什么要做服务化？将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。提高业务复用及整合的分布式服务框架(RPC)，分布式服务架构势在必行。 服务化拆分之后，每一层职责分别是什么？对于 Node 层，定位是中间层。Node 层不会过多地处理业务逻辑，业务逻辑全部都交给 Java 来处理，它只负责下面三件事情： 模板渲染：模板渲染说的就是 HTML 模板的渲染； 业务编排：对于一个稍微复杂一点的页面，通常需要聚合多个接口返回的数据才能显示完整的页面，所以在这种情况下，Node 就需要聚合多个接口的返回结果，然后将合并后的数据返回给前端。 接口转发：Java 的服务是不会直接暴露到公网提供给前端使用的，所以在这种情况下，Node 需要承担接口转发的角色。 以上是 Node 在有赞的实践 文章的部分内容。如有侵权请告知立即删除。阅读原文","link":"/2020/03/10/Blog-about-learning-35/"},{"title":"持续开发维护项目中遇到的问题及解决方法","text":"字符串字符串 —— 语言包1、在固定不变的字符串直接使用静态文本，代码中根本不去做控制，这样做不方便策划对于描述的一个更改2、是如果需要国际化，会造成很多不必要的工作。 使用字符串填空功能在存在字符串拼接的情况下，尽量使用字符串填空功能，不要直接使用字符串相加（不同语言中语序会存在不用，如果直接字符串相连会导致语序不对，使用字符串填空（StringUtil.substitute)时，只需要修改配置语序即可，便于定位查找问题。 适配屏幕自适应在屏幕自适应设计的时候抽象出一个接口，获取屏幕分辨率，对不同分辨率下的浏览器窗口进行不同程度的自适应设计，另外在屏幕4个角坐碰撞检测，一旦有打开界面超出碰撞点，就再次 resize。 静态资源图片资源打包成一个图集打包图集的目的是因为如果多个对象引用了同一个图集下的资源，就可以只用提交一次渲染提交，因为他们的 TextureBuffer 都来自同一张图集。 保存格式不需要设置图片资源的Alpha值（Alpha值指一张图片的透明和半透明度）的保存成JPG格式，只有需要更改Alpha的存为PNG格式 以上是我对下列视频及文章的归纳和总结。做前端两年，月薪18k，这些项目经验你绝对值得学习","link":"/2020/03/07/Blog-about-learning-34/"},{"title":"Web 项目开发及线上部署","text":"项目上线流程本地开发 web 项目 -&gt; 本地环境搭建 -&gt; 本地 web 项目代码实现 -&gt; 测试及导出 war 包及 sql 脚本腾讯云服务器 -&gt; 云服务器环境搭建 -&gt; 云服务器部署 web 项目 -&gt; 绑定域名 本地 web 项目大纲 本地 web 项目概述 本地开发环境准备 创建 web 项目及包结构 创建数据库并导入配置文件 编写核心代码 整体测试并导出 war 包 本地 web 项目概述完成前端登陆和注册页面的编写完成服务器端登陆和注册核心代码的编写完成数据库表的编写 本地开发环境准备JDK v1.8Tomcat v8.5Mysql v5.5或5.6或5.7 本地 web 项目开发 腾讯云服务器流程大纲 购买或者租用云服务器 远程登陆和上传工具 搭建服务器部署环境 部署 web 项目 绑定域名 绑定 https 协议服务","link":"/2020/10/01/Blog-about-learning-37/"},{"title":"Node.js 从入门到实践开发","text":"Node 概述Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 和浏览器上 JS 的区别Node.js VS 浏览器上的 JS 运行环境不同API 不同全局变量不同 window vs global事件循环 Node.js 语法概述Node.js语法是完全基于JavaScript的，下列内容与JS完全一样 数据类型 声明变量和常量 运算符 逻辑结构 函数作用域和闭包 对象和原型 对象分类 JS和Node.js的最大不同点在由解释器所提供的扩展对象上！。 数据类型 原始类型：string、number、boolean、null、undefined 引用类型：ES核心对象：Global、String、Number、Boolean、Date、Math、Array、Error、Function、Object、RegExp Node.js对象：Buffer、ReadStream、ClientRequest 自定义对象 Node.js的特点 简单，避免过度设计 单线程逻辑处理 非阻塞的异步I/O处理 事件驱动编程 无锁机制，不会产生死锁 支持数万个并发链接 Node适用于IO密集型的应用，而不适合于CPU密集的应用。 Node全局对象嵌入在浏览器中的V8引擎，支持ES原生对象、BOM和DOM对象，全局对象为windowNode中的全局对象是global，所有全局变量都是global对象的属性。 global 在交互模式下声明的全局变量和函数都是global对象的成员——全局对象污染在脚本模式下声明的”全局变量和函数”不是global对象的成员——避免了全局对象污染脚本模式下，每个.js文件都是一个独立的模块对象，其中创建的“全局变量和函数”都是该对象构造方法内的局部成员 process 当操作系统启动一个程序时，会将必须的可执行文件和数据文件从文件系统调入内存，分配必须的内存空间，执行其中的代码——称为创建了一个执行进程。— 全局对象global.process就是这个进程的代码表示；— process对象获取当前操作系统及运行时信息，并操作脚本所在执行进程。 Buffer Buffer：缓冲区，专用于存储数据的内存区域，用于存储读写的文件数据、网络上要传输的数据等。Buffer对象的实例，可以直接构建，也可以通过数据读写获得。能存储字符数据，二进制的字节数据 1var buf1=new Buffer.alloc(32); 将 Buffer 内容转换为特定编码的string 1console.log(buf3.toString('utf8')); 缓冲区：内存的一部分。在内存空间中预留了一定的存储空间，存储空间是用来缓冲输入或输出的数据。缓冲区分为输入缓冲区和输出缓冲区。 高速设备与低速设备的不匹配，势必会让高速设备花时间等待低俗设备，可以在两者之间设立一个缓存区。 缓冲区的作用：1.可以解除两者的制约关系，数据可以直接送往缓冲区，高速设备不用在等待低速设备，提高了计算机的效率。2.可以减少数据的读写次数，如果每次数据只传输一点数据，就需要传送很多次，这样会浪费很多时间，因为开始读写与终止读写所需的时间很长，如果将数据送往缓冲区，待缓冲区满后再进行传送会大大减少读写次数，这样就可以节约很多时间。 缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来存储数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。 buffer偏重于写cache偏重于读 全局函数定时器global.setTimeout():一次性定时器global.setInterval():周期性定时器process.nextTick():本次事件循环结束时立即执行的定时器global.setImmediate():下次事件循环立即执行的定时器 模块Node.js中每一个.js文件对应一个模块对象；模块内声明的变量或函数的作用域是“模块作用域”——默认只能在当前JS文件（即当前模块）中使用，而不是全局作用域；每个模块可以导出（exports）自己内部的成员提供其它模块使用，也可以引入（require）并使用其他模块中导出的成员；Node.js启动时运行的第一个模块称为主模块（main module） 模块分类核心模块Node.js提供，被编译进二进制执行文件，可以被解释器直接使用，加载速度最快 第三方模块基于node.js核心模块，第三方扩展应用模块常用的第三方模块：express、less、webpack 自定义模块文件式自定义模块目录式自定义模块 Node.js 的安装运行在官网上下载，安装点击下一步下一步即可完成安装。 检验是否安装成功，打开命令行窗口。 1234node -vv10.16.0npm -v6.13.7 以上显示为正常。 如果显示没该命令，你可以尝试在系统变量的 Path 中找寻 node的路径如下图所示。 Node 的运行方式可以在命令窗口中运行例如 编译模式 12nodeconsole.log('Hello World') 1node -e &quot;console.log('呵呵')&quot;; 也可以运行文件。 1node hello.js Node.js 最重要的几个概念Node.js 模块Node.js 包管理 NPM Yarn Node.js 模块1234567891011121314151617181920/** @file a* @author Max*/// a.js// require 引入 b 模块// require('b') 会到 node_modules 中找模块const b = require('./b');console.log(b);// c.jsvar hello = require('./d');var he = new hello();he.setName('marico');he.sayHello();var he2 = new hello();he2.setName('yfc');he2.sayHello(); 12345678910111213141516171819202122/** @file module example* @author Max*/// b.jsconsole.log(1);// 导出内容module.exports = 'hello world'// d.jsfunction hello(){ var name; this.setName = function(thyName){ name = thyName; } this.sayHello = function(){ console.log('hello' + name); }}module.exports = hello; require 导入是同步的，当导入完成后，才能往下执行代码。 Node.js 包管理 NPM Yarnnpm 常用来下载安装包 File system读写文件示例代码： 1234567891011121314151617181920212223242526272829303132const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);// path.resolve(__dirname) 当前所在的目录const data = new Uint8Array(Buffer.from(&quot;hello world&quot;));// writeFile 异步执行fs.writeFile(path.resolve(__dirname, &quot;hello.txt&quot;), data, err =&gt; { if (err) throw err; console.log(&quot;文件已被保存&quot;);});// 同步// fs.writeFileSync()fs.readFile(path.resolve(__dirname, &quot;hello.txt&quot;), (err, data) =&gt; { if (err) throw err; // 二进制转成文字 console.log(data.toString());});// 捕获错误try {} catch (error) {}// 捕获错误process.on(&quot;uncaughtException&quot;, e =&gt; { console.log(e.message);}); HTTPHTTP Server示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const http = require(&quot;http&quot;);const net = require(&quot;net&quot;);const { URL } = require(&quot;url&quot;);// 创建 HTTP 隧道代理。const proxy = http.createServer((req, res) =&gt; { // req.headers 请求头 console.log(req.headers); // res.writeHead 写响应头 res.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot;, &quot;x-myself-http-header&quot;: &quot;max&quot; }); // 跟上面 writeHead 实现效果一样。 /* res.statusCode = 400; res.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;); res.setHeader(&quot;x-myself-http-header&quot;, &quot;max&quot;); */ // 会写入页面中 //res.write(&quot;hello world&quot;); res.end(&quot;响应内容&quot;);});proxy.on(&quot;connect&quot;, (req, cltSocket, head) =&gt; { // 连接到原始服务器。 const { port, hostname } = new URL(`http://${req.url}`); const srvSocket = net.connect(port || 80, hostname, () =&gt; { cltSocket.write( &quot;HTTP/1.1 200 Connection Established\\r\\n&quot; + &quot;Proxy-agent: Node.js-Proxy\\r\\n&quot; + &quot;\\r\\n&quot; ); srvSocket.write(head); srvSocket.pipe(cltSocket); cltSocket.pipe(srvSocket); });});proxy.on(&quot;clientError&quot;, (err, socket) =&gt; { socket.end(&quot;HTTP/1.1 400 Bad Request\\r\\n\\r\\n&quot;);});// 代理正在运行。proxy.listen(1337, &quot;127.0.0.1&quot;, () =&gt; { // 向隧道代理发出请求。 const options = { port: 1337, host: &quot;127.0.0.1&quot;, method: &quot;CONNECT&quot;, path: &quot;nodejs.cn:80&quot; }; // 发出 HTTP 请求 const req = http.request(options); req.end(); req.on(&quot;connect&quot;, (res, socket, head) =&gt; { console.log(&quot;已连接&quot;); // 通过 HTTP 隧道发出请求。 socket.write( &quot;GET / HTTP/1.1\\r\\n&quot; + &quot;Host: nodejs.cn:80\\r\\n&quot; + &quot;Connection: close\\r\\n&quot; + &quot;\\r\\n&quot; ); // 返回响应信息 socket.on(&quot;data&quot;, chunk =&gt; { console.log(chunk.toString()); }); // 结束关闭 socket.on(&quot;end&quot;, () =&gt; { proxy.close(); }); });}); Events 事件123456789101112const EventEmitter = require('events');// 继承class MyEmitter extends EventEmitter {}// 声明事件对象const myEmitter = new MyEmitter();// 注册事件myEmitter.on('event', () =&gt; { console.log('an event occurred!');});// 触发事件myEmitter.emit('event'); nvm-windowsWindows 的 node.js 版本管理 相关资料[视频]Node.js 入门√[视频]node.js 入门 Windows下安装及使用NVM√windows上NVM安装与使用√nvm 安装npm不成功，一直没反应√十个Node.js开发易犯错误之一:不使用开发工具 javascript standard style 一种 JavaScript 的代码风格Uint8Array对象处理二进制数据Buffer自定义根证书颁发机构 CA 生成自签名证书Redis + NodeJS 实现一个能处理海量数据的异步任务队列系统多维度分析 Express、Koa 之间的区别","link":"/2020/03/24/Blog-about-learning-39/"},{"title":"程序员私活平台","text":"巨牛汇 任务栈 云沃客 威客网 更多平台请看知乎 以上平台我都没有尝试，接私活需谨慎。","link":"/2020/03/24/Blog-about-learning-40/"},{"title":"开发者职业发展漫谈","text":"成为优秀的开发者需要具备怎样的素质？软件开发者的发展路径是怎样的？开发者应该养成怎样的好习惯？如何持续学习，如何管理知识产权？开发者应该具有哪些软技能？去哪里抱团？如何销售自己？开发者如何提高沟通技能？开发者如何提高英语水平？ 千万不要只走一种语言算法：高等数学数据统计、数据分析 “编程的本质任务就是驾驭计算机科学的极端复杂性。” —— Dijkstra 为产品项目提出自己的想法和见解。 进阶的历程是？入门中级熟练级技术带头人级 如何持续学习？如何管理知识资产？ 开发者应该具备哪些软技能？ 如何打造自己的品牌？去哪里抱团？如何销售自己？ 如何提高沟通水平？ 推荐的网站courseraudacity 推荐书籍《软技能：代码之外的生存指南》。 以上是我对下列视频及文章的归纳和总结。开发者职业发展漫谈","link":"/2020/03/25/Blog-about-learning-43/"},{"title":"2019 安卓混合开发视频精讲","text":"原生语言苹果手机：iOS 系统，由 Swift 和 C++ / Objective-C 语言编写，后缀名为 ipa （iOS 开发的安装包的后缀名） Swift 语言是一种开源的语言（半开半闭） 安卓手机：Android 系统，由 Java （Android）语言编写，后缀名为 apk 开源的。 wp手机： Windows Phone 系统，由 C# 语言编写，后缀名分为两类 （wp7 wp8的是 xap wp8.1以后用 8.1 的 SDK 开发的是 appx）一般说到混合开发不考虑这个版本 序号 系统 语言 后缀名 1 iOS OC/C++/Swift ipa 2 Android Java apk 3 wp C# appx 混合开发原生语言开发 + JavaScript 开发缘由： JavaScript 无法调动系统的原生功能（拍照、短信、打电话、通信录），但是原生（iOS、Android、wp）可以，原生有很大的适配问题（特别是 Android），JavaScript 可以很好的解决这个问题。 术语： Hybrid App —— JavaScript + iOS/Android 写的。 Web App —— m 站，touch 端项目 手机网站 —— 纯 JavaScript 写的。 Native App —— 纯 iOS/Android 编写的程序。 Android + JavaScript 的开发模式准备工具： Java JDK android-studio IntelliJ 编辑器插件扩展而来 android 手机或 android 模拟器 数据线 代码分析 项目目录介绍 桥接涉及的知识点：1、线性布局2、WebView 组件应用3、JSBridge 调用、传值 示例 主要代码 1234567891011121314151617181920&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_height=&quot;match_parent&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/tv_title&quot; /&gt; &lt;Button android:id=&quot;@+id/btn1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/btn1&quot;/&gt; &lt;WebView android:id=&quot;@+id/wv&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;&lt;/WebView&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.view.KeyEvent;import android.view.View;import android.webkit.JavascriptInterface;import android.webkit.WebSettings;import android.webkit.WebView;import android.widget.Button;import android.widget.Toast;public class MainActivity extends AppCompatActivity { private Button Btn1; // var btn1 private WebView WV; private View.OnClickListener btnonClickHandler = new View.OnClickListener() { @Override public void onClick(View view) { // 业务逻辑 可消失的提示框 Toast Toast.makeText(MainActivity.this,&quot;测试 android 的 Toast 功能&quot;,Toast.LENGTH_SHORT).show(); WV.loadUrl(&quot;javascript:getData('我是一个android传递过来的值')&quot;); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); } private void initView(){ // btn1 = document.getElementById(&quot;html&quot;) // btn1.addEventLinstenner('click',function(){},false) Btn1 = findViewById(R.id.btn1); Btn1.setOnClickListener(btnonClickHandler); /** * WV.loadUrl() * WebView.loadUrl('http://www.google.com') // 远程页面 * WebView.loadUrl('file:///android_asset/test.html') // 本地页面 —— 随着 App 打包 * WebView.loadUrl('content://com android htmlfileprovider/sdcard/test.html') // 手机本地的页面 —— sd卡中的页面 * WebView.loadData() // 加载一段 HTML 代码 */ /* * 初次加载显示无网络，需要到项目配置文件添加网络的权限 * &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; */ WV = findViewById(R.id.wv); // 默认的 WebView 是需要进行配置才能达到我们想要的一些浏览器的特性 WVSetting(); WVClientSetting(); // 加载远程页面 // WV.loadUrl(&quot;https://m.jd.com/&quot;); // 加载本地页面 WV.loadUrl(&quot;file:///android_asset/index.html&quot;); // 添加JS调用Android(Java)的方法接口 WV.addJavascriptInterface(new MJavascriptInterface(getApplicationContext()), &quot;ToastFunc&quot;); WV.addJavascriptInterface(new PhotoJavascriptInterface(getApplicationContext()), &quot;PhotoFunc&quot;); } private void WVSetting() { // 声明 WebSettings 子类 // getSettings() 返回一个WebSettings对象,用来控制WebView的属性设置 WebSettings webSettings = WV.getSettings(); /* * 如果访问的页面中要与 JavaScript 交互，则 webview 必须设置支持 JavaScript * 若加载的 html 里有 JavaScript 在执行动画等操作，会造成资源浪费 （CPU、电量） * 在 onStop 和 onResume 里分别把 setJavaScriptEnadled() 给设置成 false 和 true 即可 * 设置自适应屏幕，两者合用 */ webSettings.setJavaScriptEnabled(true); // 将图片调整到适合 webview 的大小 webSettings.setUseWideViewPort(true); // 缩放至屏幕大小 webSettings.setLoadWithOverviewMode(true); // 支持缩放，默认为 true webSettings.setSupportZoom(true); // 设置内置的缩放控件。若为 false，则该 webview 不可缩放 webSettings.setBuiltInZoomControls(true); // 隐藏原生的缩放控件 webSettings.setDisplayZoomControls(false); // 关闭 webview 中缓存 webSettings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK); // 设置可以访问文件 webSettings.setAllowFileAccess(true); // 支持通过 JavaScript 打开新窗口 webSettings.setJavaScriptCanOpenWindowsAutomatically(true); // 支持自动加载图片 webSettings.setLoadsImagesAutomatically(true); // 设置编码格式 webSettings.setDefaultTextEncodingName(&quot;utf-8&quot;); } private void WVClientSetting() { //处理页面加载各个阶段 MWebViewClient mWebViewClient = new MWebViewClient(WV,getApplicationContext()); WV.setWebViewClient(mWebViewClient); //提供网页加载过程中提供的数据内容 MWebChromeClient mWebChromeClient = new MWebChromeClient( getApplicationContext()); WV.setWebChromeClient(mWebChromeClient); } class MJavascriptInterface { private Context context; public MJavascriptInterface(Context context) { this.context = context; } // andorid版本升级时必须加上@JavascriptInterface @JavascriptInterface public void showToast() { // 可以由前端调用 window.ToastFunc.showToast() Toast.makeText(MainActivity.this, &quot;js调起了android的Toast功能&quot;, Toast.LENGTH_SHORT).show(); } @JavascriptInterface public void showToastParams(String str) { // 可以由前端调用 window.ToastFunc.showToast() Toast.makeText(MainActivity.this, &quot;js调起了android的Toast功能&quot; + str, Toast.LENGTH_SHORT).show(); } } class PhotoJavascriptInterface { private Context context; public PhotoJavascriptInterface(Context context) { this.context = context; } // andorid版本升级时必须加上@JavascriptInterface @JavascriptInterface public void takePhoto() { // 拍照 Toast.makeText(MainActivity.this, &quot;拍照&quot;, Toast.LENGTH_SHORT).show(); // 拍照流程 } @JavascriptInterface public void getPhoto() { // 相册选取 Toast.makeText(MainActivity.this, &quot;相册选取&quot;, Toast.LENGTH_SHORT).show(); // 相册选取流程 } } //点击返回上一页面而不是退出浏览器 @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; WV.canGoBack()) { WV.goBack(); return true; } return super.onKeyDown(keyCode, event); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link href=&quot;https://cdn.bootcss.com/mui/3.7.1/css/mui.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;button type=&quot;button&quot; id=&quot;btn&quot; class=&quot;mui-btn mui-btn-royal&quot;&gt;js按钮，调用android的Toast功能&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;takePhoto&quot; class=&quot;mui-btn mui-btn-royal&quot;&gt;拍照&lt;/button&gt; &lt;button type=&quot;button&quot; id=&quot;getPhoto&quot; class=&quot;mui-btn mui-btn-royal&quot;&gt;相册&lt;/button&gt; &lt;div id=&quot;msg&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; $('#btn').on('click', function () { console.log('我是js按钮，想要调用android的Toast功能') window.ToastFunc.showToast() // js 可以调用android的功能 window.ToastFunc.showToastParams('是真的吗') }) $('#takePhoto').on('click', function () { window.PhotoFunc.takePhoto() }) $('#getPhoto').on('click', function () { window.PhotoFunc.getPhoto() }) function getData (str) { $('#msg').html(str) } /** 只需要按照项目需求编写也买你，假设你的一个按钮需要调用系统的功能（部分功能需要添加权限）， 在你的按钮事件中调用由android工程师提供的相对应的对象和其方法即可， 同时前端也会定义一些方法，但是前端自己不调用，android会根据webview的loadUrl方法进行调用， 并且传参（根据需求看） 如果把这些对象封装起来（plus），结合特定的环境（hbuilder），那么前端人员也就可以自己做混合开发的项目了 */&lt;/script&gt;&lt;/html&gt; 相关资料2019 安卓混合开发视频精讲 相关代码","link":"/2020/03/06/Blog-about-learning-32/"},{"title":"关于反编译","text":"我最早听说过类似“反编译”的词汇是在汽车、飞机等领域，通过反编译来仿制汽车、飞机等，昨天面试听到面试公司技术骨干提到这个反编译。我觉得很神奇。索性出一篇文章来了解反编译。 反编译反编译指通过他人软件进行“逆向分析、研究”工作，推导出他人的软件产品所使用的思路、原理、结构、算法、处理过程、运行方式等设计要素，某种特定情况下可能推导出源码。可以作为自己开发软件时的参考或直接用于自己的软件产品中。 这里我想到了，我在学校期间使用过一款扒网站的工具，跟反编译接近，工具是你输入一个网址然后通过这个网址来扒取网站的。我想大致原理是跟爬虫类似的，只不过爬虫抓取的是网站的数据，它抓取的是文件资源。 微信小程序反编译大致操作步骤，在模拟器中找到微信用微信打开某个小程序，小程序会被下载下来，然后找到下载下来的包，用ES 文件浏览器 把包复制到共享文件夹，然后通过 node 进行反编译，详细请看相关资料。 相关资料科普：什么是编译与反编译逆向反编译四大工具利器知乎 反编译反编译微信小程序反编译获取任何微信小程序源码(完)微信小程序反编译如何将模拟器内的文件导出到电脑","link":"/2020/03/28/Blog-about-learning-45/"},{"title":"phpstudy v8.0 的使用","text":"大学时期，接触过 PHP,并且简单的使用过织梦，那时候用的工具是 XAMPP。PHP 忘得也差不多了，这次写 Ajax 例子的时候用到了 PHP，那就写一篇关于 phpstudy 常用操作吧。 WAMP、XAMPP、PHPstudyWAMP 强烈推荐这款 ：WAMP是基于Windows，Apache，MySQL和PHP的开放资源网络开发平台，Windows是微软的操作系统；Apache是最通用的网络服务器；mySQL是带有基于网络管理附加工具的关系数据库；XAMPP：许多人通过他们自己的经验认识到安装 Apache 服务器是件不容易的事儿。如果您想添加 MySQL、PHP 和 Perl，那就更难了。XAMPP 是一个易于安装且包含 MySQL、PHP 和 Perl 的 Apache 发行版。XAMPP 的确非常容易安装和使用：只需下载，解压缩，启动即可。PHPstudy：能够随意版本却换。 相关资料phpstudy 官网phpstudy v8.0 下载_安装步骤phpstudy v8.0创建本地站点域名教程phpstudy v8.0 网站创建与配置phpstudy v8.0 php mysql多版本共存与切换教程phpstudy v8.0 数据库管理工具phpadmin使用教程phpstudy v8.0 FTP服务器设置phpstudy v8.0 完全卸载图文教程","link":"/2020/03/28/Blog-about-learning-46/"},{"title":"jQuery源码解析","text":"先占着，等有时间了在写。 以上是我对下列视频及文章的归纳和总结。jQuery 源码解析遇到的问题和解决方法","link":"/2020/03/29/Blog-about-learning-47/"},{"title":"代码审查","text":"什么是代码审查 程序源代码系统的进行审查 =&gt; 找出修正初期未发现的错误，提升代码质量 帮助开发者发现代码缺陷，避免类似问题发生 互相阅读代码，发现代码中的Bug 通俗就是leader主持下，讲关键代码，大家提建议和意见 好处： 提升代码质量 最重要的是你同团队一起成长，团队技术提升的重要环节 审查规范的坑 没有流程 没有系统 没有任何清单 导致程序员像面试一样面对未知很紧张 代码清单包含方面 代码安全性 性能 代码注释 单元测试代码 代码优化（例如格式化、分类等） 以上是常见需要涵盖的方面，具体的按照公司规定来，这是最重要的一项 好处 有清单程序员介绍关键代码和审查都有数 审查时间节约 代码审查参与者避坑 应该是日常工作，而不是作为项目的最后工作，最好每天一做，至少一星期一次 每次审查行数200~400左右 审查代码的时间不要太长，一个组不超过一小时，每个人大概15分钟就好，不要影响开发效率了 代码审查中领导不要发火，不要批评，变成一个快乐、互相学习、互相进步的过程。 以上来自视频下TIAN梦的评论 以上是我对下列视频及文章的归纳和总结。大胖逼逼叨17-程序员避开这4个坑 代码审查快乐又轻松 相关资料代码审查怎么做？","link":"/2020/04/01/Blog-about-learning-49/"},{"title":"30-seconds-of-code","text":"数组arrayMax返回数组中的最大值。 12const arrayMax = arr =&gt; Math.max(...arr);// arrayMax([10, 1, 5]) -&gt; 10 arrayMin返回数组中的最小值。 12const arrayMin = arr =&gt; Math.min(...arr);// arrayMin([10, 1, 5]) -&gt; 1 chunk将数组块划分为指定大小的较小数组。 使用Array.from()**创建新的数组, 这符合将生成的区块数。使用Array.slice()**将新数组的每个元素映射到size长度的区块。如果原始数组不能均匀拆分, 则最终的块将包含剩余的元素。 123const chunk = (arr, size) =&gt;Array.from({length: Math.ceil(arr.length / size)}, (v, i) =&gt; arr.slice(i * size, i * size + size));// chunk([1,2,3,4,5], 2) -&gt; [[1,2],[3,4],[5]] compact从数组中移除 falsey 值。 12const compact = (arr) =&gt; arr.filter(Boolean);// compact([0, 1, false, 2, '', 3, 'a', 'e'*23, NaN, 's', 34]) -&gt; [ 1, 2, 3, 'a', 's', 34 ] countOccurrences计算数组中值的出现次数。 使用Array.reduce()在每次遇到数组中的特定值时递增计数器。 12const countOccurrences = (arr, value) =&gt; arr.reduce((a, v) =&gt; v === value ? a + 1 : a + 0, 0);// countOccurrences([1,1,2,1,2,3], 1) -&gt; 3 deepFlatten深拼合数组。使用递归。使用Array.concat()与空数组 ([]) 和跨页运算符 (…) 来拼合数组。递归拼合作为数组的每个元素。 12const deepFlatten = arr =&gt; [].concat(...arr.map(v =&gt; Array.isArray(v) ? deepFlatten(v) : v));// deepFlatten([1,[2],[[3],4],5]) -&gt; [1,2,3,4,5] difference返回两个数组之间的差异。从b创建Set, 然后使用Array.filter() on 只保留a b中不包含的值. 12const difference = (a, b) =&gt; { const s = new Set(b); return a.filter(x =&gt; !s.has(x)); };// difference([1,2,3], [1,2,4]) -&gt; [3] distinctValuesOfArray返回数组的所有不同值。使用 ES6 Set和…rest运算符放弃所有重复的值。 12const distinctValuesOfArray = arr =&gt; [...new Set(arr)];// distinctValuesOfArray([1,2,2,3,4,4,5]) -&gt; [1,2,3,4,5] dropElements移除数组中的元素, 直到传递的函数返回true。返回数组中的其余元素。 在数组中循环, 使用Array.shift()将数组的第一个元素除去, 直到函数的返回值为true。返回其余元素。 12345const dropElements = (arr, func) =&gt; {while (arr.length &gt; 0 &amp;&amp; !func(arr[0])) arr.shift(); return arr;};// dropElements([1, 2, 3, 4], n =&gt; n &gt;= 3) -&gt; [3,4] everyNth返回数组中的每个第 n 个元素。使用Array.filter()创建一个包含给定数组的每个第 n 个元素的新数组。 12const everyNth = (arr, nth) =&gt; arr.filter((e, i) =&gt; i % nth === 0);// everyNth([1,2,3,4,5,6], 2) -&gt; [ 1, 3, 5 ] 相关资料30-seconds-of-code中文翻译 30-seconds-of-code","link":"/2020/08/04/Blog-about-learning-5/"},{"title":"2018 前端学习路线","text":"基础基础的 HTML + CSS基础的 JavaScript框架：Bootstrap框架：Vue 进阶HTML5 + CSS3ES6基于 Vue 的组件化 SPA 开发。 延伸了解更多资源: iconfont、bootswatch、themeforest小程序：原生、mpvueAPP：APICloudNode：AdonisJs后端云：知晓云 以上是我对下列视频及文章的归纳和总结。2018前端开发学习路线建议","link":"/2019/12/29/Blog-about-learning-50/"},{"title":"关于 Android 项目常见问题","text":"gradle 版本号修改项目 gradle 的版本号修改项目 gradle 的版本号 NDK人脸识别用到 NDK ，项目中有用到 NDK 就下载，然后会提示你版本不对，然后再下载响应的版本即可。 秘钥找不到问题指定 key 路径 java 文件报错java文件报错 window 命令行跳转目录","link":"/2020/04/07/Blog-about-learning-51/"},{"title":"《Android App开发从入门到精通》","text":"第1章 Android Studio的介绍以及使用探索Android Studio基于Gradle的灵活构建系统。• 快速且功能丰富的模拟器。• 可针对所有Android设备进行开发的统一环境。• Instant Run，可将变更推送到正在运行的应用，无须构建新的APK。• 帮助构建应用程序和导入示例代码以及GitHub集成。• 丰富的测试工具和框架。• 可捕捉性能、易用性、版本兼容性以及其他问题的Lint工具。• C++和NDK支持。• 内置对Google云端平台的支持，可轻松集成Google Cloud Messaging和App引擎。 书中案例源码下载https://github.com/ansen666/book_source_code","link":"/2020/04/07/Blog-about-learning-52/"},{"title":"学习资源分享","text":"阿里开发者社区阿里开发者云平台百度 AI 开放平台腾讯云平台腾讯云大学","link":"/2020/04/07/Blog-about-learning-53/"},{"title":"MUI 视频教程","text":"MUI 介绍、新项目创建、基础布局MUI 为何诞生1、性能和体验的差距，一直是 mobile app 开发者放弃 HTML5 的首要原因。2、浏览器天生的切页白屏、不忍直视的转页动画、浮动元素的抖动、无法流畅下拉刷新、侧滑抽屉卡顿等问题，这些都让 HTML5 开发者倍感挫败，尤其在 Android 低端机运行。3、浏览器默认控件样式又少又丑，制作一个漂亮的控件非常麻烦，也有一些制作简单的 ui 框架但性能低下。mui 框架有效的解决了这些问题，这是一个可以方便开发出高性能 App 的框架，也是目前最接近原生 App 效果的框架。 MUI 的定位是：最接近原生体验的移动 App 的 UI 框架基于 mui 的定位，产生了 mui 的几个特点，轻、小、只涉及 UI、只为移动 App 而生、界面风格原生话。 1、mui 不是 jq，不封装 dom 操作与 ui 无关的 mui 不做，可以用 jq 或 zepto 就用，并不冲突。但并不建议在 移动 App 里引入 jq 或 zepto 这些框架，原因如下：为了性能，层层封装的框架，尤其是遍历 dom 时，影响效率，尤其在低端 Android 手机上。 原生 JS 挺简单，为何需要 jq ？手机上只有 webkit 浏览器（忽略 wp，反正 mui 不支持 wp），根本就不需要 jq 这种封装来操作 dom。而且 HBuilder 提供了代码块来简化开发，敲 dg、dq，直接生成 document.getElementById(“”)、document.querySelectorAll(“”)，非常快捷方便，而且执行性能非常高，而且没有浏览器兼容问题。 2、mui、HTML5+、5+ Runtime 的关系说明mui 是一个前端框架，HTML5+ 是一套 HTML5 能力扩展规范，HTML5+ Runtime 是实现 HTML5+ 规范的强化浏览器引擎。 开始体验 MUI1、安装新版本 HBuilderHBuilder 2、新建 app 项目 基础布局头部核心 css mui-bar mui-bar-nav 1234&lt;header class=&quot;mui-bar mui-bar-nav&quot;&gt; &lt;a class=&quot;mui-action-back mui-icon mui-icon-left-nav mui-pull-left&quot;&gt;&lt;/a&gt; &lt;h1 class=&quot;mui-title&quot;&gt;test&lt;/h1&gt;&lt;/header&gt; 主体部分核心 css mui-content 123&lt;div class=&quot;mui-content&quot;&gt; test...&lt;/div&gt; 组件折叠面板12345678&lt;ul class=&quot;mui-table-view&quot;&gt; &lt;li class=&quot;mui-table-view-cell mui-collapse&quot;&gt; &lt;a class=&quot;mui-navigate-right&quot; href=&quot;#&quot;&gt;面板1&lt;/a&gt; &lt;div class=&quot;mui-collapse-content&quot;&gt; &lt;p&gt;面板1子内容&lt;/p&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 常用按钮123456&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot;&gt;默认&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-primary&quot;&gt;蓝色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-success&quot;&gt;绿色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-warning&quot;&gt;黄色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-danger&quot;&gt;红色&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-royal&quot;&gt;紫色&lt;/button&gt; 操作表123456789101112131415161718192021222324252627&lt;div class=&quot;mui-content&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;handleClick()&quot;&gt;操作表&lt;/button&gt;&lt;/div&gt;&lt;div id=&quot;sheet1&quot; class=&quot;mui-popover mui-popover-bottom mui-popover-action &quot;&gt; &lt;!-- 可选择菜单 --&gt; &lt;ul class=&quot;mui-table-view&quot;&gt; &lt;li class=&quot;mui-table-view-cell&quot;&gt; &lt;a href=&quot;#&quot;&gt;菜单1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell&quot;&gt; &lt;a href=&quot;#&quot;&gt;菜单2&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 取消菜单 --&gt; &lt;ul class=&quot;mui-table-view&quot;&gt; &lt;li class=&quot;mui-table-view-cell&quot;&gt; &lt;a href=&quot;#sheet1&quot;&gt;&lt;b&gt;取消&lt;/b&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; mui.init(); mui.plusReady(function () {}); function handleClick() { mui(&quot;#sheet1&quot;).popover(&quot;toggle&quot;); }&lt;/script&gt; 数字角标123456789101112&lt;span class=&quot;mui-badge&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-primary&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-success&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-warning&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-danger&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-purple&quot;&gt;456&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-inverted&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-primary mui-badge-inverted&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-success mui-badge-inverted&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-warning mui-badge-inverted&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-danger mui-badge-inverted&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;mui-badge mui-badge-royal mui-badge-inverted&quot;&gt;6&lt;/span&gt; 单选框12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;div class=&quot;mui-content&quot;&gt; &lt;div class=&quot;mui-input-row mui-radio&quot;&gt; &lt;label&gt;radio&lt;/label&gt; &lt;input name=&quot;radio2&quot; type=&quot;radio&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;mui-input-row mui-radio&quot;&gt; &lt;label&gt;radio&lt;/label&gt; &lt;input name=&quot;radio2&quot; type=&quot;radio&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;mui-input-row mui-radio mui-left&quot;&gt; &lt;label&gt;面条&lt;/label&gt; &lt;input class=&quot;radio1&quot; name=&quot;radio1&quot; type=&quot;radio&quot; value=&quot;面条&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;mui-input-row mui-radio mui-left&quot;&gt; &lt;label&gt;包子&lt;/label&gt; &lt;input class=&quot;radio1&quot; name=&quot;radio1&quot; type=&quot;radio&quot; value=&quot;包子&quot; checked=&quot;checked&quot; /&gt; &lt;/div&gt; &lt;ul class=&quot;mui-table-view mui-table-view-radio&quot;&gt; &lt;li class=&quot;mui-table-view-cell&quot;&gt; &lt;a class=&quot;mui-navigate-right&quot;&gt;Item 1&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell mui-selected&quot;&gt; &lt;a class=&quot;mui-navigate-right&quot;&gt;Item 2&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;mui-table-view-cell&quot;&gt; &lt;a class=&quot;mui-navigate-right&quot;&gt;Item 3&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;getVals()&quot;&gt;获取值&lt;/button&gt;&lt;/div&gt;&lt;script&gt; mui.init(); mui.plusReady(function () {}); function getVals() { let res = getRadioRes(&quot;radio1&quot;); if (res == null) { mui.toast(&quot;请选择&quot;); return; } mui.toast(res, { duration: &quot;long&quot;, type: &quot;div&quot; }); } function getRadioRes(className) { let rdsObj = document.getElementsByClassName(className); let checkVal = null; for (let i = 0; i &lt; rdsObj.length; i++) { if (rdsObj[i].checked) { checkVal = rdsObj[i].value; } } return checkVal; }&lt;/script&gt; 复选框12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div class=&quot;mui-content&quot;&gt; &lt;div class=&quot;mui-input-row mui-checkbox mui-left&quot;&gt; &lt;label&gt;checkbox左侧显示示例&lt;/label&gt; &lt;input name=&quot;checkbox1&quot; class=&quot;checkbox1&quot; value=&quot;Item 1&quot; type=&quot;checkbox&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;mui-input-row mui-checkbox mui-left&quot;&gt; &lt;label&gt;checkbox左侧显示示例&lt;/label&gt; &lt;input name=&quot;checkbox1&quot; class=&quot;checkbox1&quot; value=&quot;Item 2&quot; type=&quot;checkbox&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;mui-input-row mui-checkbox mui-left&quot;&gt; &lt;label&gt;checkbox左侧显示示例&lt;/label&gt; &lt;input name=&quot;checkbox1&quot; class=&quot;checkbox1&quot; value=&quot;Item 3&quot; type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt; &lt;/div&gt; &lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;getVals()&quot;&gt;获取值&lt;/button&gt;&lt;/div&gt;&lt;script&gt; mui.init(); mui.plusReady(function () {}); function getVals() { let res = getRadioRes(&quot;checkbox1&quot;); if (res.length == 0) { mui.toast(&quot;请选择&quot;); return; } mui.toast(res, { duration: &quot;long&quot;, type: &quot;div&quot; }); } function getRadioRes(className) { let rdsObj = document.getElementsByClassName(className); let checkVal = []; for (let i = 0; i &lt; rdsObj.length; i++) { if (rdsObj[i].checked) { checkVal.push(rdsObj[i].value); } } return checkVal; }&lt;/script&gt; 系统日期选择框12345678910111213141516171819202122232425262728&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;pickDate()&quot;&gt;获取日期&lt;/button&gt;&lt;script&gt; function pickDate() { let dDate = new Date(); // 设置当前日期（不设置默认当前日期） dDate.setFullYear(2016, 7, 16); let minDate = new Date() // 最小时间 minDate.setFullYear(2010, 1, 1); let maxDate = new Date(); // 最大时间 maxDate.setFullYear(2020, 11, 31); plus.nativeUI.pickDate( function(e) { let d = e.date; mui.toast('您选择的日期是:' + d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate()); }, function(e) { mui.toast('你没有选择日期'); }, { title: '请选择日期', date: dDate, minDate: minDate, maxDate: maxDate }) }&lt;/script&gt; 系统时间选择框1234567891011121314151617181920&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;pickTime()&quot;&gt;获取时间&lt;/button&gt;&lt;script&gt; function pickTime(){ var myDate = new Date(); var h = myDate.getHours(); var min = myDate.getMinutes(); var dTime = new Date(); dTime.setHours(h,min); plus.nativeUI.pickTime(function(e){ var d = e.date; mui.toast('您选择的时间是' + d.getHours() + &quot;:&quot; + d.getMinutes()); },function(e){ mui.toast('您没有选择时间') },{ title:'请选择时间', is24Hour: true, time:dTime }) }&lt;/script&gt; 对话框警告框 12345678&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;alert()&quot;&gt;警告框&lt;/button&gt;&lt;script&gt; function alert() { mui.alert('请不要随便点击', '警告消息', '确定', function() { mui.toast('提示对话框上关闭后的回调函数'); }) }&lt;/script&gt; 确认框 123456789101112&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;confirm()&quot;&gt;确认框&lt;/button&gt;&lt;script&gt; function confirm() { mui.confirm('MUI 是个好框架？', 'Hello MUI', new Array('否', '是'), function(e) { if (e.index == 1) { mui.toast('感谢您的支持') } else { mui.toast('MUI 没有得到你的认可，继续加油！'); } }) }&lt;/script&gt; 输入对话框 123456789101112&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;prompt()&quot;&gt;输入对话框&lt;/button&gt;&lt;script&gt; function prompt() { mui.prompt('请输入您对 MUI 的评语', '性能好', 'Hello MUI', new Array('取消', '确认'), function(e) { if(e.index == 1){ mui.toast(e.value); }else{ mui.toast('您取消了输入'); } }); }&lt;/script&gt; 消息提示框 12345678910111213141516&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;shorttoast()&quot;&gt;短的消息提示框&lt;/button&gt;&lt;button type=&quot;button&quot; class=&quot;mui-btn&quot; onclick=&quot;longtoast()&quot;&gt;长的消息提示框&lt;/button&gt;&lt;script&gt; function shorttoast(){ mui.toast('short 消息提示框',{ &quot;duration&quot; : &quot;short&quot; }) } function longtoast(){ mui.toast('long 消息提示框',{ &quot;duration&quot; : &quot;long&quot; }) }&lt;/script&gt; 表单元素1234567891011121314&lt;form class=&quot;mui-input-group&quot;&gt; &lt;div class=&quot;mui-input-row&quot;&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;mui-input-clear&quot; placeholder=&quot;请输入用户名&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mui-input-row&quot;&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;mui-input-password&quot; placeholder=&quot;请输入密码&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mui-button-row&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-primary&quot; &gt;确认&lt;/button&gt; &lt;button type=&quot;button&quot; class=&quot;mui-btn mui-btn-danger&quot; &gt;取消&lt;/button&gt; &lt;/div&gt;&lt;/form&gt; 初始化 mui 在 mui.int() 中会自动初始化基本控件，但是动态添加的元素需要重新进行初始化 1mui('.mui-input-row input').input(); 轮播组件连接模拟器连接模拟器需要用到 ADB 。 12345// 连接模拟器端口adb connect 127.0.0.1:62001// 查看连接设备adb devices 也可以通过 修改 HBuilder 运行配置 Android 模拟器端口 来实现连接。 注意：引入顺序。mui.min.js 需要在 demo渲染前 加载。如果在 demo 渲染后加载会莫名报错 123456789&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;/&gt; &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;/&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=&quot;js/mui.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/mui.min.css&quot; rel=&quot;stylesheet&quot; /&gt; &lt;/head&gt; 以上是我对下列视频及文章的归纳和总结。MUI 视频教程 相关资料HBuilder X 中使用模拟器进行 App 开发ADB 常用命令及其用法大全如何查看夜神模拟器的端口DCloud appid 用途/作用/使用说明Android 平台签名证书(.keystore)生成指南 Android 平台本地（离线）打包指南 - Android Studio Android 平台云端打包证书使用说明manifest.json 文档说明MUI – plus初始化原理及plus is not defined，mui is not defined 错误汇总Hbuilderx真机运行失败,失败原因:手机上没有信任本计算机的授权,请在手机上信任该","link":"/2020/04/08/Blog-about-learning-54/"},{"title":"纯 web 调用手机摄像头扫描二维码 探索","text":"html+js调用手机摄像头扫描二维码根据 html+js调用手机摄像头扫描二维码 文章尝试发现 createObjectURL 废弃了 然后根据 谷歌浏览器更新后无法使用摄像头Failed to execute ‘createObjectURL’ on ‘URL’ 文章修改然后报错 error! notreadableerror could not start video source。………… 下载他的apk运行也报错error could not start audio source。………… jsqrcodemui如何实现扫码功能根据 mui如何实现扫码功能 可以实现扫码。 mui 实现原理是 HTML5+ 相关资料html+js调用手机摄像头扫描二维码谷歌浏览器更新后无法使用摄像头Failed to execute ‘createObjectURL’ on ‘URL’NotReadableError: Failed to allocate videosource用于 JavaScript 的跨浏览器QRCode生成器qrcodejsJavascript QRCode扫描器jsqrcodezxing-typescriptmui如何实现扫码功能 开源instascanhtml5-qrcode","link":"/2020/04/09/Blog-about-learning-56/"},{"title":"这才叫 CSS","text":"上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;style&gt; /* css reset */ html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; } /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } body { line-height: 1; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } table { border-collapse: collapse; border-spacing: 0; } html,body{ height: 100%; font-family: 'Open Sans Light'; line-height: 1.2; } .container { height: 100%; background-image: linear-gradient(to right,#fbc2eb,#a6c1ee); } .login-form{ position: relative; left: 50%; top: 50%; width: 250px; height: 500px; padding: 0 50px; border-radius: 15px; background: #fff; transform: translate(-50%,-50%); } .login-form .bar-nav{ padding: 60px 0; text-align: center; font-size: 25px; font-weight: bold; line-height: 1.2; letter-spacing: 50px; text-indent:50px; } .input-group .input-item{ display: block; width: 100%; padding: 10px; border: 0; margin-bottom: 20px; border-bottom: 1px solid rgb(128, 125, 125); font-size: 15px; outline: none; } .input-group .btn{ width: 100%; padding: 10px; margin-top: 20px; margin-bottom: 20px; background-image: linear-gradient(to right,#a6c1ee,#fbc2eb); color: #fff; text-align: center; } .link-area{ text-align: center; line-height: 1.5; } .link-area a{ text-decoration: none; color: #a6c1ee; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;main class=&quot;container&quot;&gt; &lt;section class=&quot;login-form&quot;&gt; &lt;header class=&quot;bar-nav&quot;&gt; 登陆 &lt;/header&gt; &lt;main class=&quot;input-group&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot; class=&quot;input-item&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot; class=&quot;input-item&quot;/&gt; &lt;button class=&quot;btn&quot;&gt;登陆&lt;/div&gt; &lt;/main&gt; &lt;footer class=&quot;link-area&quot;&gt; 没有账号? &lt;a href=&quot;javascript:;&quot;&gt;注册&lt;/a&gt; &lt;/footer&gt; &lt;/section&gt; &lt;/main&gt; &lt;/body&gt; 以上是我对下列视频及文章的归纳和总结。【每天学一点CSS】CSS 总是可以漂亮到你的心坎上 ~","link":"/2020/04/10/Blog-about-learning-57/"},{"title":"前端开发 直播课&amp;公开课","text":"腾讯课堂慕课网网易云课堂一节课让你面试无惧vue响应式原理 Vue 2 的数据响应式原理 Vue 3 的数据响应式原理 Diff 算法和 virtual dom 什么是 definePropertydefineProperty 其实是定义对象的属性defineProperty 其实并不是核心的为一个对象做数据双向绑定，而是去给对象做属性标签，只不过属性里的 get 和 set 实现了响应式。 属性名 Second Header value undefined get undefined set undefined writable false enumerable false configurable false 123456789101112131415var obj = { a : 1, b : 2}Object.defineProperty(obj,'a',{ writable : false, enumerable : false, configurable : false,})// getOwnPropertyDescriptor 返回指定对象上一个自有属性对应的属性描述符console.log(Object.getOwnPropertyDescriptor(obj,'a'));// output// {value: 1, writable: false, enumerable: false, configurable: false} 面试加分技术点-ssr怎么做什么是 ssr传统的 vue 纯浏览器渲染 这样渲染造成的影响1、不利于SEO；搜索引擎优化2、首屏问题；所有文件都要一次性加载完成，通过按需加载一定程度上缓解3、性能问题；所有渲染都交给浏览器，造成浏览器性能下降。 ssr 123456789101112const vue = require(&quot;vue&quot;);const renderer = require('vue-server-renderer').createRenderer();const app = new vue({ template: `&lt;div&gt;Hellow World&lt;span&gt;{{num}}&lt;/span&gt;&lt;/div&gt;`, data: { num: 123 }})// 将 vue 变成字符串返回renderer.renderToString(app).then(html =&gt; { console.log(html);}) node 123456789101112131415161718192021222324252627282930const vue = require('vue');const server = require('express')();const renderer = require('vue-server-renderer').createRenderer();const fs = require('fs');function createApp(url){ if(url == ''{ url = '/index' })}// 读取对应的数据 数据存在 json 文件中var json = fs.readFileSync(`json${url}.json`,'utf-8');var tempalte = fs.readFileSync(`tempalte${url}.html`,'utf-8');return new vue({ tempalte: tempalte, data: JSON.parse('json').data})server.get(&quot;*&quot;,(req,res) =&gt; { if(req.url != '/favicon.ico'){ const app = createApp(req.url); renderer.renderToString(app).then(html =&gt; { res.end(html); }) }})server.listen(7070) 特性 每一次访问必须新建一个 vue 实例只会触发组件的 beforeCreate 和 creatd 钩子，所以需要客户端 js。 自己动手搭建一个 ssr + vue 项目ssr 需要哪些东西 vue ssr 框架 nuxt分别打包好客户端和服务端加 nginx 代理 vue高级实战技巧-骚操作和最佳实践优化三字经：快（执行快）、小（文件小）、省（减少 http请求）。缓存 - 是所有优化方案里，最常用，最有效的，可以节省 http 请求，可以从内存里最快读取数据 vue3 优化1、优化 diff 对比2、define 改为 proxy3、100kb 到 30kb 函数编程 api 数据缓存资源缓存是浏览器自动缓存 请求缓存思路 缓存架构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// main.jsimport Vue from 'vue'import App from './App.vue'import router from './router'// 1、缓存区域唯一、单一，参考单例模式。// 2、缓存数据不能直接操作// 3、缓存的问题 存在内存中 更新问题解决// v8 标准 64 1.4g 32 0.7gif(!window.mycache){ window.mycache = ( function (){ var cache = {} var cacheArr = [] return { get:function(api){ return new Promise((resolve,reject) =&gt; { if(cache[api]){ resolve(cache[api]) }else{ this.set(api).then(()=&gt;{ if(cacheArr.length == 1){ var _api = cacheArr.shift(); this.remove(_api); } cache[api] = res; cacheArr.push(api); resolve(res); }) } }) }, set:function(api){ return axios.get(api) }, remove:function(){ } } })()}new Vue({ el: '#app', router, render: h =&gt; h(App)}) vue 插件Vue.use原理：判断传入的东西有没有 install,有则执行 install，没有 install 并且传入的是一个方法的话执行传入的东西 Vue.mixin 插件提供逻辑复用注入自定义操作 123456789101112131415161718192021222324252627282930// main.jsvar a = { install:function(vue){ // 生命周期混入 Vue.mixin({ beforeCreate:function(){ // this 指向当前组件 // 拿到当前组件 export default 的对象 // 异步加载 vuex if(this.$options.isVuex){ var name = this.$options.name import('./store/module'+name).then(res =&gt;{ this.$store.registModule(this.$options.name,res.default) }) } }, data:function(){ return { b: 123 } }, methods: { a:function(){ } } }) }}Vue.use(a); vue 底层 api 运用 Vue.util.defineReative：把一个外部数据的改变能够触发 vue 的视图更新vue-router原理 hash 值改变 &gt; 触发 vue-router 对象的 current 变量改变 &gt; 触发视图更新 Vue.extend 1234567891011121314151617181920212223// main.js// 返回一个 vue 的构造Vue.extend({})// index.vue// 调用 弹窗组件&lt;button @click=&quot;show('hello',$ref.cover)&quot;&gt;&lt;/button&gt;&lt;div ref = &quot;cover&quot;&gt;&lt;/div&gt;// 组件import pop from './components/pop.vue'// 弹窗Vue.mixin({ methods: { show:function(mes,el){ const popContructor = Vue.extend(pop); const vm = new popContructor(); vm.$data.mes = mes; vm.$mount (el); } }}) 单元测试 &gt; vue 某个组件的方法执行结果对不对，渲染结果 &gt; 需要拿到 vue 的实例 extend：帮助我们跟 vue 没有关系的系统里能够拿到 vue 的组件实例，并且能够很好的模拟真实挂载状态 利用 render 渲染 render 代替 template：提供用 js 描述 template复杂逻辑 123render:function(h){ h(&quot;h&quot; + this.level)} 相关资料深入响应式原理[视频]网易高级前端开发系列直播课②[视频]网易高级前端开发系列直播课④[视频]网易高级前端开发系列直播课⑤[视频]网易高级前端开发系列直播课⑥[视频]网易高级前端开发系列直播课⑦[视频]网易高级前端开发系列直播课⑧[视频]网易高级前端开发系列直播课⑨[视频]【网易】高级前端4天试学营9.21[视频]【网易】高级前端4天试学营3Vue服务器渲染器Vue.js 服务器端渲染指南前端权威0基础入门 + Web百大项目案例","link":"/2020/04/08/Blog-about-learning-55/"},{"title":"nginx 从入门到实践开发","text":"安装windows下载 machttps://brew.sh/安装目录/usr/local/etc/nginx CentOScd /usr/local/src/ wget http://nginx.org/download/nginx-1.18.0.tar.gz tar zxvf nginx-1.18.0.tar.gz ./configure --prefix=/usr/local/nginx 命令Windows版Nginx使用 cd nginx-1.17.2启动start nginx快速关机（类似于强制关机）./nginx -s stop关机（推荐）./nginx -s quit重新加载./nginx -s reload重新打开./nginx -s reopen测试配置文件nginx.exe -t查看 nginx 进程tasklist /fi “imagename eq nginx.exe” 配置 Nginx配置文件 配置主文件nginx.conf windows host配置C:\\Windows\\System32\\drivers\\etc 站点单独配置文件include servers/*.conf; 相关资料 nginxNginx 详解（正向代理、反向代理、负载均衡原理）Nginx 正向代理配置Nginx开发从入门到精通","link":"/2020/03/31/Blog-about-learning-48/"},{"title":"Android 从入门到实践开发","text":"P1 Android 开发概述和开发工具Android 开发概述Android 是一个开源的，基于Linux的移动设备操作系统，主要使用于移动设备，如智能手机和平板电脑。Android 是由 Google 及其他公司带领的开放手机联盟开发的操作系统。 Android 编程是基于 Java 编程语言的，因此，如果你理解 Java 编程，这将利于你更好的学习 Android 应用程序开发。 Android官网学习 Java Android 开发是移动应用开发的表现形式之一。 Android、iOS、H5 App、Native + H5、RN、Ionic、MUI… 项目流程 Android 开发工具 下载安装 Java JDK 下载安装 Android Studio P2 第一个 Android 应用开始之前，您需要了解有关 Android 应用的两个基本概念：它们如何提供多个入口点，以及它们如何适应不同的设备。 应用提供多个入口点Android 应用由各种可单独调用的组件构成。例如，Activity 是提供界面 (UI) 的一种应用组件。 “主”Activity 在用户点按您的应用图标时启动。您还可以将用户从其他位置（例如，从通知中，甚至从其他应用中）引导至某个 Activity。 应用可适应不同的设备Android 允许您为不同的设备提供不同的资源。例如，您可以针对不同的屏幕尺寸创建不同的布局。系统会根据当前设备的屏幕尺寸确定要使用的布局。 如果应用的任何功能需要特定的硬件，如摄像头，您可以在运行时查询该设备是否具有该硬件，如果没有，则停用相应的功能。您可以指定应用需要特定的硬件，这样，Google Play 就不会允许在没有这些硬件的设备上安装应用。 1、在 Welcome to Android Studio 窗口中，点击 Start a new Android Studio project。 如果您已打开一个项目，请依次选择 File &gt; New &gt; New Project。 2、在 Choose your project 窗口中，选择 Empty Activity，然后点击 Next。3、在 Configure your project 窗口中，完成以下操作： 在 Name 字段中输入“My First App”。 在 Package name 字段中输入“com.example.myfirstapp”。 如果您想将项目放在其他文件夹中，请更改其 Save 位置。 从 Language 下拉菜单中选择 Java 或 Kotlin。 选中 Use androidx.* artifacts 旁边的复选框。 其他选项保持原样。 了解一下最重要的文件。 首先，确保已打开 Project 窗口（依次选择 View &gt; Tool Windows &gt; Project），并从该窗口顶部的下拉列表中选择 Android 视图。随后，您可以看到以下文件： app &gt; java &gt; com.example.myfirstapp &gt; MainActivity 这是主 Activity。它是应用的入口点。当您构建和运行应用时，系统会启动此 Activity 的实例并加载其布局。 app &gt; res 主要的资源文件 app &gt; res &gt; drawable 自定义的 XML 文件和图片 app &gt; res &gt; layout 布局文件 app &gt; res &gt; layout &gt; activity_main.xml 此 XML 文件定义了 Activity 界面的布局。它包含一个 TextView 元素，其中具有“Hello, World!”文本 app &gt; res &gt; values 文字、颜色 app &gt; manifests &gt; AndroidManifest.xml 清单文件描述了应用的基本特性并定义了每个应用组件。 Gradle Scripts &gt; build.gradle 有两个使用此名称的文件：一个针对项目“Project: My First App”，另一个针对应用模块“Module: app”。每个模块均有自己的 build.gradle 文件，但此项目当前仅有一个模块。 运行应用在真实设备上运行按照以下步骤设置设备：1、使用一根 USB 数据线将设备连接到开发计算机。如果您是在 Windows 上开发的，则可能需要为设备安装合适的 USB 驱动程序。2、执行以下步骤，在开发者选项窗口中启用 USB 调试： 打开设置应用。 如果设备使用 Android v8.0 或更高版本，请选择系统。否则，请继续执行下一步 滚动到底部，然后选择关于手机。 滚动到底部，然后点按版本号七次。 回上一屏幕，滚动到底部，然后点按开发者选项。 在开发者选项窗口中，向下滚动以查找并启用 USB 调试。 注意 是版本号 不是 Android版本。 按照以下步骤操作，在设备上运行应用：1、在 Android Studio 中，从工具栏中的运行/调试配置下拉菜单中选择您的应用。2、在工具栏中，从目标设备下拉菜单中选择要用来运行应用的设备。 点击 Run Android Studio 会在连接的设备上安装您的应用并启动它。您现在会看到设备上的应用中显示了“Hello, World!”。 在模拟器上运行按照以下步骤操作，在模拟器上运行应用：1、在 Android Studio 中创建一个 Android 虚拟设备 (AVD)，模拟器可以使用它安装和运行您的应用。2、在工具栏中，从运行/调试配置下拉菜单中选择您的应用。3、从目标设备下拉菜单中，选择要用来运行应用的 AVD。点击 Run Android Studio 会在 AVD 上安装应用并启动模拟器。您现在会看到应用中显示了“Hello, World!”。 在夜深模拟器上运行1、启动 Android Studio2、启动夜深模拟器，设置为 “手机版”，保存后立即重启。3、链接夜深模拟器CMD 打开命令窗口切换到夜深安装目录，例如：D:\\Program Files\\Nox\\bin执行命令连接模拟器 nox_adb.exe connect 127.0.0.1:620014、在 Android Studio 点击 run。通过shift+F10可查看设备(手机/平板/模拟器)的连接情况 P3 线性布局 LinearLayout单位dp在 Android 里通常使用 dp，Android 屏幕碎片化比较严重，所以使用 dp。dp 会根据屏幕分辨率适配。 sp字体使用 sp 布局管理器频繁使用的布局：LinearLayout（线性布局）RelativeLayout（相对布局） LinearLayoutLinearLayout（线性布局）它在单列中水平排布或单列中垂直排列其他视图。 最常用属性 android:idandroid:layout_width：宽度android:layout_height：高度android:background：背景颜色android:layout_weight：对单个子视图进行设置，以指定线性布局如何在其中包含的视图之间划分剩余空间。android:layout_margin：外边距android:layout_padding：内边距android:orientation：以指定子视图显示在行还是列中。android:gravity：以指定行或列中所有子视图的水平和垂直对齐方式。android:layout_weight：权重 以下代码段显示了如何在布局 XML 文件中包括线性布局： 123456789101112&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;16dp&quot; android:paddingRight=&quot;16dp&quot; android:orientation=&quot;horizontal&quot; android:gravity=&quot;center&quot;&gt; &lt;!-- Include other widget or layout tags here. These are considered &quot;child views&quot; or &quot;children&quot; of the linear layout --&gt;&lt;/LinearLayout&gt; 示例： 1234567891011121314151617181920212223&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/box&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#000&quot; android:orientation=&quot;vertical&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot;&gt; &lt;view android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; /&gt; &lt;view android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; LinearLayout orientation=”horizontal” 默认子视图以行显示。orientation=”vertical” 以指定子视图以列显示。layout_width=”match_parent” 继承父元素宽度layout_width=”wrap_content” 根据内容 示例：gravity 用法 1234567891011121314151617181920&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/box&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#000&quot; android:orientation=&quot;horizontal&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:gravity=&quot;center_horizontal&quot;&gt; &lt;view android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 示例：layout_weight 用法，等比分 1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/box&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;horizontal&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:gravity=&quot;center_horizontal&quot;&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;#ADFF2F&quot; android:text=&quot;one&quot;/&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; android:background=&quot;#DA70D6&quot; android:text=&quot;two&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; P4 相对布局 RelativeLayoutRelativeLayoutRelativeLayout（相对布局）可以相对于彼此或相对于父项描述子项位置布局。 最常用属性 android:layout_toLeftOf：在谁的左边android:layout_toRightOf：在谁的右边android:layout_alignBottom：跟谁底部对齐android:layout_alignParentBottom：跟父空间底部对齐android:layout_below：在谁的下边 官网示例： 123456789101112131415161718192021222324252627282930&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingLeft=&quot;16dp&quot; android:paddingRight=&quot;16dp&quot; &gt; &lt;EditText android:id=&quot;@+id/name&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;Reminder name&quot; /&gt; &lt;Spinner android:id=&quot;@+id/dates&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/name&quot; android:layout_alignParentLeft=&quot;true&quot; android:layout_toLeftOf=&quot;@+id/times&quot; /&gt; &lt;Spinner android:id=&quot;@id/times&quot; android:layout_width=&quot;96dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/name&quot; android:layout_alignParentRight=&quot;true&quot; /&gt; &lt;Button android:layout_width=&quot;96dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_below=&quot;@id/times&quot; android:layout_alignParentRight=&quot;true&quot; android:text=&quot;Done&quot; /&gt;&lt;/RelativeLayout&gt; 父容器定位属性示意图 示例 123456789101112131415161718192021222324252627282930313233343536373839&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#f0f&quot; android:layout_alignParentLeft=&quot;true&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#ff0&quot; android:layout_alignParentRight=&quot;true&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#ff0&quot; android:layout_alignParentTop=&quot;true&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#00f&quot; android:layout_alignParentBottom=&quot;true&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#00f&quot; android:layout_centerHorizontal=&quot;true&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#00f&quot; android:layout_centerVertical=&quot;true&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#00f&quot; android:layout_centerInParent=&quot;true&quot;/&gt;&lt;/RelativeLayout&gt; 呈现效果： 根据兄弟组件定位 示例： 123456789101112131415161718192021222324252627282930313233343536373839&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;View android:id=&quot;@+id/view_1&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#f0f&quot; android:layout_centerInParent=&quot;true&quot; /&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#ff0&quot; android:layout_centerInParent=&quot;true&quot; android:layout_toRightOf=&quot;@+id/view_1&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#00f&quot; android:layout_centerInParent=&quot;true&quot; android:layout_toLeftOf=&quot;@+id/view_1&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#33a3dc&quot; android:layout_centerInParent=&quot;true&quot; android:layout_above=&quot;@+id/view_1&quot;/&gt; &lt;View android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#9933CC&quot; android:layout_centerInParent=&quot;true&quot; android:layout_below=&quot;@+id/view_1&quot;/&gt;&lt;/RelativeLayout&gt; P5 TextView 文字大小、颜色 显示不下使用… 文字 + icon 中划线、下划线 跑马灯 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/app_name&quot; android:textColor=&quot;#0ff&quot; android:textSize=&quot;28sp&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_2&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:ellipsize=&quot;end&quot; android:maxLines=&quot;1&quot; android:text=&quot;@string/app_name&quot; android:textColor=&quot;#0ff&quot; android:textSize=&quot;28sp&quot; android:singleLine=&quot;true&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/app_name&quot; android:textColor=&quot;#0ff&quot; android:textSize=&quot;28sp&quot; android:drawableRight=&quot;@drawable/unfold&quot; android:drawablePadding=&quot;10dp&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/app_name&quot; android:textColor=&quot;#0ff&quot; android:textSize=&quot;28sp&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/app_name&quot; android:textColor=&quot;#0ff&quot; android:textSize=&quot;28sp&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_6&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;18sp&quot; android:singleLine=&quot;true&quot; android:ellipsize=&quot;marquee&quot; android:marqueeRepeatLimit=&quot;marquee_forever&quot; android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; android:text=&quot;你整天说着日了狗日了狗，但是你却没有来，呵呵呵呵呵呵呵呵呵呵~&quot;/&gt;&lt;/LinearLayout&gt; 12345678910111213141516171819202122232425import androidx.appcompat.app.AppCompatActivity;import android.graphics.Paint;import android.os.Bundle;import android.widget.Button;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private TextView mTv4,mTv_5; private Button mBtnTextView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTv4 = findViewById(R.id.tv_4); mTv4.getPaint().setFlags(Paint.STRIKE_THRU_TEXT_FLAG); // 中划线 mTv4.getPaint().setAntiAlias(true); // 去除锯齿 mTv_5 = findViewById(R.id.tv_5); mTv_5.getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG); // 下划线 }} Java 我忘得差不多了，也因为时间原因，后续复习完 java 再回来整理。 File/Sync Project with Gradle Files //同步 Gradle 文件 Tools/SDK Manager/Android SDK 建议把 5 以上都勾选上 以上是我对下列视频及文章的归纳和总结。Android 开发视频教程最新版 Android Studio 开发 相关资料Android 基础入门教程应用开发者文档Android Studio与夜神模拟器的环境搭建&amp;开发调试 Minimum supported Gradle version is 6.1.1. Current version is 5.6.4.√ 一招解决gradle依赖库国内下载不了的问题√ Android Studio Error:Connection timed out: connect.√ gradle 下载地址√ 解决org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration$ArtifactResolveException 相关工具Genymotion：简化 Android 测试","link":"/2020/03/07/Blog-about-learning-33/"},{"title":"别慌，不就是跨域么!","text":"什么是跨域跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全限制。 同源策略限制了以下行为：Cookie、LocalStorage 和 IndexDB 无法读取；DOM 和 JS 对象无法获取；Ajax请求发送不出去；（不准确，我记得是可以发送出去，但是接受的时候会遭到浏览器拦截过滤。） 常见的跨域场景同源是指，域名、协议、端口均为相同。 http://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 非跨域http://www.nealyang.cn/index.html 调用 http://www.neal.cn/server.php 跨域,主域不同http://abc.nealyang.cn/index.html 调用 http://def.neal.cn/server.php 跨域,子域名不同http://www.nealyang.cn:8080/index.html 调用 http://www.nealyang.cn/server.php 跨域,端口不同https://www.nealyang.cn/index.html 调用 http://www.nealyang.cn/server.php 跨域,协议不同localhost 调用 127.0.0.1 跨域 跨域的解决办法jsonp 跨域jsonp 跨域其实也是 JavaScript 设计模式中的一种代理模式。在 html 页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信原生的实现方式： 1234567//原生的实现方式let script = document.createElement('script');script.src = 'http://www.nealyang.cn/login?username=Nealyang&amp;callback=callback';document.body.appendChild(script);function callback(res) { console.log(res);} jquery： 123456789$.ajax({ url:'http://www.nealyang.cn/login', type:'GET', dataType:'jsonp',//请求方式为jsonp jsonpCallback:'callback', data:{ &quot;username&quot;:&quot;Nealyang&quot; }}) 虽然这种方式非常好用，但是一个最大的缺陷是，只能够实现 get 请求 document.domain + iframe 跨域这种跨域的方式最主要的是要求主域名相同。什么是主域名相同呢？www.nealyang.cn、aaa.nealyang.cn、ba.ad.nealyang.cn 这三个主域名都是nealyang.cn,而主域名不同的就不能用此方法。 假设目前a.nealyang.cn 和 b.nealyang.cn 分别对应指向不同ip的服务器。a.nealyang.cn 下有一个test.html文件 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;html&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src = &quot;jquery-1.12.1.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;A页面&lt;/div&gt; &lt;iframe style = &quot;display : none&quot; name = &quot;iframe1&quot; id = &quot;iframe&quot; src=&quot;http://b.nealyang.cn/1.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ try{ document.domain = &quot;nealyang.cn&quot; }catch(e){} $(&quot;#iframe&quot;).load(function(){ var jq = document.getElementById('iframe').contentWindow.$ jq.get(&quot;http://nealyang.cn/test.json&quot;,function(data){ console.log(data); }); }) }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 利用 iframe 加载其他域下的文件（nealyang.cn/1.html）, 同时 document.domain 设置成 nealyang.cn ，当 iframe 加载完毕后就可以获取 nealyang.cn 域下的全局对象， 此时尝试着去请求 nealyang.cn 域名下的 test.json （此时可以请求接口），就会发现数据请求失败了~~ 惊不惊喜，意不意外！！！！！！！数据请求失败，目的没有达到，自然是还少一步： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;html&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src = &quot;jquery-1.12.1.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function(){ try{ document.domain = &quot;nealyang.com&quot; }catch(e){} }) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id = &quot;div1&quot;&gt;B页面&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 此时在进行刷新浏览器，就会发现数据这次真的是成功了~~~~~ window.name + iframe 跨域window.name属性可设置或者返回存放窗口名称的一个字符串。他的神奇之处在于name值在不同页面或者不同域下加载后依旧存在，没有修改就不会发生变化，并且可以存储非常长的name(2MB) 假设index页面请求远端服务器上的数据，我们在该页面下创建iframe标签，该iframe的src指向服务器文件的地址（iframe标签src可以跨域），服务器文件里设置好window.name的值，然后再在index.html里面读取改iframe中的window.name的值。完美~ 12345678910&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; iframe = document.createElement('iframe'), iframe.src = 'http://localhost:8080/data.php'; document.body.appendChild(iframe); iframe.onload = function() { console.log(iframe.contentWindow.name) }; &lt;/script&gt;&lt;/body&gt; 当然，这样还是不够的。因为规定如果index.html页面和和该页面里的iframe框架的src如果不同源，则也无法操作框架里的任何东西，所以就取不到iframe框架的name值了，告诉你我们不是一家的，你也休想得到我这里的数据。 既然要同源，那就换个src去指，前面说了无论怎样加载window.name值都不会变化，于是我们在index.html相同目录下，新建了个proxy.html的空页面，修改代码如下： 1234567891011&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; iframe = document.createElement('iframe'), iframe.src = 'http://localhost:8080/data.php'; document.body.appendChild(iframe); iframe.onload = function() { iframe.src = 'http://localhost:81/cross-domain/proxy.html'; console.log(iframe.contentWindow.name) }; &lt;/script&gt;&lt;/body&gt; 理想似乎很美好，在iframe载入过程中，迅速重置iframe.src的指向，使之与index.html同源，那么index页面就能去获取它的name值了！但是现实是残酷的，iframe在现实中的表现是一直不停地刷新， 也很好理解，每次触发onload时间后，重置src，相当于重新载入页面，又触发onload事件，于是就不停地刷新了（但是需要的数据还是能输出的）。修改后代码如下： 123456789101112131415161718192021&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; iframe = document.createElement('iframe'); iframe.style.display = 'none'; var state = 0; iframe.onload = function() { if(state === 1) { var data = JSON.parse(iframe.contentWindow.name); console.log(data); iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); } else if(state === 0) { state = 1; iframe.contentWindow.location = 'http://localhost:81/cross-domain/proxy.html'; } }; iframe.src = 'http://localhost:8080/data.php'; document.body.appendChild(iframe);&lt;/script&gt;&lt;/body&gt; 所以如上，我们就拿到了服务器返回的数据，但是有几个条件是必不可少的：iframe标签的跨域能力window.names 属性值在文档刷新后依然存在的能力 location.hash + iframe 跨域此跨域方法和上面介绍的比较类似，一样是动态插入一个iframe然后设置其src为服务端地址，而服务端同样输出一端js代码，也同时通过与子窗口之间的通信来完成数据的传输。关于锚点相信大家都已经知道了，其实就是设置锚点，让文档指定的相应的位置。锚点的设置用a标签，然后href指向要跳转到的id，当然，前提是你得有个滚动条，不然也不好滚动嘛是吧。而location.hash其实就是url的锚点。比如http://www.nealyang.cn#Nealyang的网址打开后，在控制台输入location.hash就会返回#Nealyang的字段。基础知识补充完毕，下面我们来说下如何实现跨域如果index页面要获取远端服务器的数据，动态的插入一个iframe，将iframe的src执行服务器的地址，这时候的top window 和包裹这个iframe的子窗口是不能通信的，因为同源策略，所以改变子窗口的路径就可以了，将数据当做改变后的路径的hash值加载路径上，然后就可以通信了。将数据加在index页面地址的hash上， index页面监听hash的变化，h5的hashchange方法 12345678910111213141516171819202122&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt; function getData(url, fn) { var iframe = document.createElement('iframe'); iframe.style.display = 'none'; iframe.src = url; iframe.onload = function() { fn(iframe.contentWindow.location.hash.substring(1)); window.location.hash = ''; document.body.removeChild(iframe); }; document.body.appendChild(iframe); } // get data from server var url = 'http://localhost:8080/data.php'; getData(url, function(data) { var jsondata = JSON.parse(data); console.log(jsondata.name + ' ' + jsondata.age); });&lt;/script&gt;&lt;/body&gt; 补充说明：其实location.hash和window.name都是差不多的，都是利用全局对象属性的方法，然后这两种方法和jsonp也是一样的，就是只能够实现get请求 postMessage跨域这是由H5提出来的一个炫酷的API，IE8+，chrome,ff都已经支持实现了这个功能。这个功能也是非常的简单，其中包括接受信息的Message时间，和发送信息的postMessage方法。发送信息的postMessage方法是向外界窗口发送信息 otherWindow.postMessage(message,targetOrigin); otherWindow指的是目标窗口，也就是要给哪一个window发送消息，是 window.frames 属性的成员或者是 window.open 方法创建的窗口。 Message 是要发送的消息，类型为String，Object(IE8、9不支持Obj)，targetOrigin是限定消息接受范围，不限制就用星号 *接受信息的message事件 12345678910var onmessage = function(event) { var data = event.data; var origin = event.origin;}if(typeof window.addEventListener != 'undefined'){ window.addEventListener('message',onmessage,false);}else if(typeof window.attachEvent != 'undefined'){ window.attachEvent('onmessage', onmessage);} 举个栗子a.html(http://www.nealyang.cn/a.html) 12345678910111213141516&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.neal.cn/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'aym' }; // 向neal传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.neal.cn'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from neal ---&gt; ' + e.data); }, false);&lt;/script&gt; b.html(http://www.neal.cn/b.html) 123456789101112&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) { alert('data from nealyang ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回nealyang window.parent.postMessage(JSON.stringify(data), 'http://www.nealyang.cn'); } }, false);&lt;/script&gt; 跨域资源共享 CORS因为是目前主流的跨域解决方案。所以这里多介绍点。简介CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。两种请求说起来很搞笑，分为两种请求，一种是简单请求，另一种是非简单请求。只要满足下面条件就是简单请求请求方式为HEAD、POST 或者 GEThttp头信息不超出以下下字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type(限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain) 为什么要分为简单请求和非简单请求，因为浏览器对这两种请求方式的处理方式是不同的。 简单请求基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0… Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。 浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin 字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的 onerror 回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以Access-Control-开头Access-Control-Allow-Origin :该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在 CORS 请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送 Cookie，删除该字段即可。Access-Control-Expose-Headers:该字段可选。CORS 请求时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。withCredentials 属性上面说到，CORS请求默认不发送 Cookie 和 HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。 123456789101112131415161718192021var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { alert(xhr.responseText); }};// jquery$.ajax({ ... xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...}); 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略withCredentials 设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭 withCredentials。需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或者 Content-Type 字段的类型是 application/json。非简单请求的CORS请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0… “预检”请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。Access-Control-Request-Method：该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些HTTP方法，上例是PUT。Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是X-Custom-Header预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应 HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。服务器回应的其他CORS相关字段如下： Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。Access-Control-Allow-Headers：如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。Access-Control-Allow-Credentials： 该字段与简单请求时的含义相同。Access-Control-Max-Age： 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。浏览器正常请求回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0…浏览器的正常CORS请求。上面头信息的Origin字段是浏览器自动添加的。下面是服务器正常的回应。 Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8Access-Control-Allow-Origin字段是每次回应都必定包含的结束语CORS与JSONP的使用目的相同，但是比JSONP更强大。JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---&gt; ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); });});document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value);};&lt;/script&gt; node Server 1234567891011121314151617181920212223242526var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) { res.writeHead(200, { 'Content-type': 'text/html' }); res.end();});server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); });}); node代理跨域node中间件实现跨域代理，是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。利用node + express + http-proxy-middleware搭建一个proxy服务器前端代码 12345678var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);xhr.send(); 后端代码 12345678910111213141516171819var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改}));app.listen(3000);console.log('Proxy server is listen at port 3000...'); 这篇文章是我从我之前的学习资料里找到的。","link":"/2020/12/05/Blog-about-learning-38/"},{"title":"Cordova 从入门到实践开发","text":"简单认知 Cordova什么是 Cordova 一个移动应用开发框架 本质是 HTML、CSS、JavaScript 外面包装个原生的壳 出自于 Adobe 11 年收购的 PhoneGap，是驱动 PhoneGap 的核心引擎 是 Apache 的顶级开源项目 Cordova 提供了一系列设备相关的 API，通过这组 API，移动应用能够以 JavaScript 访问原生的设备功能，如摄像头、麦克风。 三种移动开发的分类常见的移动端开发的三大分类1、原生 App2、Web App3、混合 App（Hybrid App） Cordova 的优缺点优点：跨平台，便于移植，开发快速，成本低。缺点：执行速度相对原生会慢一些，一次编写，要处处调试。 Cordova 的架构 Web App：存放应用程序代码的地方，体现是你的具体业务逻辑模块。 WebView：给应用提供完整的用户访问呈现。 Cordova Plugins：提供了和原生组件通信的接口并绑定到了标准的设备 API,将来通过 JavaScript 来调用。 Cordova 环境配置Cordova 在整个 App 领域中的位置 Cordova 环境安装1、Git 的安装2、Node.js 的安装3、安装 Cordova Cli 下载并安装 Cordova 全局模块4、安装 Java JDK5、安装 Android Studio 安装 Android SDK 123npm install -g cordova / cnpm install -g cordova npm install -g cordova --registry=https://registry.npm.taobao.orgcnpm install -g cordova@8.1.2 // 安装指定版本 第一个应用程序的编译12cordova --version // 查看 cordova 安装的版本10.0.0 创建项目12345cordova create 项目名 com.公司名.项目名 类名（建议） // 创建一个空的Cordova项目cordova create cordovademo02 com.itying.cordova Cordovademocordova create MyApp // 创建一个空的Cordova项目cordova help create // 要获得完整的选项集，请运行 cordova 创建项目报错解决方法： 123卸载 cordova npm uninstall -g cordova删掉 cordova 文件 npm\\node_modules\\cordovanpm install -g cordova --registry=https://registry.npm.taobao.org 添加平台123cd MyAppcordova platform add android // 添加平台cordova platform // 获取完整的平台列表,请运行 运行项目1cordova run android 项目的 platforms 下 android目录 导入 android studio 进行运行调试 （或者运行 cordova run android） 创建项目的时候注意包名称：发布上线打包的时候用到包名称，注意 修改应用包名称参考：http://www.ionic.wang/article-index-id-91.html 1、修改 config.xml 里面的包名称 2、修改完成以后重新执行 cordova platform add android 修改项目后，运行 cordova prepare 实际编译 platforms \\android\\app\\src\\main\\assets\\www 编译项目1cordova build android 打包报错123456Checking Java JDK and Android SDK versionsANDROID_SDK_ROOT=undefined (recommended setting)ANDROID_HOME=F:\\software\\Android\\Sdk (DEPRECATED)Could not find an installed version of Gradle either in Android Studio,or on your system to install the gradle wrapper. Please include gradlein your path, or install Android Studio 方法一： 用 Android Studio 打开 Android 目录 进项打包。 包所在的位置：android\\app\\build\\outputs\\apk\\debug 方法二： 根据上面的报错信息可以得出1、没有找到 Gradle2、需要设置环境变量 ANDROID_SDK_ROOT3、Android SDK 在 F:\\software\\Android\\Sdk 如果不知道 Android SDK 在什么位置可以如下操作： 打开 Android Studio 环境变量配置如下 初次安装 Android Studio 时会安装 gradle 在上面路径基础上 + \\wrapper\\dists 你就会看到 gradle 的包了。例如：C:\\Users\\86183.gradle + \\wrapper\\dists 在系统变量中 path 下添加 gradle/bin 的路径 例如：C:\\Users\\86183.gradle\\wrapper\\dists\\gradle-5.6.4-all\\ankdp27end7byghfw1q2sw75f\\gradle-5.6.4\\bin 再次打包 123456789101112131415161718192021222324252627282930313233343536373839Checking Java JDK and Android SDK versionsANDROID_SDK_ROOT=D:\\software\\Android\\Sdk (recommended setting)ANDROID_HOME=D:\\software\\Android\\Sdk (DEPRECATED)Subproject Path: CordovaLibSubproject Path: appFAILURE: Build failed with an exception.* Where:Build file 'D:\\MyApp\\platforms\\android\\app\\build.gradle' line: 20* What went wrong:A problem occurred evaluating project ':app'.&gt; Failed to apply plugin [id 'com.android.internal.version-check'] &gt; Minimum supported Gradle version is 5.6.4. Current version is 4.10.3. If using the gradle wrapper, try editing the distributionUrl in D:\\MyApp\\gradle\\wrapper\\gradle-wrapper.properties to gradle-5.6.4-all.zip* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 3sD:\\MyApp\\platforms\\android\\gradlew: Command failed with exit code 1 Error output:FAILURE: Build failed with an exception.* Where:Build file 'D:\\MyApp\\platforms\\android\\app\\build.gradle' line: 20* What went wrong:A problem occurred evaluating project ':app'.&gt; Failed to apply plugin [id 'com.android.internal.version-check'] &gt; Minimum supported Gradle version is 5.6.4. Current version is 4.10.3. If using the gradle wrapper, try editing the distributionUrl in D:\\MyApp\\gradle\\wrapper\\gradle-wrapper.properties to gradle-5.6.4-all.zip* Try:Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.* Get more help at https://help.gradle.orgBUILD FAILED in 3s 根据报错手动修改了 项目中的 gradle 版本 项目\\gradle\\wrapper\\gradle-wrapper.properties 中的 gradle-4.10.3-all.zip 修改为 gradle-5.6.4-all.zip 再次打包，还是报错，并且文件又被修改回去了。而且还下载了 gradle-4.10.3-all.zip 包。 不要用 Android Studio 打开 android 目录，Android Studio 很可能会更改 Cordova 配置。 第一个项目的目录大致认知 config.xml 配置页，配置起始页项目名称等基础内容 hooks 存放一些自定义扩展功能 platforms 存放添加的 platform 运行时 plugins 存放引入的插件 www 开发的 HTML5 目录 实际打包文件 platforms /android/app/src/main/assets/www 第一个应用程序功能改造cordova 通过 document.addEventListener 来监听事件 123// 当 Cordova 完全加载好 deviceready 事件会触发。这个事件对每一个应用程序都是必须的。他是 Cordova 设备 API 准备好并可以访问的信号。// Cordova 由两个代码库组成：原生(native)和JavaScript。document.addEventListener(&quot;deviceready&quot;, function() {}); 重写功能源码：实现功能 让 .listening 隐藏 让 .received 显示 123456789101112131415161718192021222324252627var app = { initialize: function() { // deviceready 等待设备 api 的加载 document.addEventListener( &quot;deviceready&quot;, this.onDeviceReady.bind(this), false ); }, onDeviceReady: function() { this.receivedEvent(&quot;deviceready&quot;); }, receivedEvent: function(id) { var parentElement = document.getElementById(id); var listeningElement = parentElement.querySelector(&quot;.listening&quot;); var receivedElement = parentElement.querySelector(&quot;.received&quot;); listeningElement.setAttribute(&quot;style&quot;, &quot;display:none;&quot;); receivedElement.setAttribute(&quot;style&quot;, &quot;display:block;&quot;); console.log(&quot;Received Event: &quot; + id); }};app.initialize(); 重写代码： 1234567891011121314// 添加 deviceready 监听，等待设备 api 的加载document.addEventListener(&quot;deviceready&quot;, function() { console.log(&quot;设备 api 准备就绪&quot;); // 让 listening 隐藏 // 让 received 显示 setTimeout(() =&gt; { var listening = document.querySelector(&quot;.listening&quot;); var received = document.querySelector(&quot;.received&quot;); listening.style.display = &quot;none&quot;; received.style.display = &quot;block&quot;; }, 2000);}); Cordova 事件的基本监听Cordova 插件和事件说明Cordova 对于设备功能的封装，都是以事件或插件体现的 插件即 plugin，封装了设备提供的功能，如摄像头、通讯录、GPS 等，他们是以自定义的 js 根对象或者覆盖标准对象的方式提供的，插件需要单独安装才能使用。 Cordova 事件概览 事件名称 说明 deviceready 当 Cordova 加载完成后该事件被触发 pause 当应用程序被置于后台，则触发此事件 resume 当应用程序从后台返回，则触发此事件 backbutton 当按下后退按钮时，则触发此事件 …… …… Cordova 事件的使用所有的事件调用方式类似，通过 js 进行事件监听即可（addEventListener） 12345678document.addEventListener(&quot;deviceready&quot;, onDeviceReady,false);function onDeviceReady() { document.addEventListener(&quot;pause&quot;, onPause, false); document.addEventListener(&quot;resume&quot;, onResume, false); document.addEventListener(&quot;menubutton&quot;, onMenuKeyDown, false); //给其他事件添加类似的监听} Cordova 应用启动流程html 页面加载流程1、原生代码启动2、splashscreen3、load html4、顺序执行 JavaScript =&gt; cordova.js 也执行5、$(document).ready() 执行，cordova 中的事件不一定可用。6、注册 deviceready 事件 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * Cordova 对于设备 api 的封装，都是以 插件 和 事件 的方式体现的 * Cordova 中对于事件的监听，都类似 *//* * 1、deviceready 设备 api 准备就绪时，执行 * 基于设备 api 的一些底层事件 或方法，都要在 deviceready 事件调用完成后，执行 * 2、pause 当应用挂起进入后台时，调用执行 * 3、resume 当应用回到最前面时，调用执行 * 4、backbutton 当返回键被点击时，调用 *//* * deviceready 设备 api 准备就绪时，调用 * 参数1：事件名 * 参数2：回调函数 * 参数3：是否在捕获阶段执行，默认 false（冒泡阶段执行），直接默认即可 */// 等待是底层 cordova 相关的一些设备代码的加载document.addEventListener(&quot;deviceready&quot;, function() { log(&quot;设备api准备就绪, 可以进行其他方法的调用 或者 事件的监听&quot;); // 添加应用挂起监听 document.addEventListener(&quot;pause&quot;, function() { log(&quot;应用程序被挂起了&quot;); }); document.addEventListener(&quot;resume&quot;, function() { log(&quot;应用程序回来了&quot;); }); document.addEventListener(&quot;backbutton&quot;, function() { log(&quot;返回键被点击了&quot;); });});// 输出日志内容到屏幕body中function log(msg) { var p = document.createElement(&quot;p&quot;); p.style.fontSize = &quot;14px&quot;; p.innerHTML = msg; // 输出到 body 中 document.body.appendChild(p);} 卸载插件1cordova plugin rm cordova-plugin-network-information Cordova 插件的使用设备1、安装插件 1cordova plugin add cordova-plugin-device 网络1、安装插件 1cordova plugin add cordova-plugin-network-information 设备位置1、安装插件 1cordova plugin add cordova-plugin-geolocation 文件1、安装插件 12cordova plugin add cordova-plugin-file-transfer // 文件传输插件cordova plugin add cordova-plugin-file // 文件插件 电池状态1、安装电池插件 1cordova plugin add cordova-plugin-battery-status 2、添加事件监听 事件监听必须在 deviceready 调用完成后调用，且必须通过 window 添加监听 1234567891011document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false);function onDeviceReady() { window.addEventListener(&quot;batterystatus&quot;, onBatteryStatus, false);}function onBatteryStatus(status) { console.log( &quot;电池状态：Level: &quot; + status.level + &quot; isPlugged: &quot; + status.isPlugged );} 事件会返回一个 status 对象，有两个属性level：当前电量的百分比值，范围（0-100）number 数值类型isPlugged：标记当前手机是否在充电 boolean 类型 三个事件： 事件名称 事件说明 batterystatus 当电池发生 1%的变化时触发, 或者充电状态发生切换时触发 batterylow 当电池电量百分比达到了较低的值时，则触发此事件。此值在不同的设备可能有所不同。 batterycritical 当电池电量百分比达到临界值时，则触发此事件。此值在不同的设备可能有所不同。 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// cordova 对于插件的使用, 需要先进行安装// 1. 安装插件 cordova plugin add cordova-plugin-battery-status// 2. 该插件可以用于监视设备电池的变化// 全局提供了三个事件// (1) batterystatus 表示电池状态发生改变 (至少1%电量变化) 或者 充电状态改变 触发// (2) batterycritical 表示电池电量进入临界值, 快关机了// (3) batterylow 表示电池电量比较低, 触发// 注意点: 插件的事件监听以及插件方法的调用, 一定要在 deviceready 准备完成后调用// 所有的事件, 都会返回一个 status 对象, 这个对象有两个属性// (1) status.level 表示设备电池电量的百分比 (0-100) number// (2) status.isPlugged 表示设备是否正在充电 boolean值 true 在充电, false 不在充电// 等待 cordova 设备api的加载document.addEventListener(&quot;deviceready&quot;, function() { // cordova 设备api的加载完成, 可以添加事件监听 window.addEventListener(&quot;batterystatus&quot;, onBatterystatus); window.addEventListener(&quot;batterycritical&quot;, onBatterycritical); window.addEventListener(&quot;batterylow&quot;, onBatterylow);});function onBatterystatus(status) { log(&quot;当前电量: &quot; + status.level + &quot;是否充电中: &quot; + status.isPlugged);}function onBatterycritical(status) { log( &quot;当前电量已经进入临界值, 当前电量: &quot; + status.level + &quot;是否充电中: &quot; + status.isPlugged );}function onBatterylow(status) { log( &quot;当前电量已经比较低了, 当前电量: &quot; + status.level + &quot;是否充电中: &quot; + status.isPlugged );}// 输出日志内容到屏幕body中function log(msg) { var p = document.createElement(&quot;p&quot;); p.style.fontSize = &quot;14px&quot;; p.innerHTML = msg; // 输出到 body 中 document.body.appendChild(p);} 照相机这个插件定义了一个全局的 navigator.camera 对象, 这个对象提供了用于拍照或者使用图库文件的 API 这个对象, 只在 deviceready 事件触发后, 才可用。 1、安装照相机插件 1cordova plugin add cordova-plugin-camera 2、拍照功能 123456789101112131415161718注意：ios 拍照完成以后调用 navigator.camera.cleanup(onSuccess, onFail); 清除照片缓存// 拍照功能function takePicure() { // 调用插件api提供的 navigator.camera 全局对象 navigator.camera.getPicture( onSuccess, onFail, { quality: 50, destinationType: Camera.DestinationType.DATA_URL }); function onSuccess(imageData) { var img = document.querySelector(&quot;img&quot;); img.src = &quot;data:image/jpeg;base64,&quot; + imageData; } function onFail(message) { console.log( &quot;failed because &quot; + message ); }} 3、相册读取图片 1234567891011121314151617 // 选择照片功能function selectPicure() { navigator.camera.getPicture(onSuccess, onFail, { quality: 50, destinationType: Camera.DestinationType.NATIVE_URI, sourceType: Camera.PictureSourceType.PHOTOLIBRARY }); function onSuccess(imageURL) { var img = document.querySelector(&quot;img&quot;); img.src = imageURL; } function onFail(message) { console.log('Failed because: ' + message); }} 参数名 配置值 quality 在 0-100 的范围内的图像质量。默认值是 50。 destinationType DATA_URL 或 0 返回 base64 编码字符串 FILE_URI 或 1 返回图像文件 URI NATIVE_URI 或 2 返回图像本地 URI sourceType PHOTOLIBRARY 或 0 打开照片库 CAMERA 或 1 打开机摄像头 SAVEDPHOTOALBUM 或 2 打开保存相册 allowEdit 允许图像编辑 encodingType JPEG 或 0 返回 JPEG 编码的图像 PNG 或 1 返回 PNG 编码的图像 targetWidth 图像中的像素缩放宽度 targetHeight 图像中的像素比例的高度 cameraDirection FRONT 或 0 前置摄像头 BACK 或 1 后置摄像头 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// cordova中提供了, 可以调用摄像头设备的 api, 需要安装对应的插件// 1. 添加插件 cordova plugin add cordova-plugin-camera// 2. 这个插件提供了一个全局对象 navigator.camera 提供了一系列的api// 这些api, 可以帮助我们拍照, 或者从相册中读取图片// 注意: 需要在 deviceready 完成后, 才能获取 navigator.camera 对象// 在 navigator.camera 对象中, 提供了一个方法, getPicture( success, error, options );// getPicture 可以用于拍照 或者 从相册中读取图片// options参数:// (1) quality: 表示图片质量// (2) destinationType: 表示返回的图片格式 (路径/还是base64格式的字符串)// 默认值: FILE_URI 返回文件路径// (3) sourceType: 设置使用摄像头, 还是从相册读取// 默认值 CAMERA 使用摄像头/* 需求: 1. 点击按钮, 拍摄照片, 显示在页面中 2. 点击按钮, 从相册中, 找到图片, 显示在页面中*/// 找对象var btn1 = document.getElementById(&quot;btn1&quot;); // 拍照var btn2 = document.getElementById(&quot;btn2&quot;); // 拍照-返回base64格式var btn3 = document.getElementById(&quot;btn3&quot;); // 从相册中选图片var img = document.querySelector(&quot;img&quot;); // 获取图片dom对象document.addEventListener(&quot;deviceready&quot;, function() { // 等待设备 api 的加载 // console.log( navigator.camera ); btn1.addEventListener(&quot;click&quot;, takePic); btn2.addEventListener(&quot;click&quot;, takePicBase64); btn3.addEventListener(&quot;click&quot;, getPic);});function takePic() { // 调用 getPicture 方法, 可以拍照 // navigator.camera.getPicture( success, error, options ); navigator.camera.getPicture(success, error, { quality: 50, // 表示图片的质量, 默认值 50 范围 0-100 destinationType: Camera.DestinationType.FILE_URI, // 表示显示时, 返回图片url sourceType: Camera.PictureSourceType.CAMERA, // 默认值 CAMERA 表示通过相机进行拍照 targetWidth: 100, // 保持原有比例, 进行压缩显示 targetHeight: 100 }); function success(fileurl) { console.log(&quot;拍照成功&quot;); // 默认 success 返回的是 文件路径 img.src = fileurl; } function error() { console.log(&quot;拍照失败&quot;); }}function takePicBase64() { // 调用 getPicture( success, error, options ); navigator.camera.getPicture(success, error, { quality: 50, // 表示图片的质量 destinationType: Camera.DestinationType.DATA_URL, // 返回base64编码的字符串 sourceType: Camera.PictureSourceType.CAMERA // 默认值 CAMERA 表示通过相机进行拍照 }); function success(base64str) { console.log(base64str); console.log(&quot;拍照成功&quot;); // 默认读取的base64编码后的图片, 是没有前面的格式说明的 img.src = &quot;data:image/jpeg;base64,&quot; + base64str; } function error() { console.log(&quot;拍照失败&quot;); }}function getPic() { navigator.camera.getPicture(success, error, { quality: 50, // 表示图片的质量 destinationType: Camera.DestinationType.FILE_URI, // 返回的是图片路径 sourceType: Camera.PictureSourceType.PHOTOLIBRARY // 配置图片源 为相册 }); function success(fileurl) { img.src = fileurl; console.log(&quot;从相册中读取图片成功&quot;); } function error() { console.log(&quot;从相册中读取图片失败&quot;); }} 振动1、安装振动插件 1cordova plugin add cordova-plugin-vibration 2、振动使用 12navigator.vibrate(time);navigator.vibrate([time]); 1234// 停止震动navigator.vibrate(0);navigator.vibrate([]);navigator.vibrate([0]); 代码示例： 12345678910111213141516171819202122232425262728293031// 1. 安装插件 cordova plugin add cordova-plugin-vibration// 2. 使用振动的 api// 有一个全局的方法 navigator.vibrate 可以完成振动// 注意点: 振动api, 需要在 deviceready 之后, 调用// navigator.vibrate 两种调用方式// 1. navigator.vibrate( 3000 ); 振动一次, 振动3秒, 最长只能 5s// 2. navigator.vibrate( [ 3000, 1000, 3000, 1000 ] ); // 表示振动3秒, 停顿1秒, 再振动3秒, 再停1秒// 让振动停止, 给方法, 传 0即可// navigator.vibrate( 0 );// navigator.vibrate( [] );var btn1 = document.getElementById(&quot;btn1&quot;);var btn2 = document.getElementById(&quot;btn2&quot;);var stop = document.getElementById(&quot;stop&quot;);document.addEventListener(&quot;deviceready&quot;, function() { // 设备 api 准备就绪, 可以调用 设备相关 api 了 btn1.addEventListener(&quot;click&quot;, function() { navigator.vibrate(5000); }); btn2.addEventListener(&quot;click&quot;, function() { navigator.vibrate([3000, 1000, 3000, 1000]); }); stop.addEventListener(&quot;click&quot;, function() { navigator.vibrate(0); });}); Cordova 插件的使用-多媒体1、安装插件 1cordova plugin add cordova-plugin-media 2、多媒体播放、暂停、停止 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 播放音频function playAudio() { var src = &quot;/android_asset/www/video/bg.mp3&quot;; // 指定音频的路径 if ( myMedia === null ) { myMedia = new Media( src, onSuccess, onError ); function onSuccess() { console.log(&quot;playAudio Success&quot;); } function onError(error) { console.log(&quot;playAudio Error: &quot; + error.code); } } console.log(&quot;播放音乐&quot;); // 播放音频 myMedia.play();}// 暂停功能function pauseAudio() { if ( myMedia ) { console.log(&quot;暂停音乐&quot;); myMedia.pause(); }}// 停止音频function stopAudio() { if ( myMedia ) { myMedia.stop(); } console.log(&quot;停止音频&quot;); myMedia = null;}// 音量函数功能var volumeValue = 0.5;function volumeUp() { if ( myMedia &amp;&amp; volumeValue &lt; 1 ) { myMedia.setVolume( volumeValue += 0.1 ); } console.log( &quot;当前音量:&quot; + volumeValue );}function volumeDown() { if(myMedia &amp;&amp; volumeValue &gt; 0) { myMedia.setVolume(volumeValue -= 0.1); } console.log( &quot;当前音量:&quot; + volumeValue );} 插件提供的方法表: 方法 说明 getCurrentPosition 返回音频的当前位置 getDuration 返回一个音频的持续时间 play 用于开始或恢复音频 pause 用于暂停音频 release 发布底层操作系统的音频资源 seekTo 用于改变音频的位置 setVolume 用于音频设置音量 startRecord 开始录制音频文件 stopRecord 停止录制音频文件 stop 停止播放音频文件 Config.xml更改名称 123&lt;widget ...&gt; &lt;name&gt;HelloCordova&lt;/name&gt;&lt;/widget&gt; 更改描述 123&lt;widget ...&gt; &lt;description&gt;A sample Apache Cordova application&lt;/description&gt;&lt;/widget&gt; 更改图标 123&lt;widget ...&gt; &lt;icon src=&quot;res/icon.png&quot; /&gt;&lt;/widget&gt; cordova vue把 vue 项目打包成 app： 1、npm run build （注意：图片 目录的路径） 2、把 vue 打包后的静态资源复制到 cordova 项目里面 3、运行 cordova prepare 注意： vue init webpack-simple 项目名称 ​ 修改：webpack.config.js 里面 publicPath ​ 把 publicPath：’/dist’’ 改为 publicPath：’dist/‘ ​ 修改 index 里面引入 dist 的路径 去掉前面的 / （重要） vue init webpack 项目名称 ​ 修改：config/index.js 把 assetsPublicPath: ‘/‘, 修改成 assetsPublicPath: ‘./‘ Vue 中调用原生的 api：使用 vue-cordova (不推荐使用) 1、vue 项目安装 npm install –save vue-cordova 2、在 main.js 引入插件并 use 插件 12import VueCordova from 'vue-cordova'Vue.use(VueCordova) 3、调用插件 注意在对应的组件需要引入 123456789var Vue = require('vue');Vue.cordova.camera.getPicture((imgeURL) =&gt; { window.alert('Photo URL:' + imageURL)},(message)=&gt;{ window.alert('FAILED:' + message)},{ quality:50, destinationType:Vue.cordova.camera.DestinationType.FILE_URL}) 4、注意需要在 vue 项目 index.html 引入 cordova 1&lt;script src=&quot;cordova.js&quot;&gt;&lt;/script&gt; 使用 index.html 引入 cordova.js 并定义全局变量让 vue 组件里面直接使用 cordova 插件（推荐的使用方法） 1、在 vue index.html 引入 cordova.js （注意顺序 cordova.js 放在 build.js 上面） 2、直接可以在组件里面使用 cordova 的 api （注意 cordova 里面要安装 api 的插件） capacitor 相关资料[视频]Cordova 混合 App 入门（1） 相关代码Cordova中文网android studio 查看 sdk 路径配置cordova 开发环境搭建 cordova device插件——获取设备信息 cordova退回版本7.0.0 Cordova 生成慢问题，卡在Gradle:Download https://services.gradle.org/ vue-cordova","link":"/2020/03/10/Blog-about-learning-36/"},{"title":"Ajax 跨域 一起来吧！","text":"Ajax 简介Ajax读音：[ˈeɪdʒæks] Ajax 的全程：Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。Ajax 不是某种编程语言，是一种在无需重新加载整个页面的情况之下能够更新网页部分的技术。 解决问题传统的网页（不使用 Ajax 技术的页面），想要更新内容或者提交一个表单，就需要重新载入页面。使用了 Ajax 技术的页面，通过在后台跟服务器进行少量的数据交互，网页就可以实现异步局部更新。 Ajax 概念同步和异步Ajax 未出现时，网页和服务器的交互 Ajax 技术的实现得益于一个对象的出现 XMLHttpRequest 的出现 运用 HTML 和 CSS 来实现页面，表达信息；运用 XMLHttpRequest 和 web 服务器进行数据异步交互运用 JavaScript 操作 DOM，实现动态局部刷新 XMLHttpRequest 对象使用1let xmlhttp = new XMLHttpRequest(); IE5、IE6 不支持 XMLHttpRequest 对象。兼容IE5、IE6写法 123456789let xmlhttp;if (window.XMLHttpRequest) { // Support: IE 9-11 xmlhttp = new XMLHttpRequest();} else { // Support: IE6-IE8 xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);} HTTP 请求什么是 HTTP HTTP 是计算机通过网络进行通信的规则。主要应用在 web领域。 HTTP 是一种无状态协议，服务端不保留连接的相关信息。没有记忆的。 HTTP 是明文传输。 完整的 HTTP 请求 过程1、建立 TCP 连接2、Web 浏览器向 Web服务器发送请求命令，发送请求头信息3、Web 服务器应答，服务器发送应答头信息，服务器向浏览器发送数据4、Web 服务器关闭 TCP 连接。 HTTP 请求组成1、HTTP 请求的方法或动作 比如是 GET 还是 POST 请求2、请求的 URL地址。3、请求头，包含一些客户端环境信息，身份验证等。4、请求主体，也就是请求正文，请求正文中可以包含客户提交的查询字符串信息，表单信息等等。 HTTP 请求 GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 2000 个字符POST：一般用于修改服务器上的资源。对所发信息的数量无限制。相对于GET请求安全。 HTTP 响应组成1、一个数字和文字组成的状态码，用来显示请求是否成功2、响应头，响应头也是和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等。3、响应主体，也就是响应正文。 HTTP 请求HTTP 状态码由 3 位数字构成，其中首位数字定义了状态码的类型：1XX：信息类，表示收到 Web 浏览器请求，正在进一步的处理中2XX：成功，表示用户请求被正确接受，理解和处理例如：200 OK3XX：重定向，表示请求没有成功，客户必须采取进一步的动作4XX：客户端错误，表示客户端提交的请求有错误，例如：404 NOT Found，意味着请求中所引用的文档不存在5XX：服务器错误，表示服务器不能完成对请求的处理：如 500 XMLHttpRequest 发送请求open(method,url,async)send(string) 例子： XMLHttpRequest 取得响应responseText：获得字符串形式的响应数据responseXML：获得 XML 形式的响应数据status 和 statusText：以数字和文本形式返回 HTTP 状态码getAllResponseHeaders()：获取所有的响应头getResponseHeader()：查询响应中的某个字段的值readyState 属性0：请求未初始化，open 还没有调用1：服务器连接已建立，open 已经调用了2：请求已接收，也就是接收到头信息了3：请求处理中，也就是接收到响应主体了4：请求已完成，且响应已就绪，也就是响应完成了 示例代码： 1234567891011let xmlhttp = new XMLHttpRequest();// Support: IE 9-11xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) { // 做一些事情 xml.responseText }};xmlhttp.open(&quot;GET&quot;, &quot;/try/ajax/ajax_info.txt&quot;);xmlhttp.send(); Ajax 的简单例子例子简介1、查询员工信息，可以通过输入员工编号查询员工基本信息；2、新建员工信息，包含员工姓名、员工编号、员工性别、员工职位； 纯 html 页面，用来实现员工查询和新建的页面；php 页面，用来实现查询员工和新建员工的后台接口； PHP PHP 是一种创建动态交互性站点的服务器端脚本语言PHP 能够生成动态页面内容PHP 能够创建、打开、读写、删除以及关闭服务器上的文件PHP 能够接收表单数据PHP 能够发送并取回 cookiePHP 能够添加、删除、修改数据库中的数据PHP 能够限制用户访问网站中的某些页面…… php 入门简单、免费、开源、应用广泛 涉及提到点wordpress 博客系统XAMPP （服务集合）Fiddler 工具（抓包工具） 我这里使用的是 phpstudy 、 Postman 来测试接口。 示例代码： 12345678910111213141516171819202122232425262728293031323334document.getElementById(&quot;search&quot;).onclick = function() { var request = new XMLHttpRequest(); request.open(&quot;GET&quot;, &quot;server.php?number=&quot; + document.getElementById(&quot;keyword&quot;).value); request.send(); request.onreadystatechange = function() { if (request.readyState===4) { if (request.status===200) { document.getElementById(&quot;searchResult&quot;).innerHTML = request.responseText; } else { alert(&quot;发生错误：&quot; + request.status); } } }}document.getElementById(&quot;save&quot;).onclick = function() { var request = new XMLHttpRequest(); request.open(&quot;POST&quot;, &quot;server.php&quot;); var data = &quot;name=&quot; + document.getElementById(&quot;staffName&quot;).value + &quot;&amp;number=&quot; + document.getElementById(&quot;staffNumber&quot;).value + &quot;&amp;sex=&quot; + document.getElementById(&quot;staffSex&quot;).value + &quot;&amp;job=&quot; + document.getElementById(&quot;staffJob&quot;).value; request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); request.send(data); request.onreadystatechange = function() { if (request.readyState===4) { if (request.status===200) { document.getElementById(&quot;createResult&quot;).innerHTML = request.responseText; } else { alert(&quot;发生错误：&quot; + request.status); } } }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php//设置页面内容是html编码格式是utf-8header(&quot;Content-Type: text/plain;charset=utf-8&quot;); //header(&quot;Content-Type: application/json;charset=utf-8&quot;); //header(&quot;Content-Type: text/xml;charset=utf-8&quot;); //header(&quot;Content-Type: text/html;charset=utf-8&quot;); //header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); //定义一个多维数组，包含员工的信息，每条员工信息为一个数组$staff = array ( array(&quot;name&quot; =&gt; &quot;洪七&quot;, &quot;number&quot; =&gt; &quot;101&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;总经理&quot;), array(&quot;name&quot; =&gt; &quot;郭靖&quot;, &quot;number&quot; =&gt; &quot;102&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;开发工程师&quot;), array(&quot;name&quot; =&gt; &quot;黄蓉&quot;, &quot;number&quot; =&gt; &quot;103&quot;, &quot;sex&quot; =&gt; &quot;女&quot;, &quot;job&quot; =&gt; &quot;产品经理&quot;) );//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;) { search();} elseif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){ create();}//通过员工编号搜索员工function search(){ //检查是否有员工编号的参数 //isset检测变量是否设置；empty判断值为否为空 //超全局变量 $_GET 和 $_POST 用于收集表单数据 if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) { echo &quot;参数错误&quot;; return; } //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 //global 关键词用于访问函数内的全局变量 global $staff; //获取number参数 $number = $_GET[&quot;number&quot;]; $result = &quot;没有找到员工。&quot;; //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果 foreach ($staff as $value) { if ($value[&quot;number&quot;] == $number) { $result = &quot;找到员工：员工编号：&quot; . $value[&quot;number&quot;] . &quot;，员工姓名：&quot; . $value[&quot;name&quot;] . &quot;，员工性别：&quot; . $value[&quot;sex&quot;] . &quot;，员工职位：&quot; . $value[&quot;job&quot;]; break; } } echo $result;}//创建员工function create(){ //判断信息是否填写完全 if (!isset($_POST[&quot;name&quot;]) || empty($_POST[&quot;name&quot;]) || !isset($_POST[&quot;number&quot;]) || empty($_POST[&quot;number&quot;]) || !isset($_POST[&quot;sex&quot;]) || empty($_POST[&quot;sex&quot;]) || !isset($_POST[&quot;job&quot;]) || empty($_POST[&quot;job&quot;])) { echo &quot;参数错误，员工信息填写不全&quot;; return; } //TODO: 获取POST表单数据并保存到数据库 //提示保存成功 echo &quot;员工：&quot; . $_POST[&quot;name&quot;] . &quot; 信息保存成功！&quot;;} 源码 JSON 格式JSON 基本概念JSON：JavaScript 对象表示法（JavaScript Object Notation）JSON 是存储和交换文本信息的语法，类似 XML。它采用键值对的方式来组织，易于人们阅读和编写，同时也易于机器解析和生产JSON 是独立于语言的，也就是说不管什么语言，都可以解析 json，只需要按照 json 的规则来就行。 JSON 与 XML 比较json 的长度 和 xml 格式比起来很短小json 读写的速度更快json 可以使用 JavaScript 内建的方法直接进行解析，转成为 JavaScript 对象，非常方便。 JSON 语法规则JSON 数据的书写格式是：名称/值对名称/值对组合中的名称写在前面（在双引号中），值对写在后面（同样在双引号中），中间用冒号隔开：比如 “name”:“郭靖” json 的值可以是下面这些类型数字（整数或浮点数），比如123，1.23字符串（在双引号中）逻辑值（true 或 false）数组 （在方括号中）对象 （在花括号中）null JSON 解析eval 和 JSON.parse一般使用 JSON.parse，使用 eval 很危险。 JSON 检验工具JSONLint 采用 json 格式代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344document.getElementById(&quot;search&quot;).onclick = function() { var request = new XMLHttpRequest(); request.open(&quot;GET&quot;, &quot;serverjson.php?number=&quot; + document.getElementById(&quot;keyword&quot;).value); request.send(); request.onreadystatechange = function() { if (request.readyState===4) { if (request.status===200) { var data = JSON.parse(request.responseText); if (data.success) { document.getElementById(&quot;searchResult&quot;).innerHTML = data.msg; } else { document.getElementById(&quot;searchResult&quot;).innerHTML = &quot;出现错误：&quot; + data.msg; } } else { alert(&quot;发生错误：&quot; + request.status); } } }}document.getElementById(&quot;save&quot;).onclick = function() { var request = new XMLHttpRequest(); request.open(&quot;POST&quot;, &quot;serverjson.php&quot;); var data = &quot;name=&quot; + document.getElementById(&quot;staffName&quot;).value + &quot;&amp;number=&quot; + document.getElementById(&quot;staffNumber&quot;).value + &quot;&amp;sex=&quot; + document.getElementById(&quot;staffSex&quot;).value + &quot;&amp;job=&quot; + document.getElementById(&quot;staffJob&quot;).value; request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); request.send(data); request.onreadystatechange = function() { if (request.readyState===4) { if (request.status===200) { var data = JSON.parse(request.responseText); if (data.success) { document.getElementById(&quot;createResult&quot;).innerHTML = data.msg; } else { document.getElementById(&quot;createResult&quot;).innerHTML = &quot;出现错误：&quot; + data.msg; } } else { alert(&quot;发生错误：&quot; + request.status); } } }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php//设置页面内容是html编码格式是utf-8header(&quot;Content-Type: text/plain;charset=utf-8&quot;); //header(&quot;Content-Type: application/json;charset=utf-8&quot;); //header(&quot;Content-Type: text/xml;charset=utf-8&quot;); //header(&quot;Content-Type: text/html;charset=utf-8&quot;); //header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); //定义一个多维数组，包含员工的信息，每条员工信息为一个数组$staff = array ( array(&quot;name&quot; =&gt; &quot;洪七&quot;, &quot;number&quot; =&gt; &quot;101&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;总经理&quot;), array(&quot;name&quot; =&gt; &quot;郭靖&quot;, &quot;number&quot; =&gt; &quot;102&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;开发工程师&quot;), array(&quot;name&quot; =&gt; &quot;黄蓉&quot;, &quot;number&quot; =&gt; &quot;103&quot;, &quot;sex&quot; =&gt; &quot;女&quot;, &quot;job&quot; =&gt; &quot;产品经理&quot;) );//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;) { search();} elseif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){ create();}//通过员工编号搜索员工function search(){ //检查是否有员工编号的参数 //isset检测变量是否设置；empty判断值为否为空 //超全局变量 $_GET 和 $_POST 用于收集表单数据 if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) { echo '{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;}'; return; } //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 //global 关键词用于访问函数内的全局变量 global $staff; //获取number参数 $number = $_GET[&quot;number&quot;]; $result = '{&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;}'; //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果 foreach ($staff as $value) { if ($value[&quot;number&quot;] == $number) { $result = '{&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：' . $value[&quot;number&quot;] . '，员工姓名：' . $value[&quot;name&quot;] . '，员工性别：' . $value[&quot;sex&quot;] . '，员工职位：' . $value[&quot;job&quot;] . '&quot;}'; break; } } echo $result;}//创建员工function create(){ //判断信息是否填写完全 if (!isset($_POST[&quot;name&quot;]) || empty($_POST[&quot;name&quot;]) || !isset($_POST[&quot;number&quot;]) || empty($_POST[&quot;number&quot;]) || !isset($_POST[&quot;sex&quot;]) || empty($_POST[&quot;sex&quot;]) || !isset($_POST[&quot;job&quot;]) || empty($_POST[&quot;job&quot;])) { echo '{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误，员工信息填写不全&quot;}'; return; } //TODO: 获取POST表单数据并保存到数据库 //提示保存成功 echo '{&quot;success&quot;:true,&quot;msg&quot;:&quot;员工：' . $_POST[&quot;name&quot;] . ' 信息保存成功！&quot;}';}?&gt; 源码 jQuery 中的 AjaxjQuery.ajax([settings]) type：类型，“POST” 或 “GET”，默认为 “GET”url：发送请求的地址data：是一个对象，连同请求发送到服务器的数据dataType：预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，一般采用 json 格式，可以设置为“json”success：是一个方法，请求成功后的回调函数。传入返回后的数据，以及包含成功代码的字符串error：是一个方法，请求失败后调用此函数。传入 XMLHttpRequest 对象 静态资源库360 前端静态资源库腾讯前端静态资源库字节跳动 前端静态资源库 改写代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243$(document).ready(function(){ $(&quot;#search&quot;).click(function(){ $.ajax({ type: &quot;GET&quot;, url: &quot;serverjson2.php?number=&quot; + $(&quot;#keyword&quot;).val(), dataType: &quot;json&quot;, success: function(data) { if (data.success) { $(&quot;#searchResult&quot;).html(data.msg); } else { $(&quot;#searchResult&quot;).html(&quot;出现错误：&quot; + data.msg); } }, error: function(jqXHR){ alert(&quot;发生错误：&quot; + jqXHR.status); }, }); }); $(&quot;#save&quot;).click(function(){ $.ajax({ type: &quot;POST&quot;, url: &quot;serverjson2.php&quot;, data: { name: $(&quot;#staffName&quot;).val(), number: $(&quot;#staffNumber&quot;).val(), sex: $(&quot;#staffSex&quot;).val(), job: $(&quot;#staffJob&quot;).val() }, dataType: &quot;json&quot;, success: function(data){ if (data.success) { $(&quot;#createResult&quot;).html(data.msg); } else { $(&quot;#createResult&quot;).html(&quot;出现错误：&quot; + data.msg); } }, error: function(jqXHR){ alert(&quot;发生错误：&quot; + jqXHR.status); }, }); });}); 源码 跨域一个域名地址的组成： http:// www . abc.com : 8080 / script/jquery.js协议 子域名 主域名 端口号 请求资源地址 当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。不同域之间相互请求资源，就算做“跨域” 跨域JavaScript 出于安全方面的考虑，不允许跨域调用其他页面的对象。简单理解就是 JavaScript 同源策略的限制。 处理跨域方式——代理后端做代理 处理跨域方式 —— jsonpJSONP 可用于解决主流浏览器的跨域数据访问的问题，只能 GET 请求。借助标签可以实现跨域的特性。 示例代码： 123456789101112131415161718$(&quot;#search&quot;).click(function(){ $.ajax({ type: &quot;GET&quot;, url: &quot;http://127.0.0.1:8000/ajaxdemo/serverjsonp.php?number=&quot; + $(&quot;#keyword&quot;).val(), dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;, success: function(data) { if (data.success) { $(&quot;#searchResult&quot;).html(data.msg); } else { $(&quot;#searchResult&quot;).html(&quot;出现错误：&quot; + data.msg); } }, error: function(jqXHR){ alert(&quot;发生错误：&quot; + jqXHR.status); }, });}); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php//设置页面内容是html编码格式是utf-8//header(&quot;Content-Type: text/plain;charset=utf-8&quot;); header(&quot;Content-Type: application/json;charset=utf-8&quot;); //header(&quot;Content-Type: text/xml;charset=utf-8&quot;); //header(&quot;Content-Type: text/html;charset=utf-8&quot;); //header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); //定义一个多维数组，包含员工的信息，每条员工信息为一个数组$staff = array ( array(&quot;name&quot; =&gt; &quot;洪七&quot;, &quot;number&quot; =&gt; &quot;101&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;总经理&quot;), array(&quot;name&quot; =&gt; &quot;郭靖&quot;, &quot;number&quot; =&gt; &quot;102&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;开发工程师&quot;), array(&quot;name&quot; =&gt; &quot;黄蓉&quot;, &quot;number&quot; =&gt; &quot;103&quot;, &quot;sex&quot; =&gt; &quot;女&quot;, &quot;job&quot; =&gt; &quot;产品经理&quot;) );//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;) { search();} elseif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){ create();}//通过员工编号搜索员工function search(){ $jsonp = $_GET[&quot;callback&quot;]; //检查是否有员工编号的参数 //isset检测变量是否设置；empty判断值为否为空 //超全局变量 $_GET 和 $_POST 用于收集表单数据 if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) { echo $jsonp . '({&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;})'; return; } //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 //global 关键词用于访问函数内的全局变量 global $staff; //获取number参数 $number = $_GET[&quot;number&quot;]; $result = $jsonp . '({&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;})'; //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果 foreach ($staff as $value) { if ($value[&quot;number&quot;] == $number) { $result = $jsonp . '({&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：' . $value[&quot;number&quot;] . '，员工姓名：' . $value[&quot;name&quot;] . '，员工性别：' . $value[&quot;sex&quot;] . '，员工职位：' . $value[&quot;job&quot;] . '&quot;})'; break; } } echo $result;}//创建员工function create(){ //判断信息是否填写完全 if (!isset($_POST[&quot;name&quot;]) || empty($_POST[&quot;name&quot;]) || !isset($_POST[&quot;number&quot;]) || empty($_POST[&quot;number&quot;]) || !isset($_POST[&quot;sex&quot;]) || empty($_POST[&quot;sex&quot;]) || !isset($_POST[&quot;job&quot;]) || empty($_POST[&quot;job&quot;])) { echo '{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误，员工信息填写不全&quot;}'; return; } //TODO: 获取POST表单数据并保存到数据库 //提示保存成功 echo '{&quot;success&quot;:true,&quot;msg&quot;:&quot;员工：' . $_POST[&quot;name&quot;] . ' 信息保存成功！&quot;}';}?&gt; 源码 处理跨域方式 —— XHR2HTML5 提供的 XMLHttpRequest Level2 已经实现了跨域访问以及其他的一些新功能IE10 以下的版本都不支持在服务器端做一些小小的改造即可：header(‘Access-Control-Allow-Origin:*’)header(‘Access-Control-Allow-Methods:POST,GET’) 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php//设置页面内容是html编码格式是utf-8//header(&quot;Content-Type: text/plain;charset=utf-8&quot;); header('Access-Control-Allow-Origin:*');header('Access-Control-Allow-Methods:POST,GET');header('Access-Control-Allow-Credentials:true'); header(&quot;Content-Type: application/json;charset=utf-8&quot;); //header(&quot;Content-Type: text/xml;charset=utf-8&quot;); //header(&quot;Content-Type: text/html;charset=utf-8&quot;); //header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); //定义一个多维数组，包含员工的信息，每条员工信息为一个数组$staff = array ( array(&quot;name&quot; =&gt; &quot;洪七&quot;, &quot;number&quot; =&gt; &quot;101&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;总经理&quot;), array(&quot;name&quot; =&gt; &quot;郭靖&quot;, &quot;number&quot; =&gt; &quot;102&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;开发工程师&quot;), array(&quot;name&quot; =&gt; &quot;黄蓉&quot;, &quot;number&quot; =&gt; &quot;103&quot;, &quot;sex&quot; =&gt; &quot;女&quot;, &quot;job&quot; =&gt; &quot;产品经理&quot;) );//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;) { search();} elseif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){ create();}//通过员工编号搜索员工function search(){ //检查是否有员工编号的参数 //isset检测变量是否设置；empty判断值为否为空 //超全局变量 $_GET 和 $_POST 用于收集表单数据 if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) { echo '{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;}'; return; } //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 //global 关键词用于访问函数内的全局变量 global $staff; //获取number参数 $number = $_GET[&quot;number&quot;]; $result = '{&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;}'; //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果 foreach ($staff as $value) { if ($value[&quot;number&quot;] == $number) { $result = '{&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：' . $value[&quot;number&quot;] . '，员工姓名：' . $value[&quot;name&quot;] . '，员工性别：' . $value[&quot;sex&quot;] . '，员工职位：' . $value[&quot;job&quot;] . '&quot;}'; break; } } echo $result;}//创建员工function create(){ //判断信息是否填写完全 if (!isset($_POST[&quot;name&quot;]) || empty($_POST[&quot;name&quot;]) || !isset($_POST[&quot;number&quot;]) || empty($_POST[&quot;number&quot;]) || !isset($_POST[&quot;sex&quot;]) || empty($_POST[&quot;sex&quot;]) || !isset($_POST[&quot;job&quot;]) || empty($_POST[&quot;job&quot;])) { echo '{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误，员工信息填写不全&quot;}'; return; } //TODO: 获取POST表单数据并保存到数据库 //提示保存成功 echo '{&quot;success&quot;:true,&quot;msg&quot;:&quot;员工：' . $_POST[&quot;name&quot;] . ' 信息保存成功！&quot;}';}?&gt; 产生跨域问题的原因浏览器限制跨域XHR（XMLHttpRequest）请求 解决思路 全面解决跨域问题浏览器禁止检查命令行参数启动 1C:\\Users\\UserName\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe --disable-web-security --user-data-dir JSONPJSONP 是什么？利用 script 标签请求资源可以跨域，来解决跨域问题。 JSONP 后台要改动。 JSONP 发出去的请求 Type 是 script ，而 Ajax 发出去的是 Type 是 xhr。Ajax 返回的类型是 json，而 JSONP 返回的类型是 JavaScript。JSONP 请求地址加了 callback 参数 ,还有随机数是防止被缓存 JSONP 服务器需要改动代码支持只支持 GET 方法 最常见的 JAVAEE 架构 跨域解决方向 被调用方解决：服务器端实现Nginx 配置Apache 配置 浏览器在发送跨域请求的时候先判断是不是简单请求，简单请求浏览器是先执行后判断，非简单请求会先发一个预检命令，检查通过之后才发跨域请求。如何判断，根据请求中（Origin）源头来判断。服务端 filter 代码实现原理 所有的请求都经过 filter。filter 中增加响应头。 调用方解决隐藏跨域 简单请求和非简单请求简单请求方法为：GET、POST、HEAD请求 header 里面：无自定义头Content-Type 为以下几种：text/plainmultipart/form-dataapplication/x-www-form-urlencoded 工作中常见的非简单请求有put,delete 方法的 ajax 请求发送 json 格式的 ajax 请求带自定义头的 ajax 请求 缓存预检命令：Access-Control-Max-Age:”3600” 毫秒数 带 cookie 的跨域12345678910$.ajax({ type: &quot;get&quot;, url: base + &quot;/getCookie&quot;, xhrFields: { withCredentials: true }, success: function(json){ result = json; }}) 后端要加 Access-Control-Allow-Origin 不能为 * 必须是完全匹配Access-Control-Allow-Credentials 设置为 true可以把 请求头的 Origin 设置为 Access-Control-Allow-Origin 的值来应对多个跨域 带自定义头的跨域12345678910111213$.ajax({ type: &quot;get&quot;, url: base + &quot;/getCookie&quot;, headers: { &quot;x-header1&quot; :&quot;AAA&quot; }, beforeSend: function(xhr){ xhr.setRequestHeader('x-header2','BBB') }, success: function(json){ result = json; }}) 后端要加Access-Control-Allow-Headers,“x-header1”,”x-header2”可以把 请求头中 Access-Control-Request-Headers 作为 Access-Control-Allow-Headers 的值。 nginx 解决方案可以通过搜索 hosts* 来找到 windows host配置 windows host配置C:\\Windows\\System32\\drivers\\etc\\hosts 内添加映射127.0.0.1 b.com 在 nginx-1.16.1 目录下 conf 文件下 nginx.conf 增加 include servers/*.conf; 1234567891011121314151617server{ listen 80; server_name b.com; location / { proxy_pass http://localhost:4000; add_header Access-Control-Allow-Methods *; add_header Access-Control-Max-Age 3600; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Origin $http_origin; add_header Access-Control-Allow-Headers $http_access-control-request-headers; if ($request_method = OPTIONS){ return 200; } }} Apache 解决方案可以搜索 httpd.conf 来找到 Apache 的配置文件 Apache 配置Apache2.4.39\\conf\\httpd.conf 1234567# 去掉下列的注释 ##LoadModule vhost_alias_module modules/mod_vhost_alias.so#Include conf/vhosts.conf#LoadModule proxy_module modules/mod_proxy.so#LoadModule proxy_http_module modules/mod_proxy_http.so#LoadModule headers_module modules/mod_headers.so#LoadModule rewrite_module modules/mod_rewrite.so conf/vhosts.conf 配置文件中添加 1234567891011121314151617181920&lt;VirtualHost *:80&gt; ServerName test.com ErrorLog logs/test.com-error_log CustomLog logs/test.com-access_log common ProxyPass / http://localhost:4000/ # 把请求头的 origin 值返回到 Access-Control-Allow-Origin 字段 Header always set Access-Control-Allow-Origin &quot;expr=%{req:origin}&quot; # 把请求头的 Access-Control-Request-Headers 值返回到 Access-Control-Allow-Headers 字段 Header always set Access-Control-Allow-Headers &quot;expr=%{req:Access-Control-Request-Headers}&quot; Header always set Access-Control-Allow-Methods &quot;*&quot; Header always set Access-Control-Allow-Credentials &quot;true&quot; Header always set Access-Control-Max-Age &quot;3600&quot; # 处理预检命令 OPTIONS，直接返回 204 RewriteEngine On RewriteCond %{REQUEST_METHOD} OPTIONS RewriteRule ^(.*)$ &quot;/&quot; [R=204,L]&lt;/VirtualHost&gt; 隐藏跨域 nginx反向代理 123456789101112server{ listen 80; server_name a.com location / { proxy_pass http://localhost:8081; } location /ajaxserver { proxy_pass http://localhost:8080/test/; }} 隐藏跨域 Apache&lt;VirtualHost *:80&gt; ServerName test.com ErrorLog logs/test.com-error_log CustomLog logs/test.com-access_log common ProxyPass / http://localhost:8081/ ProxyPass /ajaxserverapache http://localhost:8080/test --- 以上是我对下列视频及文章的归纳和总结。Ajax全接触Ajax跨域完全讲解 相关资料前端测试框架对比","link":"/2020/03/26/Blog-about-learning-44/"},{"title":"基于 CentOS 搭建 Discuz 论坛","text":"准备 LAMP 环境LAMP 是 Linux、Apache、MySQL 和 PHP 的缩写，是 Discuz 论坛系统依赖的基础运行环境。 安装 MySQL使用 yum 安装 MySQL： 1yum install mysql-server -y 安装完成后，启动 MySQL 服务： 1service mysqld restart 可以设置自己的 MySQL 账户名和密码： 1/usr/bin/mysqladmin -u root password 'ICQvykOy' 将 MySQL 设置为开机自动启动： 1chkconfig mysqld on 安装 Apache 组件使用 yum 安装 Apache 组件： 1yum install httpd -y 安装之后，启动 httpd 进程： 1service httpd start 把 httpd 也设置成开机自动启动： 1chkconfig httpd on 安装 PHP使用 yum 安装 PHP 1yum install php php-fpm php-mysql -y 安装之后，启动 PHP-FPM 进程： 1service php-fpm start 启动之后，可以使用下面的命令查看 PHP-FPM 进程监听哪个端口 1netstat -nlpt | grep php-fpm 把 PHP-FPM 也设置成开机自动启动： 1chkconfig php-fpm on 安装并配置 DiscuzCentOS 6 没有Discuz 的 yum 源，所以我们需要下载一个Discuz 压缩包: 1wget http://download.comsenz.com/DiscuzX/3.2/Discuz_X3.2_SC_UTF8.zip 下载完成后，解压这个压缩包 1unzip Discuz_X3.2_SC_UTF8.zip 配置 Discuz由于PHP默认访问 /var/www/html/ 文件夹，所以我们需要把upload文件夹里的文件都复制到 /var/www/html/ 文件夹 1cp -r upload/* /var/www/html/ 给 /var/www/html 目录及其子目录赋予权限 1chmod -R 777 /var/www/html 重启 Apache 1service httpd restart 以上是我对下列视频及文章的归纳和总结。 相关资料基于 CentOS 搭建 Discuz 论坛","link":"/2020/04/13/Blog-about-learning-59/"},{"title":"GitHub 技巧","text":"GitHub 访问和下载问题：GitHub 访问不了或下载慢原因：GitHub 的 CDN 被墙屏了。解决方法：绕过 DNS 解析，在本地直接绑定 host，该方法也可用于其他 CDN 被屏蔽的网站。原理：找出 GitHub 域名所对应的 IP 地址，直接添加在本地 host 中。每次请求 GitHub 时就无需再向 DNS 查询地址。操作： 访问ipaddress，查看网站域名对应的 IP 地址，输入网址则可查阅对应的 IP 地址。 修改 host 文件Windows 中 host 文件在 C:\\Windows\\System32\\drivers\\etc 下。修改 host 文件如下： 123456# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost192.30.253.112 github.com151.101.113.194 github.global.ssl.fastly.net 刷新 DNSWindows：cmd 执行 ipconfig/flushdnsmac：sudo dscacheutil –flushcache GitHub 的使用进入个人主页 Followers 表示跟随者和粉丝 进入项目 stars 和 fork 表示该项目的受欢迎程度 Branch: 分支 Tag: 标签 比较代码分支之间的区别:在项目之后输入/compare vue commits 提交 branch 分支 contributors 贡献者 Issues 评论\\留言\\bug 追踪\\特性追踪 Pull requests 提交请求\\贡献 Projects 项目管理 Wiki 维基百科 Insights 统计信息 Webhooks 消息钩子 开源项目搜索项目名称中带 spring boot 并且 star 数超过 3000 fork 超过 300in:name spring boot stars:&gt;3000 forks:&gt;300 项目描述中带 spring bootin:readme spring boot stars:&gt;3000 forks:&gt;300 描述里搜索微服务相关的项目 语言 java 最近提交时间大于 2019-09-03 in:description 微服务 language:java pushed:&gt;2019-09-03 以上是我对下列视频及文章的归纳和总结。程序员宝库,开源社区 GitHub 到底该怎么玩如何高效地在网上找开源项目做！GitHub上重要的几个搜索技巧Github 搜索技巧，快速找到好资源GitHub 全球用户排行榜 github 高级搜索","link":"/2020/01/16/Blog-about-learning-6/"},{"title":"基于 CentOS 搭建 WordPress 个人博客","text":"准备 LNMP 环境LNMP 是 Linux、Nginx、MySQL 和 PHP 的缩写，是 WordPress 博客系统依赖的基础运行环境。 安装 Nginx使用 yum 安装 Nginx： 1yum install nginx -y 修改 /etc/nginx/conf.d/default.conf，去除对 IPv6 地址的监听 示例代码：/etc/nginx/conf.d/default.conf 123456789101112131415161718192021server { listen 80 default_server; # listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { }} 修改完成后，启动 Nginx： 1nginx 此时，可访问实验机器外网 HTTP 服务（http://139.199.220.127）来确认是否已经安装成功。 将 Nginx 设置为开机自动启动： 1chkconfig nginx on CentOS 6 不支持 IPv6，需要取消对 IPv6 地址的监听，否则 Nginx 不能成功启动。 安装 MySQL使用 yum 安装 MySQL： 1yum install mysql-server -y 安装完成后，启动 MySQL 服务： 1service mysqld restart 设置 MySQL 账户 root 密码： 1/usr/bin/mysqladmin -u root password 'MyPas$word4Word_Press' 将 MySQL 设置为开机自动启动： 1chkconfig mysqld on 安装 PHP1yum install php-fpm php-mysql -y 安装之后，启动 PHP-FPM 进程： 1service php-fpm start 启动之后，可以使用下面的命令查看 PHP-FPM 进程监听哪个端口 1netstat -nlpt | grep php-fpm 把 PHP-FPM 也设置成开机自动启动： 1chkconfig php-fpm on CentOs 6 默认已经安装了 PHP-FPM 及 PHP-MYSQL，下面命令执行的可能会提示已经安装。 PHP-FPM 默认监听 9000 端口 安装并配置 WordPress安装 WordPress配置好 LNMP 环境后，继续使用 yum 来安装 WordPress： 1yum install wordpress -y 安装完成后，就可以在 /usr/share/wordpress 看到 WordPress 的源代码了。 配置数据库进入 MySQL： 1mysql -uroot --password='MyPas$word4Word_Press' 为 WordPress 创建一个数据库： 1CREATE DATABASE wordpress; MySQL 部分设置完了，我们退出 MySQL 环境： 1exit 把上述的 DB 配置同步到 WordPress 的配置文件中，可参考下面的配置：示例代码：/etc/wordpress/wp-config.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?php/** * The base configuration for WordPress * * The wp-config.php creation script uses this file during the * installation. You don't have to use the web site, you can * copy this file to &quot;wp-config.php&quot; and fill in the values. * * This file contains the following configurations: * * * MySQL settings * * Secret keys * * Database table prefix * * ABSPATH * * @link https://codex.wordpress.org/Editing_wp-config.php * * @package WordPress */// ** MySQL settings - You can get this info from your web host ** ///** The name of the database for WordPress */define('DB_NAME', 'wordpress');/** MySQL database username */define('DB_USER', 'root');/** MySQL database password */define('DB_PASSWORD', 'MyPas$word4Word_Press');/** MySQL hostname */define('DB_HOST', 'localhost');/** Database Charset to use in creating database tables. */define('DB_CHARSET', 'utf8');/** The Database Collate type. Don't change this if in doubt. */define('DB_COLLATE', '');/**#@+ * Authentication Unique Keys and Salts. * * Change these to different unique phrases! * You can generate these using the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service} * You can change these at any point in time to invalidate all existing cookies. This will force all users to have to log in again. * * @since 2.6.0 */define('AUTH_KEY', 'put your unique phrase here');define('SECURE_AUTH_KEY', 'put your unique phrase here');define('LOGGED_IN_KEY', 'put your unique phrase here');define('NONCE_KEY', 'put your unique phrase here');define('AUTH_SALT', 'put your unique phrase here');define('SECURE_AUTH_SALT', 'put your unique phrase here');define('LOGGED_IN_SALT', 'put your unique phrase here');define('NONCE_SALT', 'put your unique phrase here');/**#@-*//** * WordPress Database Table prefix. * * You can have multiple installations in one database if you give each * a unique prefix. Only numbers, letters, and underscores please! */$table_prefix = 'wp_';/** * See http://make.wordpress.org/core/2013/10/25/the-definitive-guide-to-disabling-auto-updates-in-wordpress-3-7 *//* Disable all file change, as RPM base installation are read-only */define('DISALLOW_FILE_MODS', true);/* Disable automatic updater, in case you want to allow above FILE_MODS for plugins, themes, ... */define('AUTOMATIC_UPDATER_DISABLED', true);/* Core update is always disabled, WP_AUTO_UPDATE_CORE value is ignore *//** * For developers: WordPress debugging mode. * * Change this to true to enable the display of notices during development. * It is strongly recommended that plugin and theme developers use WP_DEBUG * in their development environments. * * For information on other constants that can be used for debugging, * visit the Codex. * * @link https://codex.wordpress.org/Debugging_in_WordPress */define('WP_DEBUG', false);/* That's all, stop editing! Happy blogging. *//** Absolute path to the WordPress directory. */if ( !defined('ABSPATH') ) define('ABSPATH', '/usr/share/wordpress');/** Sets up WordPress vars and included files. */require_once(ABSPATH . 'wp-settings.php'); 配置 NginxWordPress 已经安装完毕，我们配置 Nginx 把请求转发给 PHP-FPM 来处理首先，重命名默认的配置文件： 12cd /etc/nginx/conf.d/mv default.conf defaut.conf.bak 在 /etc/nginx/conf.d 创建 wordpress.conf 配置，参考下面的内容：示例代码：/etc/nginx/conf.d/wordpress.conf 123456789101112131415server { listen 80; root /usr/share/wordpress; location / { index index.php index.html index.htm; try_files $uri $uri/ /index.php index.php; } # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 location ~ .php$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; }} 配置后，通知 Nginx 进程重新加载： 1nginx -s reload 默认的 Server 监听 80 端口，与 WordPress 的服务端口冲突，将其重命名为 .bak 后缀以禁用默认配置 以上是我对下列视频及文章的归纳和总结。 相关资料基于 CentOS 搭建 WordPress 个人博客","link":"/2020/04/13/Blog-about-learning-60/"},{"title":"秒杀活动","text":"秒杀活动特点“限时限量”、“价格极地”、“几秒内就被抢光” 秒杀活动带来的问题：1、对现有网站业务的冲击2、高并发情况以及数据库负载3、突然增加的网路和服务器宽带4、直接下单5、防止机器秒杀 解决方案1、秒杀系统单独部署，如果有需要甚至是独立的域名，根网站完全隔离开，除了底层数据库中某些数据，也就是从 Web 服务器、数据库服务器等都会有单独的一套。2、在没有开始秒杀之前，把商品的展示页面做静态化，也就是简单的 HTML 页面不做任何业务逻辑的处理，也不访问数据库，就只是很简单的展示，等真正需要秒杀的时候再打开另外一个页面，这个页面有业务逻辑，也会有可能访问数据库的。在秒杀活动之前大多数用户会不停的刷新页面。3、可以根运营商购买或者是租借网络服务器带宽，将秒杀商品的静态页面缓存到 CDN，租借 CDN。4、避免让用户在秒杀活动前知道秒杀活动下单的接口或者页面。对下单页面添加动态验证参数，并且该页面是在秒杀开始前无法访问到的。5、ip 的阻止，一个 ip 可以访问几次，验证码。","link":"/2020/04/13/Blog-about-learning-62/"},{"title":"基于 CentOS 搭建微信小程序服务","text":"准备域名和证书小程序后台服务需要通过 HTTPS 访问，在实验开始之前，我们要准备域名和 SSL 证书。 域名注册 搭建小程序开发环境 以上是我对下列视频及文章的归纳和总结。基于 CentOS 搭建微信小程序服务","link":"/2020/04/14/Blog-about-learning-63/"},{"title":"基于 NodeJs 打造 Web 在线聊天室","text":"以上是我对下列视频及文章的归纳和总结。基于 NodeJs 打造 Web 在线聊天室","link":"/2020/04/14/Blog-about-learning-64/"},{"title":"windows server 2012 standard 搭建 git 服务 探索","text":"服务器系统介绍windows server 2012 standard 搭建项目托管平台在搭建项目托管平台之前我们应该先搞明白版本控制这个概念。 版本控制什么是 版本控制？ 来源 百度百科版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。版本控制包括：检入检出控制、分支和合并、历史记录。 来源 TOWER你可以把一个版本控制系统（缩写VCS）理解为一个“数据库”，在需要的时候，它可以帮你完整地保存一个项目的快照。当你需要查看一个之前的快照（称为“版本” ）时，版本控制系统可以显示出当前版本与上一个版本之间的所有替换的细节。 来源 git版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 为什么用 版本控制？1、备份用2、协调开发用 版本控制的变革 来源 git本地版本控制系统缺点：1、中央服务器故障，将无法提交更新，无法协同工作。如果中心数据库所在的磁盘发生损坏，又恰当无备份，，毫无疑问将丢失所有数据包括项目的整个变更历史。2、多人协作繁琐。 集中化的版本控制系统缺点：中央服务器故障，将无法提交更新，无法协同工作。如果中心数据库所在的磁盘发生损坏，又恰当无备份，，毫无疑问将丢失所有数据包括项目的整个变更历史。记住这个概念下面会有涉及到。 分布式版本控制系统解决了本地版本控制系统 集中化的版本控制系统 的缺点。解决方式：客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。记住这个概念下面会有涉及到。 简单的来说版本控制系统会记录所有对项目文件的更改。 版本控制工具现在主流版本控制工具是 Git 和 SVN。咱们上面提到两个概念分别是 集中化的版本控制系统 和 分布式版本控制系统。 SVN 属于 集中化的版本控制系统。Git 属于 分布式版本控制系统。 SVN VS GitSVN 简介 来源SVNApache® Subversion®“Enterprise-class centralized version control for the masses” google 翻译Apache Subversion面向群众的企业级集中版本控制 提取关键字：企业级、集中、版本控制。SVN 是一款集中式版本控制系统。特点：可靠性高、模型和用法的简单性、覆盖面广（支持从个人到大型企业运营的各种用户和项目需求的能力）。 SVN 的一些概念 repository（源代码库） Checkout（提取） Commit（提交） Update (更新) SVN 的主要功能 1、目录版本控制 2、真实的版本历史 3、自动提交 4、纳入版本控管的元数据 5、选择不同的网络层 6、一致的数据处理方式 7、有效的分支(branch)与标签(tag) 8、Hackability SVN 生命周期1、创建版本库2、检出3、更新4、执行变更5、复查变化6、修复错误7、解决冲突8、提交更改 SVN 客户端工具TortoiseSVN 官网上下载 TortoiseSVN,TortoiseSVN有对应的语言包。菜鸟教程TortoiseSVN 使用教程 1、新建一个工作目录例如 runoob01，用于存储工作档案 2、将工作档案更新到本地 3、新增档案及目录到 Repository 中 Git 简介 来源 GitGit 是一个免费的开源分布式版本控制系统，旨在快速高效地处理从小型到大型项目的所有内容。Git 易于学习， 占地面积小，具有闪电般的快速性能。它具有Subversion，CVS，Perforce和ClearCase之类的SCM工具，具有廉价的本地分支，方便的暂存区域和 多个工作流等功能。 Git SVN 能做的 Git 基本都能实现。 Git 的一些概念本来要搭建 SVN 我提议搭建 GitLab ，我但是我也没有搭建过 GitLab，服务器系统是 windows server，我查了查资料，得到结果是 如果要在 windows server 上搭建 GitLab 就要装 虚拟机 然后装 Ubuntu 之类的 操作系统然后再装 GitLab 那可是真………… ，gitlab官网也没有资料。 查找资料的过程中我发现 GitLab Runner 可以安装在 windows 上，查了下资料大致意思是 GitLab Runner 是将代码发送到 GitLab 上的服务。？？………… GitLab Runner 官方解释GitLab Runner是一个开源项目，用于运行您的作业并将结果发送回GitLab。它与GitLab CI / CD结合使用，GitLab CI / CD是GitLab随附的用于协调作业的开源持续集成服务。 查找资料的过程中 我发现了 Gitblit 而且相关的搭建文章有很多，我开始了新的尝试。 Git 与 SVN 区别1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 托管平台 GitHub GitLab Bitbucket 码云 coding 相关资料版本控制版本控制版本控制程序员编程开发网站，为什么要有版本控制工具这种东西？Apache® Subversion®菜鸟教程 SVNTortoiseSVNGitGit工作流程Git教程菜鸟教程 GitGit、Github、Gitlab的区别Git、GitHub、GitLab三者之间的联系以及区别gitLab的使用 和 git 、 github、gitlab的区别Git、GitHub和GitLab的区别Git与GitHub，Gitlab的区别如何在你自己的服务器搭建类似github的服务,git部署站点Git：本地部署代码到服务器（GitHub服务器 或 局域网搭建的git服务器）如何搭建一个GitHub在自己的服务器上？Svn与Git的区别,为什么使用git？SVN与Git比较版本管理工具介绍——SVN篇SVN常见问题版本控制工具 - git和svnSVN与Git比较的优缺点差异对比Git 与 SVN，这篇讲的很易懂你还在用svn？git你无法拒绝的版本管理工具Bonobo Git Server官网Bonobo Git Server安装Bonobo Git Server 先决条件windows系统部署Bonobo.git服务器在Windows上搭建Git Server5分钟搞定 Git 服务端 安装 windows 2003 gitblitgitblit搭建git服务器Windows平台下Git服务器搭建Windows平台下Git(gitblit)服务器搭建怎么看电脑是否支持使用Hyper-V虚拟机gitlabgitblit搭建gitlab仓库在Windows上安装GitLab RunnerGitLab RunnerGitblit GO安装和设置windows下使用docker搭建gitlab的报错处理使用docker-compose安装GitLab安装Docker Compose安装Docker引擎服务器上的Git（Windows Server 2012）Windows下使用docker部署gitlab CI服务在Windows Server 2012上安装IIS 8Internet信息服务（IIS）管理器在哪里打开windows Server2012 IIS8.0配置安装完整教程在Windows下搭建Gitlab服务器windows server 2012 r2 安装docker 篇幅过长，回头填坑。","link":"/2020/04/11/Blog-about-learning-58/"},{"title":"Linux 下部署 Express 环境","text":"安装Nginxyum install nginx -y配置nginx启动和开机自启动systemctl enable nginx.servicesystemctl start nginx.service安装node环境yum -y isntall nodejs配置npm加速npm install -g cnpm –registry=https://registry.npm.taobao.org安装express生成器cnpm install express-generator -g创建一个express站点cd /home/express cloud进入目录，安装依赖cd cloudcnpm install测试express启动express,进行测试DEBUG=cloud:* npm start安装 PM 2 负载均衡cnpm install pm2 -g为pm2添加开机启动pm2 startup systemdpm2 save使用pm2启动expresspm2 start ./bin/www创建 Nginx 配置文件(/etc/nginx/conf.d/cloud.conf)，用于对 Express 进行反向代理upstream cloud-app{ server 127.0.0.1:3000; keepalive 64;}server{ listen 80; server_name 119.29.215.155; root /home/cloud; location / { proxy_set_header HOST $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_pass http://cloud-app/; proxy_redirect off; proxy_read_timeout 240s; } }nginx -t 来检测配置文件是否正常如果没有报错，就执行 nginx -s reload 来让重新加载配置文件。 以上是我对下列视频及文章的归纳和总结。Linux 下部署 Express 环境","link":"/2020/04/14/Blog-about-learning-65/"},{"title":"Appinventor 服务器搭建","text":"升级系统至最新yum -y update必要软件安装yum -y install wget zip unzip git vim zlib.i686 libstdc++-4.8.5-28.el7.i686 libstdc++-4.8.5-28.el7_5.1.i686 gityum provides libstdc++.so.6yum -y install libstdc++-4.8.5-28.el7.i686下载与安装jdk8cd /optwget –no-check-certificate –no-cookies –header “Cookie: oraclelicense=accept-securebackup-cookie” https://download.oracle.com/otn-pub/java/jdk/8u191-b12/2787e4a523244c269598db4e85c51e0c/jdk-8u191-linux-x64.tar.gztar -zxvf jdk-8u191-linux-x64.tar.gzln -s /opt/jdk1.8.0_191 /opt/javaAnt安装cd /optwget http://mirrors.hust.edu.cn/apache//ant/binaries/apache-ant-1.10.5-bin.zipunzip apache-ant-1.10.5-bin.zipln -s /opt/apache-ant-1.10.5 /opt/apache-ant下载最新版本App Engine SDK for Javacd /optwget https://about-10050352.cos.ap-shanghai.myqcloud.com/appengine-java-sdk-1.9.69.zipunzip appengine-java-sdk-1.9.69.zipln -s /opt/appengine-java-sdk-1.9.69 /opt/appengine-java-sdk设置环境定位到/etc/profile目录末尾追加export ANT_HOME=/opt/apache-antexport JAVA_HOME=/opt/javaexport JRE_HOME=/opt/java/jreexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$ANT_HOME/bin:/opt/appengine-java-sdk/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib改好应是这样 /etc/profileSystem wide environment and startup programs, for login setupFunctions and aliases go in /etc/bashrcIt’s NOT a good idea to change this file unless you know what youare doing. It’s much better to create a custom.sh shell script in/etc/profile.d/ to make custom changes to your environment, as thiswill prevent the need for merging in future updates.pathmunge () { case “:${PATH}:” in :”$1”:) ;; *) if [ “$2” = “after” ] ; then PATH=$PATH:$1 else PATH=$1:$PATH fi esac} if [ -x /usr/bin/id ]; then if [ -z “$EUID” ]; then # ksh workaround EUID=/usr/bin/id -u UID=/usr/bin/id -ru fi USER=”/usr/bin/id -un“ LOGNAME=$USER MAIL=”/var/spool/mail/$USER”fi Path manipulationif [ “$EUID” = “0” ]; then pathmunge /usr/sbin pathmunge /usr/local/sbinelse pathmunge /usr/local/sbin after pathmunge /usr/sbin afterfi HOSTNAME=/usr/bin/hostname 2&gt;/dev/nullif [ “$HISTCONTROL” = “ignorespace” ] ; then export HISTCONTROL=ignorebothelse export HISTCONTROL=ignoredupsfi export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL By default, we want umask to get set. This sets it for login shellCurrent threshold for system reserved uid/gids is 200You could check uidgid reservation validity in/usr/share/doc/setup-*/uidgid fileif [ $UID -gt 199 ] &amp;&amp; [ “/usr/bin/id -gn“ = “/usr/bin/id -un“ ]; then umask 002else umask 022fi for i in /etc/profile.d/*.sh /etc/profile.d/sh.local ; do if [ -r “$i” ]; then if [ “${-#*i}” != “$-“ ]; then . “$i” else . “$i” &gt;/dev/null fi fidone unset iunset -f pathmungeexport ANT_HOME=/opt/apache-antexport JAVA_HOME=/opt/javaexport JRE_HOME=/opt/java/jreexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$ANT_HOME/bin:/opt/appengine-java-sdk/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib执行source /etc/profile安装AppInventor服务器搭建下载源码cd /optgit clone https://github.com/mit-cml/appinventor-sources.gitcd appinventor-sourcescp sample-.gitignore .gitignoregit submodule update –initAnt AppInventor代码cd /opt/appinventor-sources/appinventorant cleanant MakeAuthKeyant防火墙设置firewall-cmd –permanent –zone=public –add-port=8888/tcpfirewall-cmd –reload试运行dev_appserver.sh –port=8888 –address=0.0.0.0 –disable_update_check /opt/appinventor-sources/appinventor/appengine/build/war转移至正式运行目录cd /optmkdir ai2servercd ai2servercp -R /opt/appinventor-sources/appinventor/appengine/build/war ./cp -R /opt/appinventor-sources/appinventor/buildserver/build/run/lib ./开机启动新建/opt/ai2server/runai2.sh写入示例代码：/opt/ai2server/runai2.sh#!/usr/bin/bash###export ANT_HOME=/opt/apache-antexport JAVA_HOME=/opt/javaexport JRE_HOME=/opt/java/jreexport PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin:$ANT_HOME/bin:/opt/appengine-java-sdk/binexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib#pkill -9 javanohup dev_appserver.sh –port=8888 –address=0.0.0.0 –disable_update_check /opt/ai2server/war/ &amp;&gt; /var/log/ai2d.log &amp;echo $! &gt; /var/run/ai2d.pidcd /opt/ai2server/libnohup java -Xmx1828m -cp “*” -Dfile.encoding=UTF-8 com.google.appinventor.buildserver.BuildServer –dexCacheDir /tmp/ &amp;&gt; /var/log/ai2b.log &amp;echo $! &gt; /var/run/ai2b.pid新建/opt/ai2server/stopai2.sh写入示例代码：/opt/ai2server/stopai2.sh#!/usr/bin/bash###pkill -9 javaread PID &lt; /var/run/ai2d.pidkill -15 $PIDread PID &lt; /var/run/ai2b.pidkill -15 $PID加权限chmod +x /opt/ai2server/runai2.shchmod +x /opt/ai2server/stopai2.sh创建service新建/usr/lib/systemd/system/ai2.service写入示例代码：/usr/lib/systemd/system/ai2.service[Unit]Description=app inventor 2After=network.target[Service]Type=forkingExecStart=/opt/ai2server/runai2.shExecStop=/opt/ai2server/stopai2.shPrivateTmp=true[Install]WantedBy=multi-user.target启动systemctl start ai2.servicesystemctl enable ai2.service AppInventor-Sources更新cd /opt/appinventor-sourcesgit pullgit submodule updatecd /opt/appinventor-sources/appinventorant cleanant/opt/ai2server/stopai2.shsleep 10scp -Rf /opt/appinventor-sources/appinventor/appengine/build/war /opt/ai2server/cp -Rf /opt/appinventor-sources/appinventor/buildserver/build/run/lib /opt/ai2server//opt/ai2server/runai2.sh Appinventor服务器搭建","link":"/2020/04/14/Blog-about-learning-66/"},{"title":"搭建微信 AI 机器人","text":"搭建微信 AI 机器人","link":"/2020/04/14/Blog-about-learning-67/"},{"title":"搭建微信订阅号后台服务","text":"准备域名微信公众平台需要配置服务器地址 URL 访问，在实验开始之前，我们要准备域名。 域名注册挑选域名填写信息支付购买 域名解析到控制台添加解析记录 域名设置解析后需要过一段时间才会生效，通过 ping 命令检查域名是否生效，如： 1ping www.yourmpdomain.com 如果 ping 命令返回的信息中含有你设置的解析的 IP 地址，说明解析成功。 申请微信个人订阅号在开始搭建我们的订阅号服务器之前，需要先拿到订阅号相关信息。 获取微信订阅号公众平台认证字段信息我们需要获取3个字段：AppID Token EncodingAESKey。 登录微信公众平台，依次进入 开发 - 基本配置 可以拿到 AppID。在基本配置 - 服务器配置 - 修改配置 表单中：URL 填第一步申请的域名;Token 用户根据提示填写，用于后面校验服务端合法性;EncodingAESKey 点击随机生成按钮来生成。当点击表单提交按钮时，微信会通过 Token 来校验 URL 的合法性，这个我们在后面步骤实现，此界面暂时保留不关闭。 搭建 HTTP 服务下面的步骤，将带大家在服务器上使用 Node 和 Express 搭建一个 HTTP 服务器 安装 NodeJS 和 NPM使用下面的命令安装 NodeJS 和 NPM 12curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -yum install nodejs -y 安装完成后，使用下面的命令测试安装结果 1node -v 编写 HTTP Server 源码创建工作目录使用下面的命令在服务器创建一个工作目录： 1mkdir -p /data/release/weapp 进入此工作目录 1cd /data/release/weapp 创建 package.json在刚才创建的工作目录创建 package.json，添加我们服务器包的名称和版本号，可参考下面的示例示例代码：/data/release/weapp/package.json 1234{ &quot;name&quot;: &quot;weapp&quot;, &quot;version&quot;: &quot;1.0.0&quot;} 完成后，使用 Ctrl + S 保存文件 添加 Server 源码在工作目录创建 app.js，使用 Express.js 来监听 5050 端口[?]，可参考下面的示例代码(注：请将 app.js 文件中的token/appid/encodingAESKey等配置项替换为您的订阅号对应的取值)。 示例代码：/data/release/weapp/app.js 1234567891011121314151617181920212223242526272829303132// 引用 express 来支持 HTTP Server 的实现const express = require('express');// 引用微信公共平台自动回复消息接口服务中间件var wechat = require('wechat');// 创建一个 express 实例const app = express();// 配置微信公众平台参数，在教程第二步中获取var config = { token: 'your token', // 填第二步中获取的 `token` appid: 'your appid', // 填第二步中获取的 `appid` encodingAESKey: 'your encodingAESKey', // 填第二步中获取的 `encodingAESKey` checkSignature: true // 可选，默认为true。由于微信公众平台接口调试工具在明文模式下不发送签名，所以如要使用该测试工具，请将其设置为false };app.use(express.query());app.use('/', wechat(config, function (req, res, next) { res.reply({ content: '你好，Hello World!', type: 'text' });}));// 监听端口，等待连接const port = 5050;app.listen(port);// 输出服务器启动日志console.log(`Server listening at http://127.0.0.1:${port}`); 运行 HTTP 服务安装 PM2在开始之前，我们先来安装 1npm install pm2 --global PM2 安装时间可能稍长，请耐心等候 安装 Express我们的服务器源码里使用到了 Express 模块，下面的命令使用 NPM 来安装 Express 12cd /data/release/weappnpm install express --save 安装 Wechat我们的服务器源码里使用到了 Wechat 模块，下面的命令使用 NPM 来安装 Wechat 12cd /data/release/weappnpm install wechat --save 启动服务安装完成后，使用 PM2 来启动 HTTP 服务 12cd /data/release/weapppm2 start app.js 现在，您的 HTTP 服务已经运行。要查看服务输出的日志，可以使用下面的命令： 1pm2 logs 如果要重启服务，可以使用下面的命令： 1pm2 restart app 我们使用 PM2 来进行 Node 进程的运行、监控和管理 NPM 仓库在国内访问速度可能不太理想，如果实在太慢可以尝试使用 CNPM 的 Registry 进行安装： npm install pm2 -g --registry=https://r.cnpmjs.org/ 搭建 nginx 对外服务NodeJs只是侦听的机器上的 5050 端口，我们使用 nginx 侦听 80 端口提供对外域名服务 安装 Nginx在 CentOS 上，可直接使用 yum 来安装 Nginx 1yum install nginx -y 安装完成后，使用 nginx 命令启动 Nginx： 1nginx 此时，访问 http://您的域名 可以看到Nginx 的测试页面 如果无法访问，请重试用 nginx -s reload 命令重启 Nginx 配置 HTTP 反向代理外网用户访问服务器的 Web 服务由 Nginx 提供，Nginx 需要配置反向代理才能使得 Web 服务转发到本地的 Node 服务。Nginx 配置目录在 /etc/nginx/conf.d，我们在该目录创建 wechat.conf示例代码：/etc/nginx/conf.d/wechat.conf 12345678server { listen 80; server_name www.example.com; # 改为第一步申请的域名 location / { proxy_pass http://127.0.0.1:5050; }} 按 Ctrl + S 保存配置文件，让 Nginx 重新加载配置使其生效： 1nginx -s reload 在浏览器通过 http 的方式访问你解析的域名来测试 HTTP 是否成功启动 使用Server端回复微信消息提交服务端配置我们将第二步微信公众平台中保留的表单提交，同时将 基本配置 - 服务器配置 启用 关注、发送与消息回复首先通过二维码关注微信订阅号在聊天界面向微信公众号发送一条消息最终我们会回到一条 你好，Hello World! 的回复 大功搞成 相关资料搭建微信订阅号后台服务添加解析记录","link":"/2020/04/14/Blog-about-learning-68/"},{"title":"收藏家","text":"小程序如何实现生成海报分享朋友圈(实战总结)我用EggJS开发了一个日增量过亿的数据可视化平台读 koa2 源码后的一些思考与实践H5常见问题及解决方法小程序-云开发-如何对敏感词进行过滤即内容安全的检测(下)小程序-云开发-如何对敏感词进行过滤即内容安全的检测(上)你可能不知道的 21 个 Web API2019精选文章目录面试时，碰到过哪些棘手Vue面试题深究 Vue 底层原理源码前端常见20道高频面试题深入解析记录一次docker+jenkins+gitlab搭建内网开发环境如何设计实现 PC 站点搭建系统别担心把 console 带到线上涨薪 30 % 以上，看这篇万字干货就行前端应该如何准备数据结构和算法？10 问 10 答，带你快速入门前端算法前端进阶算法3：从浏览器缓存淘汰策略和Vue的keep-alive学习LRU算法75个JavaScript面试题集锦，内含解答，自测 JS 掌握程度CSS 渲染原理以及优化策略前端缓存最佳实践10个Vue开发技巧助力成为更好的工程师Vue响应式原理CSS样式不起作用？史上最全解决方法汇总Vue传值与状态管理总结VUE 3.0 学习探索入门系列 - 用几个 demo 认识 vue3VUE 3.0 学习探索入门系列 - vue2.x/React/vue3.x 简单横评VUE 3.0 学习探索入门系列 - 纠结要不要升级到Vue3.0？该如何升级？Vue3.x 生命周期 和 Composition API 核心语法理解《Vue.js应用测试》平庸前端码农之蜕变 — AST298行代码带你理解Vue响应式原理和next-Tick原理webpack 入门及优化指南Vue性能优化之最佳实践58 道 Vue 常见面试题集锦，涵盖入门到精通，自测 Vue 掌握程度一杯茶的时间，上手 Docker三步助你理解webpack构建原理链接：https://pan.baidu.com/s/1wuluWiWAIx1ghbvU42kiCA提取码：y11q 基于Appium的UI自动化测试如何监控网页崩溃？大厂是怎么做移动端适配的基于 Vue 技术栈的微前端设计思路与落地实践了解 Nginx 基本概念花椒前端基于 Docker 的 SSR 持续开发集成环境实践Hybrid 应用中 H5 与 Native 通信的那点事儿推荐一个基于Vue 的 H5 快速开发模板一文搞懂主流的扫码登录技术原理564- Wireshark抓包使用指南究竟如何保证session一致性？如何与 Service Worker 通信基于 Vue 的两层吸顶踩坑总结一步步从零开始用 webpack 搭建一个大型项目​JS 原生面经从初级到高级【近 1.7W 字】各种场景唤起 App 骚操作写给新手前端的各种文件上传攻略，从小图片到大文件断点续传我们应该如何编写高质量的前端代码若川知乎问答：2年前端经验，做的项目没什么技术含量，怎么办？万字解析微前端、微前端框架qiankun以及源码小程序原生开发与第三方框架选择小程序 UI 框架对比webpack不可错过的打包优化方法前端性能优化指南2020前端性能优化清单（六）前端学习数据结构与算法系列(五)：冒泡排序的理解与实现一杯茶的时间，上手 Git 团队协作开发一杯茶的时间，上手第三方登录类库 JustAuth淘系技术部 | 如何为搭建物料智能生成代码 - 自动编码移动端必备的H5问题及解决方案2020前端性能优化清单（一）微前端在小米 CRM 系统的实践爬虫毕设（四）：多页爬取和数据持久化JS 图片压缩解析与实战还不懂移动端适配快看这篇文章人手一套Linux环境之：Windows版本教程Web上的图片技巧h5 小游戏总结及踩坑记录前端性能优化之谈谈常见的性能指标及上报策略当前端基建任务落到你身上，该如何推动协作？用 Node.js 爬虫下载音乐如何使用 Proxy 来代理 JavaScript 里的类Web上的图片技巧运用 NutUI - 快捷开发京东企业业务之酷兜2020前端性能优化清单之一探索 Serverless 中的前端开发模式前端需要了解的9种设计模式我写CSS的常用套路(附demo的效果实现与源码）Web应用程序如何工作：客户端开发和部署[视频]Canvas玩转图像处理[视频]zepto设计和源码分析[视频]mobx入门基础教程[视频]基于WebAR实现3D任务书桌上跳舞 Proxy使用详解","link":"/2020/04/13/Blog-about-learning-61/"},{"title":"uni-app 从入门到实践开发","text":"uni-appuni-app背景介绍当前跨平台开发存在的3个问题1、多端泛滥2、体验不好3、生态不丰富 uni-app 产品特征1、跨平台更多 —— 条件编译：优雅的在一个项目里调用不同平台的特色功能！2、运行体验更好 —— 组件、api与微信小程序一致，兼容 weex 原生渲染3、通用技术栈，学习成本更低 —— vue 的语法、微信小程序的api、内嵌 mpvue4、开放生态，组件更丰富 —— 支持通过 npm 安装第三方包、支持微信小程序自定义组件及 SDK、兼容 mpvue 组件及项目、App 端支持和原生混合编码、DCloud 将发布插件市场 功能框架 uni-app 规范页面文件遵循 Vue 单文件组件（SFC）规范组件标签靠近小程序规范接口能力（JS API）靠近微信小程序规范数据绑定及事件处理同 Vue.js 规范为兼容多端运行，建议使用 flex 布局进行开发 条件编译1234567891011121314&lt;template&gt; &lt;view class=&quot;content&quot;&gt; &lt;!-- #ifdef MP-WEIXIN --&gt; &lt;view class=&quot;&quot;&gt; 只会编译到小程序 &lt;/view&gt; &lt;!-- #endif --&gt; &lt;!-- #ifdef APP-PLUS --&gt; &lt;view class=&quot;&quot;&gt; 只会编译到 APP &lt;/view&gt; &lt;!-- #endif --&gt; &lt;/view&gt;&lt;/template&gt; 生命周期应用生命周期页面生命周期组件生命周期组件name 配置pages.jsonglobalStyle pages API快速创建项目通过 HBuilderX 创建项目通过vue-cli命令行 创建项目123// 安装 vue clinpm install -g @vue/clivue create -p dcloudio/uni-preset-vue my-project native.js1234567891011121314// 安卓 拨打电话function call(){ // 导入Activity、Intent类 var Intent = plus.android.importClass(&quot;android.content.Intent&quot;); var Uri = plus.android.importClass(&quot;android.net.Uri&quot;); // 获取主Activity对象的实例 var main = plus.android.runtimeMainActivity(); // 创建Intent var uri = Uri.parse(&quot;tel:10010&quot;); // 这里可修改电话号码 var call = new Intent(&quot;android.intent.action.CALL&quot;,uri); // 调用startActivity方法拨打电话 main.startActivity( call ); // ... } uni-app 项目目录结构单文件vue.js文件导入尺寸单位rpx 代码块提示HBuilderX 快捷键项目发行项目配置 页面配置pages style app-plus 微信小程序 配置condition:{} navigator 跳转 组件、组件生命周期 组件传值 props\\emit、uni.$on、uni.$emit uni-ui 组件库的引入 uni-app 规范 条件编译 App 端的 nvue 开发 HTML5+ 组件、自定义组件、基础组件、生命周期、路由、API、语法、布局样式 Hbuiderx vuecli方式 微信开放平台 unionid 分享 交互反馈 redis 根据用户信息生成 随机 key 登录根基这个生成的随机键来判断 （根据用户信息+上次登录的时间）-临时想法 uniapp 一键登录 e.currentTarget.id e.target.id 获取系统信息 设置导航条 下拉刷新 onpullDownRefresh 上拉加载 onReachBottom 登录 openid unionid多端一致 微信开发平台 全局变量 节点信息 socket 的使用 123456789101112131415161718192021import io from './common/weapp.socket.io.js'Vue.prototype.socket = io('http://192.168.1.3:8082')methods:{ // 发送讯息 send: function(){ if(this.cont.length&gt;0){ this.arr.push(this.cont); let aa = this.cont this.socket.emit('message','aa') } } // 接受广播讯息 getmsg: function(){ this.socket.on('gbmsg',data=&gt;{ this.arr.push(data); }) }} uni-app 去掉 App、h5 端的导航栏pages.json 123456789&quot;globalStyle&quot;: { &quot;navigationBarTextStyle&quot;: &quot;white&quot;, &quot;navigationBarTitleText&quot;: &quot;uni-app&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#007AFF&quot;, &quot;backgroundColor&quot;: &quot;#FFFFFF&quot;, &quot;h5&quot;: { &quot;titleNView&quot;: false }} 全局样式引入 vue 1234// App.vue &lt;style&gt; @import url('/common/free.css')&lt;/style&gt; 引入图标库 12345/* icon.css */@font-face{ font-family: &quot;iconfont&quot;; src: url('data:base64') format('woff2');} 123456// App.vue&lt;style&gt; /* #ifndef APP-PLUS-NVUE */ @import url('/common/icon.css') /* endif */&lt;/style&gt; nvue 1234567891011// 只支持 unicode// App.vue&lt;script&gt; onLaunch: function(){ const domModule = weex.requireModule('dom') domModule.addRule('fontFace', { 'fontFamily': &quot;iconfont&quot;, 'src': &quot;url('http://at.alicdn.com/t/font_1469606063_76593.ttf')&quot; }); }&lt;/script&gt; midButton 中间凸起按钮设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495{ &quot;pages&quot;: [{ &quot;path&quot;: &quot;pages/component/index&quot;, &quot;style&quot;: { &quot;navigationBarTitleText&quot;: &quot;组件&quot; } }, { &quot;path&quot;: &quot;pages/API/index&quot;, &quot;style&quot;: { &quot;navigationBarTitleText&quot;: &quot;接口&quot; } }, { &quot;path&quot;: &quot;pages/component/view/index&quot;, &quot;style&quot;: { &quot;navigationBarTitleText&quot;: &quot;view&quot; } }], &quot;condition&quot;: { //模式配置，仅开发期间生效 &quot;current&quot;: 0, //当前激活的模式（list 的索引项） &quot;list&quot;: [{ &quot;name&quot;: &quot;test&quot;, //模式名称 &quot;path&quot;: &quot;pages/component/view/index&quot; //启动页面，必选 }] }, &quot;globalStyle&quot;: { &quot;navigationBarTextStyle&quot;: &quot;black&quot;, &quot;navigationBarTitleText&quot;: &quot;演示&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#F8F8F8&quot;, &quot;backgroundColor&quot;: &quot;#F8F8F8&quot;, &quot;usingComponents&quot;:{ &quot;collapse-tree-item&quot;:&quot;/components/collapse-tree-item&quot; }, &quot;renderingMode&quot;: &quot;seperated&quot;, // 仅微信小程序，webrtc 无法正常时尝试强制关闭同层渲染 &quot;pageOrientation&quot;: &quot;portrait&quot;, //横屏配置，全局屏幕旋转设置(仅 APP/微信/QQ小程序)，支持 auto / portrait / landscape &quot;rpxCalcMaxDeviceWidth&quot;: 960, &quot;rpxCalcBaseDeviceWidth&quot;: 375, &quot;rpxCalcIncludeWidth&quot;: 750 }, &quot;tabBar&quot;: { &quot;color&quot;: &quot;#7A7E83&quot;, &quot;selectedColor&quot;: &quot;#3cc51f&quot;, &quot;borderStyle&quot;: &quot;black&quot;, &quot;backgroundColor&quot;: &quot;#ffffff&quot;, &quot;height&quot;: &quot;50px&quot;, &quot;fontSize&quot;: &quot;10px&quot;, &quot;iconWidth&quot;: &quot;24px&quot;, &quot;spacing&quot;: &quot;3px&quot;, &quot;list&quot;: [{ &quot;pagePath&quot;: &quot;pages/component/index&quot;, &quot;iconPath&quot;: &quot;static/image/icon_component.png&quot;, &quot;selectedIconPath&quot;: &quot;static/image/icon_component_HL.png&quot;, &quot;text&quot;: &quot;组件&quot; }, { &quot;pagePath&quot;: &quot;pages/API/index&quot;, &quot;iconPath&quot;: &quot;static/image/icon_API.png&quot;, &quot;selectedIconPath&quot;: &quot;static/image/icon_API_HL.png&quot;, &quot;text&quot;: &quot;接口&quot; }], &quot;midButton&quot;: { &quot;width&quot;: &quot;80px&quot;, &quot;height&quot;: &quot;50px&quot;, &quot;text&quot;: &quot;文字&quot;, &quot;iconPath&quot;: &quot;static/image/midButton_iconPath.png&quot;, &quot;iconWidth&quot;: &quot;24px&quot;, &quot;backgroundImage&quot;: &quot;static/image/midButton_backgroundImage.png&quot; } }, &quot;easycom&quot;: { &quot;autoscan&quot;: true, //是否自动扫描组件 &quot;custom&quot;: {//自定义扫描规则 &quot;^uni-(.*)&quot;: &quot;@/components/uni-$1.vue&quot; } }, &quot;topWindow&quot;: { &quot;path&quot;: &quot;responsive/top-window.vue&quot;, &quot;style&quot;: { &quot;height&quot;: &quot;44px&quot; } }, &quot;leftWindow&quot;: { &quot;path&quot;: &quot;responsive/left-window.vue&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;300px&quot; } }, &quot;rightWindow&quot;: { &quot;path&quot;: &quot;responsive/right-window.vue&quot;, &quot;style&quot;: { &quot;width&quot;: &quot;300px&quot; }, &quot;matchMedia&quot;: { &quot;minWidth&quot;: 768 } }} 12345678// 只支持 unicode// App.vue&lt;script&gt; onLaunch: function(){ uni.onTabBarMidButtonTap(()=&gt;{ }) }&lt;/script&gt; 业务刷礼物listApp nvue 专用组件app端nvue专用组件。在app-nvue下，如果是长列表，使用list组件的性能高于使用view或scroll-view的滚动。原因在于list在不可见部分的渲染资源回收有特殊的优化处理。 如果需要跨端，建议使用 uni-ui 的 uni-list组件，它会自动处理webview渲染和原生渲染的情况，在app-nvue下使用list组件，而在其他平台则使用页面滚动。 1234567891011121314151617// live.nvue&lt;template&gt; &lt;f-gift ref=&quot;gift&quot;&gt;&lt;/f-gift&gt;&lt;/template&gt;&lt;script&gt; mounted(){ setInterval(()=&gt;{ this.$refs.gift.send({ username: '发送人', avatar: &quot;&quot;, gift_name: '蛋糕', gift_image: '/static/gift/3.png', num: 1 }) }) }&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// f-gift.vue 礼物组件&lt;template&gt; &lt;list style=&quot;width:520rpx;height:500rpx;&quot; :show-scrollbar=&quot;false&quot; :bounce=&quot;false&quot;&gt; &lt;!-- 注意事项: 不能使用 index 作为 key 的唯一标识 --&gt; &lt;cell class=&quot;flex align-center px-3&quot; v-for=&quot;(item, index) in dataList&quot; :key=&quot;item.id&quot; insert-animation=&quot;default&quot; delete-animation=&quot;default&quot;&gt; &lt;view style=&quot;width: 325rpx;&quot;&gt; &lt;/view&gt; &lt;/cell&gt; &lt;/list&gt;&lt;/template&gt;&lt;script&gt; const domModule = weex.requireModule('dom') export default { data () { return { gifts: [{}] } }, method:{ // 送礼物 send(gift){ this.gifts.push(gift) this.toBottom(); this.autoHide(); } // 置于底部 toBottom(){ this.$nextTick(() =&gt; { let index = this.gifts.length -1 let ref = 'item' + index if(this.$refs[ref]){ dom.scrollToElement(this.$refs[ref][0],{}) } }) }, // 自动消失 autoHide(){ if(this.gifts.length){ let timer = setTimeout(()=&gt;{ this.gifts.splice(0,1); },5000) } } } }&lt;/script&gt; 弹幕123456789101112131415161718&lt;template&gt; &lt;view&gt; &lt;scroll-view scroll-y=&quot;true&quot; scroll-with-animation :scroll-inio-view=&quot;scrollInToView&quot;&gt; &lt;view :id=&quot;'danmu'+item.id&quot; &gt; &lt;/view&gt; &lt;/scrioll-view&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; methods: { toBottom(){ let len = this.list.length; if(len &gt; 0 &amp;&amp; this.list[len-1]){ this.scrollInToView = 'danmu' + this.list[len - 1].id } } }&lt;/script&gt; UI 框架uView：uView是uni-app生态专用的UI框架，uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码， 可发布到iOS、Android、H5、以及各种小程序(微信/支付宝/百度/头条/QQ/钉钉)等多个平台(引言自uni-app网)ThorUI：简约而不简单一直是ThorUI的追求。ThorUI目前有微信小程序原生版本和uni-app版本，后续会扩展到其他原生版本，扩大生态。 除了组件库ThorUI还会陆续发布一些常用模板，使开发更加高效。 目前组件与模板默认支持App端(IOS和Android)、H5、微信小程序、QQ小程序。 colorui：鲜亮的高饱和色彩，专注视觉的小程序组件库 报错微信小程序 forceUpdate 错误 123456789101112131415161718SystemError (appServiceSDKScriptError)Cannot read property 'forceUpdate' of undefinedTypeError: Cannot read property 'forceUpdate' of undefined at http://127.0.0.1:28307/appservice/__dev__/WAService.js:2:1415111 at http://127.0.0.1:28307/appservice/__dev__/WAService.js:2:633507 at o (http://127.0.0.1:28307/appservice/__dev__/asdebug.js:1:3197) at e.exports.&lt;anonymous&gt; (http://127.0.0.1:28307/appservice/__dev__/asdebug.js:1:3577) at http://127.0.0.1:28307/appservice/__dev__/asdebug.js:1:1844 at Array.forEach (&lt;anonymous&gt;) at WebSocket._ws.onmessage (http://127.0.0.1:28307/appservice/__dev__/asdebug.js:1:1826)console.error @ VM38:1errorReport @ VM45 WAService.js:2(anonymous) @ VM45 WAService.js:2(anonymous) @ VM45 WAService.js:2o @ VM42 asdebug.js:1(anonymous) @ VM42 asdebug.js:1(anonymous) @ VM42 asdebug.js:1_ws.onmessage @ VM42 asdebug.js:1 配置微信小程序 AppID sitemap.json 错误 sitemap.json Error: 未找到入口 sitemap49.json 文件，或者文件读取失败，请检查后重新编译。 根目录下创建 sitemap.json 并配置 uni-app 图表 H5端流行的echart报表因为涉及大量dom操作，无法跨端使用，而wx-chart在跨端和更新方面都不足，如果要做小程序，推荐使用全端可用的uChart。 如只考虑H5端，也可以继续使用 echart、f2等常规web图表。 如不考虑小程序，那么App端和H5，还可以通过renderjs 技术来使用 echart、f2等web图表，功能性能比uchart更好。什么是renderjs、基于renderjs使用echart的示例 不开发APP，可以不使用nvue 插件插件大赛2020评奖结果揭晓，这些优秀的插件你都用起来了吗？ 极光认证官方SDK uCharts高性能跨全端图表 uParse修复版-html富文本加载 APP-引导页+官方示例 封装的request网络请求 开源项目Uni-App awesome-uni-app 来客推电商 / 小程序商城+APP+SaaS+前后代码开源 相关资料[视频]uni-app跨平台框架官方教程√[视频]uni-app实战直播app全栈开发，uni-app实战视频教程√ [视频]uni-App从入门到实战[视频]uni-app实战商城类app和小程序 [视频]uni-app 快速入门 从零开始实现新闻资讯类跨端应用[视频]uni-app基础+进阶+案例[视频]uni-app零基础入门到项目实战 uni-app 零基础到实战课程 2020uniApp视频全套资料配源码【千锋Web前端】uniapp 打造美团外卖微信小程序，uni-app，vue 中高级实战课程ThinkPHP6+uniapp实战开发【简书app】uni-app 跨平台 App 终极解决方案uni-app视频教程合集|UniApp实战教程 小程序开发：用原生还是选框架（wepy/mpvue/taro/uni-app）– 第1季创建、运行、发布uni-appuni-app 全局变量的几种实现方式uni-app 中保持用户登录状态uni-app去掉h5端的导航栏uni-app中过滤器的使用uniapp获取微信手机号码uni-app H5跨域问题解决方案（CORS、Cross-Origin）直播业务指南历时六个月月完全由UNI做推流APP的经历分享 跨平台前端框架uni-app学习Native.js示例汇总dcloud 社区问答 SystemError (appServiceSDKScriptError)高效开发技巧开发规范 uni-app官方教程学习手记√uni-app—从安装到卸载√wepy踩坑 sitemap.json Error: 未找到入口 sitemap49.json 文件，或者文件读取失败，请检查后重新编译。√解决uni-app开发环境中H5端跨域问题√ uni-app 全局变量的几种实现方式√ uni-app 启动界面（splash）参数配置说明 | 启动慢的原因(https://ask.dcloud.net.cn/article/35021)√ HBuilder X运行小程序时，打开了微信开发者工具，但微信开发者工具未运行项目但又没有错误提示√ uni-app 小程序系列教程 uni-app官网 uni-app 资源在线升级/热更新 uni-app 整包升级/更新方案 关于 uni-app白话uni-appvuevue和微信小程序的区别、比较uni-uiH5 端路由配置网络请求封装拦截等可参考插件市场从App端跳转到微信小程序方式uni-app导航栏文档和注意事项导航栏开发指南导航栏演示示例uni-app大法好 ，nvue 从入坑到放弃uni-app小程序手把手项目实战 uni-app网络请求封装uni-app 请求封装 http://www.hcoder.net/tutorials/info/id/1335 Native.js示例汇总","link":"/2020/04/16/Blog-about-learning-69/"},{"title":"面面俱到","text":"面试题 —— 基础篇涉及知识点基础知识：原型、原型链、作用域、闭包、异步、单线程JSAPI：DOM 操作、 ajax、事件绑定开发环境：版本管理、模块化、打包工具运行环境：页面渲染、性能优化 原始类型有哪几种 null 是对象嘛在 JS 中，存在着 6 种原始值，分别是 boolean null undefined number string symbol 首先原始类型存储的都是值，是没有函数可以调用的，比如 undefined.toString()‘1’.toString() 可以使用原因是 ‘1’ 被强制转换成了 String 类型，String 类型也是对象类型。js 的 number 类型是浮点型，使用计算中会出现 bug ，比如 0.1 + 0.2 != 0.3。string 类型是不可变的。null 是对象类型是历史遗留 bug ，在 js 的最初版本中使用的是 32 位 系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零。 对象类型和原始类型的不同之处 函数参数是对象会发生什么问题在 js 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间用来存放值，但是我们需要找到这个空间，这空间会拥有一个地址（指针）。 123const a = []const b = ab.push(1) 对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置放了值 []，常量 a 存放了地址（指针） #001。 前端需要注意哪些 SEO 合理的 title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同； keywords 列举出重要关键词即可 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用 js 输出：爬虫不会执行 js 获取内容 少用 iframe：搜索引擎不会抓取 iframe 中的内容 非装饰性图片必须加 alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 JS 中使用 typeof 能得到的哪些类型何时使用 === 何时使用 ==window.onload 和 DOMContentLoaded 的区别用 JS 创建 10个 a 标签，点击的时候弹出来对应的序号简述如何实现一个 模块加载器，实现类似 require.js 和基本功能实现数组的随机排序Ajax 请求的步骤第一步（得到 XMLHttpRequest）第二部（打开与服务器的链接）xmlHttp.open(请求方式，请求URL，是否异步)；用来打开与服务器的连接，需要三个参数；第三部（发送请求）xmlHttp.send(null);如果括号里不给 null 可能会造成部分浏览器无法发送；第四部在 xmlHttp 对象的一个事件上注册监听器： onreadystatechange 得到的 5个状态 0状态：刚创建，还没有调用 open()方法； 1状态：请求刚开始，调用了 open()方法，但是没有调用 send 方法； 2状态：调用完了 send()方法； 3状态：服务器已经开始响应。但不表示响应结束； 4状态：服务器响应结束！得到 xmlHttp 对象状态var state = xmlHttp.readyState; // 可能是 0,1,2,3,4得到服务器的响应状态码var state = xmlHttp.status; // 可能是 200、404、200得到服务器的响应内容 相关资料[视频]BAT大牛带你横扫初级前端JavaScript面试[视频]前端面试求职跳槽通关路线两年前端 9 ~ 10月面经（已拿阿里，头条，pdd，快手 offer）前端面试之道掘金 前端面试之道2失业两个月拿到offer后，入手MacBook Pro！新出炉的阿里、腾讯、美团以及网易等一线公司面试总结推荐这 10 个 GitHub 上超火的前端面试项目，打造自己的加薪宝库！推荐几个大厂的前端代码规范，你也能写出诗一样的代码！面试官：说说你对SPA（单页应用）的理解?分享一位同学的阿里、百度前端面经互联网寒冬，一年经验字节跳动、虾皮、快手、拼多多前端面试总结JavaScript 正则表达式迷你书JS正则表达式完整教程2 年前端 7～9 月大厂面试经历总结阿里、腾讯、美团以及网易等一线互联网公司面试总结","link":"/2020/04/18/Blog-about-learning-70/"},{"title":"APICloud 笔记","text":"入门基础 新手必看篇 入门概念篇 初级代码篇 书籍配套视频 界面布局基础 网络通信 新手必看篇 视频讲义视频学习目标： 总体上了解一下 APICloud 平台，重点介绍相关的学习资源，入门资料，常见的 FAQ 等。 明确我们这七天要开发一个什么样的 APP，明确功能需求，跟上每天的课程节奏，可以课前预习 梳理出对于一款 APP，在开发之前（Coding 之前），一些通用而又重要的准备工作，适合于所有 APP 开发，而非单指 APICloud。 APICloud 平台介绍 查看 APICloud 平台能力 APICloud 平台能否满足自己的 APP 开发需求? 查看 APICloud API 文档了解 APICloud 文档组织结构，学会通过文档搜索，找到需要的功能。APICloud 平台功能体系: 文档搜索，找到需要的功能例如：视频播放功能 APICloud 提供了很多解决方案； 点开其中一个，可以看到提供的功能、代码示例等等。 APICloud 应用的开发模式和使用的技术语言前端开发者开发模式：HTML/CSS/JavaScript + APICloud 扩展 API原生开发者代码自动生成 APICloud 扩展 API 调用方式： 123456789核心模块在 window.api 对象下，不需要单独引用，可以直接调用api.methodName(param, callback);扩展模块需要 require 引入，遵守 CommonJS 规范var module = api.require('moduleName');module.methodName(param, callback);param: {} //参数，是一个JSON对象callback: function(ret, err){} //回调函数，是一个Function对象，方法调用的结果通过此函数返回 例如： 打开新窗口：api.openWin();打开系统通讯录：api.openContacts();录音：api.startRecord();缓存网络图片：api.imageCache();加载 fs 模块：var fs = api.require(‘fs’);新建一个文件：fs.createFile();加载二维码/条形码扫描模块：var scanner = api.require(‘FNScanner’);打开二维码/条形码扫描: scanner.openScanner(); 为什么要扩展 API？ 在APICloud 聚合 API可以看到 APICloud 扩展的功能 APICloud 平台定位: APICloud 技术、产品、生态、案例、商业模式的总体介绍 推荐视频入门概念篇 1-3 讲 APICloud 开发者相关的服务支撑体系 如何解决开发者的问题？能为开发者提供哪些机会？是否有围绕开发者的生态模式？是否有一个完善的开发者相关支持服务体系来方便技术学习和社区交流？是否有一个完善的生态体系，来支持支撑 APICloud APP 开发，来满足各种不同的行业需求，来支撑实现需求复杂，功能强大的应用 开发平台 开发工具 开发文档 开发者社区 VIP 技术支持 示例源码分享 商业案例展示 模块 Store（聚合 API） 模版 Store 应用定制服务 新手应该如何开始入门 APICloud 应用开发 新手开发指南APICloud 新手教程集合贴视频教程线上培训 APICloud 平台使用流程 APICloud 云控制台使用 开发控制台 APICloud 应用开发的基本流程 创建应用 配置图标启动页 设置证书 同步代码 添加模块 云编译 推荐视频入门概念篇 第 5 讲 选择一款主流 H5 编码工具并安装相应的 APICloud 插件 APPLoader 加载 Widget 的路径：android: sdcard/UZMap/wgt/ios: Document/uzfs/wgt/ 推荐视频：APICloud 视频之初级代码篇第 9-11 讲自定义 loader 使用推荐文档：自定义 loader 说明 APICloud 应用开发的基础操作流程 在 APICloud 平台上有 4 种查看 APP 运行效果的手段： 官方 AppLoader自定义 AppLoader云编译测试包云编译正式包 应用需求分析 梳理需求说明文档 输出需求说明文档 进行 UE/UI 设计 输出 UE/UI 设计： 产品原型文件、原始 UI 设计图、UI 切图 总体架构设计 APICloud 应用设计思想 UI 架构设计 APICloud 应用的 UI 组成结构 功能点分解开放服务选择数据接口定义 相关资料APICloud 7 天培训课APICloud 七天在线培训课教程模块 store 常见模块必备使用指南数据云服务APICloud 优秀案例直播系列活动汇总APICloud 社区精品源码集合贴APICloud 视频30天 App开发从0到1","link":"/2020/01/01/Blog-about-learning-7/"},{"title":"git、gitHub 从入门到实践应用","text":"git 简单的流程新建一个目录，将其初始化为Git代码库 git init [project-name] git init -y 我老喜欢加 -y 应该是 npm init -y 项目初始化……哈哈 克隆远端 git clone https://github.com/Fallen-down/multi-end 切换到 master 分支 git checkout master 切换到 dev 远端分支本地也新增一个 dev 分支并切换到 dev 分支 git checkout -b dev origin/dev 拉取最新代码 git pull 新建一个开发分支 develop git checkout -b develop master 显示有变更的文件 git status 添加指定目录到暂存区，包括子目录 git add [dir] 添加当前目录的所有文件到暂存区 git add . 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] 提交暂存区到仓库区 git commit -m '提交内容' Git配置git config --list 编辑Git配置文件 git config -e [--global] 设置提交代码时的用户信息 git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 帮助程序将凭据存储在磁盘上 git config credential.helper store 查看所有分支 git branch -a 查看推送远端 git remote -v 合并分支 git checkout master git merge develop 删除本地分支 git branch -D dev 删除远端 develop git push origin :develop 上传本地指定分支到远程仓库 git push [remote] [branch] 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --hard [commit] 回滚上一次提交 git reset --hard head^ git reflog git reset –hard 1456 新建一个tag在当前commit git tag [tag] 与主干同步12$ git fetch origin$ git rebase origin/master 合并commit1$ git rebase -i origin/master 发出Pull Request提交到远程仓库以后，就可以发出 Pull Request 到master分支，然后请求别人进行代码review，确认可以合并到master。 git remote12345678910// 参看远程主机的网址。$ git remote -v// 查看该主机的详细信息。$ git remote show &lt;主机名&gt;// 添加远程主机$ git remote add &lt;主机名&gt; &lt;网址&gt;// 删除远程主机$ git remote rm &lt;主机名&gt;// 远程主机的改名$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch1$ git fetch origin master git pull12取回 origin 主机的next分支，与本地的master分支合并$ git pull origin next:master git push12// 将本地分支的更新，推送到远程主机$ git push -u origin master Git 工作流程开发环境 master预发环境 pre-production生产环境 production 代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到pre-production，这一步也没有问题，才进入production。 工作中遇到的问题git push到GitHub的时候遇到! [rejected] master -&gt; master (non-fast-forward)的问题 12345678git pull origin master --allow-unrelated-histories //把远程仓库和本地同步，消除差异git branch --set-upstream-to=origin/master master // 建立联系git remote add origin url // 添加远端git remote set-url origin https://gitee.com/li_huai/mobile-admin.git //删除远端 以上是我对下列视频及文章的归纳和总结。常用 Git 命令清单Git使用规范流程Git分支管理策略Git远程操作详解Git 工作流程Pull Request 的命令行管理git push到GitHub的时候遇到! [rejected] master -&gt; master (non-fast-forward)的问题码云创建分支＿上传到分支＿合并分支（vue_Travel项目）Git 分支 - 分支的新建与合并 git 切换远程分支 提高国内访问 Github 速度的 9 种方法","link":"/2020/04/18/Blog-about-learning-74/"},{"title":"Blog-about-learning-754","text":"微信小程序 | 全新语法","link":"/2020/04/18/Blog-about-learning-75/"},{"title":"Blog-about-learning-76","text":"Web前端开发之VUE入门到进阶实例【金渡教育】","link":"/2020/04/18/Blog-about-learning-76/"},{"title":"UI 框架","text":"英文 | https://www.geeksforgeeks.org/10-best-css-frameworks-for-frontend-developers-in-2020/?ref=rp翻译 | web前端开发（ID：web_qdkf) Bootstrap 快速成型 大型生态系统 大量的组件 LESS和SASS支持 简单的文档和较低的学习曲线 由Twitter开发，因此对社区有长期的长期信任。 Foundation 创建响应式设计 强大的电子邮件框架 极高的灵活性 在线网络研讨会培训支持。 易于定制。 提供了完整的模块化工具集，可让您解决几乎所有的界面任务 UI组件及更多：先进的成像系统，定价表组件，表单验证，垂直时间轴布局，RTL支持等等。 Bulma 所有CSS类名称均按逻辑命名，因此易于学习和记住语法。 纯CSS，无JavaScript 大社区 模块化：使用Saas构建，您可以通过仅导入所需的必要功能来设计界面。 大量组件，例如垂直对齐解决方案，布局以及媒体对象 Pure 移动友好 完全基于CSS，因此很容易学习。 它提供5点，2点，24点等的变化。因此，在创建网格和列系统时可以更加灵活地使用它。 Semantic UI 友好的类名：它使用人类友好的HTML，因此可以使用自然语言进行编码。 与Bootstrap 4和其他框架相比更具吸引力的布局。 仅加载必要的组件，从而减少了下载时间和文件大小 广泛的组件 Tailwind CSS 易于定制 实用程序类 带有响应式选项 UI kit 极简主义 大量有用的UI组件集合。 与更少和更少兼容 包含JavaScript 对任何设备的适应性 Materialize CSS 材料设计 引导网格 大量的组件选择 轻松定制 与Sass兼容 Skeleton 移动友好 简单易学 Miligram 基于Flexbox网格 超级设计主题 以上是我对下列视频及文章的归纳和总结。10个前端开发人员必须知道的CSS框架","link":"/2020/05/02/Blog-about-learning-77/"},{"title":"Promise 从入门到实战","text":"JavaScript 编写异步代码 回调函数 事件监听 发布订阅，消息中心 Promise/A+ Generator async/await Thunk Promise 示例Promise 值具有穿透性，穿透一个没有用的 .then() 直接到达 一个有用的 .then() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889let p1 = new Promise((resolve,reject) =&gt; { resolve(1)})p1.then() .then(value =&gt; { console.log(value); return value + 1 }).then(value =&gt; { console.log(value); })// output: 1 2// 两者不等价let p2 = Promise.resolve(1);p2.then(v =&gt; { v + 1 }) .then(v =&gt; { console.log(v)});// output: 2let p3 = Promise.resolve(1);p3.then(v =&gt; v + 1);p3.then(v =&gt; console.log(v));// output: 1let p4 = Promise.resolve(1);p4.then(v =&gt; { return new Promise((resolve,reject) =&gt; { setTimeout(() =&gt; resolve(2)) })}).then(v =&gt; console.log(v));// output: 2let p1 = new Promise((resolve , reject) =&gt; { reject(new Error ('some wrong'))})let p2 = p1.then( value =&gt; { console.log(value) }, reason =&gt; { console.log(reason.message) })// output: something wrongp2.then(()=&gt;{ throw new Error('something wrong 1')}).catch(reason =&gt; { console.log(reason.message)})// output: something wrong 1Promise.reject(new Error('error'))) .catch(reason =&gt; { console.log(reason.message); return `${reason.message} occured` }).then(v =&gt; console.log(v));// output: error error occured function sleep(duration){ return new Promise((resolve,reject) =&gt;{ setTimeout(() =&gt; {resolve(),duration}) })}async function run(){ const start = Date.now(); await sleep(1000); await sleep(2000); await sleep(3000); console.log(Date.now() - start)}run()// ==== 以下是 promise 的书写方法 === //function run1(){ const start = Date.now(); return Promise.resolve() .then(function() { return sleep(1000)}) .then(function() { return sleep(2000)}) .then(function() { return sleep(3000)}) .then(function() { console.log(Date.now() - start)})}run1(); 实现 Promise 需要注意 符合 Promise/A+ 标准 不暴露过多的函数和变量 Promise 状态只能修改一次 then() 和 catch 需要异步执行 then 能够实现链式调用 then 返回新的 Promise then 值能够穿透 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154// Promise 状态有 3 个 const PENDING = 0;const FULFILLED = 1;const REJECTED = 2;class Promise { constructor(fn){ // 初始状态 this._state = PENDING; this._data = null; this._onFulfilledCallbacks = []; this._onRejectedCallbakcs = []; run(this,fn); } static deferred (){ const dfd = {} dfd.promise = new promise ((resonlve,reject) =&gt; { dfd.resolve = resolve; dfd.reject = reject; }) return dfd; } then(onFulfilled, onRejected){ if(typeof onFulfilled !== 'function'){ onFulfilled = function(data){ return data } } if(typeof onRejected !== 'function'){ onRejected = function(reason){ throw reason } } let promise2; if(this._state === FULFILLED){ promise2 = new Promise((resolve,reject ) =&gt;{ setTimeout(()=&gt;{ try{ const x = onFulfilled(this._data) resolvePromise(promise2,x,resolve,reject) }catch(e){ reject(e); } }) }) }else if(this._state === REJECTED){ promise2 = new Promise((resolve,reject ) =&gt;{ setTimeout(()=&gt;{ try{ const x = onRejected(this._data) resolvePromise(promise2,x,resolve,reject) }catch(e){ reject(e); } }) }) }else if(this._state === PENDING){ promise2 = new Promise((resolve,reject)=&gt;{ this._onFulfilledCallbacks.push(data =&gt; { try{ const x = onFulfilled(data) resolvePromise(promise2,x,resolve,reject) }catch(e){ reject(e) } }) this._onRejectedCallbakcs.push(reason =&gt;{ try{ const x = onRejected (reason) resolvePromise(promise2,x,resolve,reject) }catch(e){ reject(e) } }) }) } } return promise2}catch(onRejected){ return this.then(undefined,onRejected)}function resolvePromise (promise2,x,resolve,reject){ if(x instanceof Promise){ return x.then(resolve,reject); }else{ resolve(x) }}function run (promise,fn){ try{ fn( data =&gt; { // do resolve resolve(promise,data) }, reason =&gt; { // do reject reject(promise,reason) } ) }catch(e){ // reject reject(promise,e) }}function resolve(promise,data) { // 处理值是 Promise 的情况 if(data instanceof Promise){ return data.then( d =&gt; { resolve (promise,d)}, r =&gt; { reject (promise,r)} ) } if(promise._state !== PENDING){ callback(data) } setTimeout(()=&gt;{ promise._state = FULFILLED; promise._data = data; for(let callback of promise._onFulfilledCallbacks) { callback(data) } })}function reject(promise,reason) { if(promise._state !== PENDING){ return } setTimeout(()=&gt;{ promise_state = REJECTED promise_data = reason for (let callback of promise__onRejectedCallbakcs){ callback(reason ) } })}module.exports = Promise; 校验 是否符合 promise 规范 promises-aplus-tests Promise 是什么按照用途来解释 主要用于异步计算。 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。 可以在对象之间传递和操作 Promise，帮助我们处理队列。 为什么会有 PromiseJavaScript 包含大量异步操作 JavaScript 为检查表单而生。创造它的首要目标是操作 DOM。所以，JavaScript 的操作大多是异步的。是 UI 语言造成界面冻结是大忌 为什么异步操作可以避免界面冻结同步问题：按顺序执行，按顺序完成。 异步：完成顺序和执行顺序无关。 异步操作的常见语法事件监听与响应： 12345678 document.getElementById(&quot;start&quot;).addEventListener(&quot;click&quot;, start, false); function start() { // 响应事件，进行相应的操作 }// jQuery 用 '.on()' 也是事件监听 $(&quot;#start&quot;).on(&quot;click&quot;, start); 异步操作的常见语法 12345678910$.ajax(&quot;http://baidu.com&quot;, { success: function (res) { // 这里就是回到函数了 },});// 或者在页面加载完毕后回调$(function () { // 这里也是回调函数}); 浏览器中的 JavaScript 异步操作以事件为主 回调主要出现在 Ajax 和 File API Node.js 的出现对异步的依赖进一步加剧了 无阻赛高并发，是 Node.js 的招牌。 异步操作是其保障。 大量操作依赖回调函数。 异步回调的问题 嵌套层次很深，难以维护 无法正常使用 return 和 throw 无法正常检索堆栈信息 多个回调之间难以建立联系 Promise 详解1234567891011121314151617new Promise( /* 执行器 executor */ function (resolve, reject) { // 一段耗时很长的异步操作 resolve(); // 数据处理完成 reject(); // 数据处理出 错 }).then( function A() { // 成功，下一步 }, function B() { // 失败，做相应处理 }); Promise 是一个代理对象，它和原先要进行的操作并无关系。它通过引入一个回调，避免更多的回调。 Promise 有 3 个状态pending [待定] 初始状态fulfilled [实现] 操作成功reject [被否定] 操作失败 Promise 状态发生改变，就会触发 .then() 里的响应函数处理后续步骤。Promise 状态一经改变，不会再变。 范例 1234567new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(&quot;hello&quot;); }, 2000);}).then((value) =&gt; { console.log(value + &quot;world&quot;);}); 两步执行范例123456789101112131415// 两步执行范例new Promise( resolve =&gt;{ setTimeout(()=&gt;{ resolve('hello'); },2000);}).then( value =&gt; { console.log(value); return new Promise( resolve =&gt;{ setTimeout(() =&gt; { resolve('world'); },2000); });}).then( value =&gt;{ console.log( value + 'world');}) 对已完成的 promise 执行12345678910111213// 对已完成的 promise 执行let promise = new Promise(resolve =&gt;{ setTimeout(() =&gt; { console.log('the promise fulfilled'); resolve('hello,world'); },1000)})setTimeout(()=&gt;{ promise.then( value =&gt;{ console.log(value); })},3000) then 里不返回 promise1234567891011121314151617181920// then 里不返回 promisenew Promise( resolve =&gt;{ setTimeout(() =&gt;{ resolve('hello'); },2000);}).then(value =&gt;{ console.log(value); console.log('everyone'); (function (){ return new Promise(resolve =&gt; { setTimeout(()=&gt;{ console.log('Mr.Laurence'); resolve(' Merry Xmas '); },2000) }); }()); return false;}).then( value =&gt;{ console.log(value + ' world');}) .then() .then() 接受两个函数作为参数，分别代表 fulfilled 和 rejected .then() 返回一个新的 Promise 实例，所以它可以链式调用 当前面的 Promise 状态改变时，.then() 根据其最终状态，选择特定的状态响应函数执行 状态响应函数可以返回新的 Promise，或其他值 如果返回新的 Promise，那么下一级 .then() 会在新 Promise 状态改变之后执行。 如果返回其他任何值，则会立刻执行下一级 .then() .then()里有 .then()的情况 因为 .then() 返回的还是 Promise 实例。 会等里面的 .then() 执行完，再执行外面的。 1234567891011121314151617181920212223console.log('start')new Promise( resolve =&gt;{ console.log('Step 1'); setTimeout(() =&gt;{ resolve('1000'); },1000); }).then(value =&gt;{ return new Promise( resolve =&gt;{ console.log('Step 1-1'); setTimeout(()=&gt;{ resolve(110); },1000) }).then( value =&gt; { console.log('Step 1-2'); return value; }).then(value =&gt; { console.log('Step 1-3'); return value; }) }).then( value =&gt;{ console.log(value); console.log('Step 2'); }) 123456789101112131415161718192021222324// 展开console.log('start')new Promise( resolve =&gt;{ console.log('Step 1'); setTimeout(() =&gt;{ resolve('1000'); },1000); }).then(value =&gt;{ return new Promise( resolve =&gt;{ console.log('Step 1-1'); setTimeout(()=&gt;{ resolve(110); },1000) }) }).then( value =&gt; { console.log('Step 1-2'); return value; }).then(value =&gt; { console.log('Step 1-3'); return value; }).then( value =&gt;{ console.log(value); console.log('Step 2'); }) 下面 Promise 的区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566doSomething().then(function(){ return doSomethingElse()});// doSomething().then(function(){// return doSomethingElse();// }).then(finalHandler);// 答案// doSomething// |-----------|// doSomethingElse(undefined)// |------------|// finalHandler(resultOfDoSomethingElse)// |------------|doSomething().then(function(){ doSomethingElse()});// doSomething().then(function(){// doSomethingElse();// }).then(finalHandler);// 答案// doSomething// |-----------|// doSomethingElse(undefined)// |------------|// finalHandler(resultOfDoSomethingElse)// |------------|doSomething().then( doSomethingElse());// doSomething().then(// doSomethingElse();// ).then(finalHandler);// 答案// doSomething// |-----------|// doSomethingElse(undefined)// |----------------------------|// finalHandler(resultOfDoSomethingElse)// |------------|doSomething().then( return doSomethingElse);// doSomething().then(// doSomethingElse;// ).then(finalHandler);// 答案// doSomething// |-----------|// doSomethingElse(resultOfDosomething)// |------------|// finalHandler(resultOfDoSomethingElse)// |------------| 错误处理Promise 会自动捕获内部异常，并交给 rejected 响应函数处理。错误处理两种做法： reject(‘错误信息’).then(null,message =&gt;{}) throw new Error(‘错误信息’).catch( message =&gt; {}) 推荐第二种，更加清晰好读，并且可以捕获前面的错误。 123456789new Promise( resolve =&gt;{ setTimeout(()=&gt;{ throw new Error('bye'); },2000);}).then( value =&gt;{ console.log(value + 'world');}).catch( error =&gt;{ console.log( 'Error:',error.message )}) 123456789new Promise( (resolve,reject) =&gt;{ setTimeout(()=&gt;{ reject('bye'); },2000);}).then( value =&gt;{ console.log(value + 'world');},value =&gt;{ console.log('Error',value);}) .catch() + .then()1234567891011121314151617new Promise(resolve =&gt;{ setTimeout(()=&gt;{ resolve(); },1000)}).then(()=&gt;{ console.log('start'); throw new Error('test error');}).catch( err =&gt; { console.log('I catch ',err); // throw new Error('another error');}).then(()=&gt;{ console.log('arrive here');}).then(()=&gt;{ console.log('...and here');}).catch( err =&gt;{ console.log('No,I catch',err);}) 注意： 强烈建议在所有队列最后都加上 .catch()，以避免漏掉错误处理造成意想不到的问题。 123456doSomething() .doAnotherThing() .doMoreThing() .catch( err =&gt;{ console.log(err); }) Promise 常用函数Promise.all()批量执行 Promise.all([p1,p2,p3,…]) 用于将多个 Promise 实例，包装成一个新的 Promise 实例 返回的实例就是普通 Promise 接收一个数组作为参数。 数组里可以是 Promise 对象，也可以是别的值，只有 Promise 会等待状态改变。 当所有子 Promise 都完成，该 Promise 完成，返回值是全部值的数组 有任何一个失败，该 Promise 失败，返回值是第一个失败的子 Promise 的结果。 12345678910111213141516171819202122232425262728293031323334353637383940Promise.all([1,2,3]).then( all =&gt; { console.log('1: ',all); return Promise.all([function(){ console.log('ooxx'); },'xxoo',false]);}).then(all =&gt;{ console.log('2: ',all); let p1 = new Promise( resolve =&gt;{ setTimeout(()=&gt;{ resolve('I\\'m P1'); },1500) }) let p2 = new Promise( resolve =&gt;{ setTimeout(()=&gt;{ resolve('I\\'m P2'); },1450) }) return Promise.all([p1,p2]);}).then( all =&gt;{ console.log('3: ',all); let p1 = new Promise( resolve =&gt;{ setTimeout(() =&gt; { resolve('I\\'m P1'); },1500) }) let p2 = new Promise( (resolve,reject) =&gt;{ setTimeout(() =&gt; { reject('I\\'m P2'); },1000) }) let p3 = new Promise( (resolve,reject) =&gt;{ setTimeout(() =&gt; { reject('I\\'m P3'); },3000) })}).then( all =&gt;{ console.log('all',all);}).catch(err =&gt;{ console.log(err);}) Promise.add() 和 .map() 连用 123456789101112131415161718192021222324252627282930const fs = require('fs');const path = require('path');const FileSystem = require('./FileSystem');function findLargest(dir) { return FileSystem.readDir(dir, 'utf-8').then( files =&gt; { return Promise.all( files.map( file =&gt; { return new Promise (resolve =&gt; { fs.stat(path.join(dir, file), (err, stat) =&gt; { if (err) throw err; if (stat.isDirectory()) { return resolve({ size: 0 }); } stat.file = file; resolve(stat); }); }); })); }).then( stats =&gt; { let biggest = stats.reduce( (memo, stat) =&gt; { if(memo.size &lt; stat.size) { return stat; } return memo; }); return biggest.file; }) } 实现队列使用 .forEach() 1234567891011121314function queue(things){ let promise = Promise.resolve(); things.forEach( thing =&gt;{ promise = promise.then(()=&gt;{ return new Promise( resolve =&gt;{ doThing(thing,()=&gt;{ resolve(); }); }) }) }) return promise;}queue('lots','of','things',...) 常见错误： 没有把 .then()产生的新 Promise 实例赋给 promise，没有生成队列。 使用 .reduce() 123456789101112function queue(things){ return things.reduce((promise,thing) =&gt; { return promise.then(() =&gt; { return new Promise( resolve =&gt; { doThing(thing,()=&gt;{ resolve(); }); }); }); },Promise.resolve());}queue('lots','of','things',...) 常见错误： Promise 实例创建之后，会立刻运行执行器代码，所以这个也无法达成队列的效果。 半成品爬虫12345678910111213141516171819let url = ['http://blog.meathill.com/'];function fetchAll(urls) { return urls.reduce((promise, url) =&gt; { return promise.then( () =&gt; { return fetch(url); }); }, Promise.resolve());}function fetch(url) { return spider.fetch(url) .then( content =&gt; { return saveOrOther(content); }) .then( content =&gt; { let links = spider.findLinks(content); return fetchAll(links); });}fetchAll(url); Promise.resolve()返回一个 fulfilled 的 Promise 实例，或原始 Promise 实例。 参数为空，返回一个状态为 fulfilled 的 Promise 实例。 参数是一个跟 Promise 无关的值，同上，不过 fulfilled 响应函数会得到这个参数 参数为 Promise 实例，则返回该实例，不做任何修改 参数为 thenable，立刻执行它的 .then()。 123456789101112131415161718Promise.resolve().then( (value) =&gt; { console.log('Step 1', value); return Promise.resolve('Hello');}).then( value =&gt;{ console.log(value,'World'); return Promise.resolve(new Promise( resolve =&gt; { setTimeout(()=&gt;{ resolve('Good'); },2000); }));}).then( value =&gt; { console.log(value, 'evening'); return Promise.resolve({ then(){ console.log(', everyone'); } })}) Promise.reject()返回一个 rejected 的 Promise 实例。 Promise.reject() 不认 thenable 123456789101112131415let promise = Promise.reject('something wrong');promise.then( () =&gt; { console.log('it\\'s ok'); }).catch( () =&gt; { console.log('no, it\\'s not ok'); return Promise.reject({ then() { console.log('it will be ok'); }, catch() { console.log('not yet'); } }); }); Promise.race()类似 Promise.all()，区别在于它有任意一个完成就算完成。 1234567891011121314151617let p1 = new Promise(resolve =&gt; { // 这是一个长时间的调用 setTimeout(() =&gt; { resolve('I\\'m P1'); }, 10000);});let p2 = new Promise(resolve =&gt; { // 这是个稍短的调用 setTimeout(() =&gt; { resolve('I\\'m P2'); }, 2000)});Promise.race([p1, p2]).then(value =&gt; { console.log(value);}); 常见用法： 把异步操作和定时器放在一起 如果定时器先触发，就认为超时，告知用户 实际开发的 Promise异步回调包装成 Promise优点： 可读性更好 返回的结果可以加入任何 Promise 队列 12345678910111213141516171819202122232425262728293031const fs = require('fs');module.exports = { readDir: function (path, options) { return new Promise( resolve =&gt; { fs.readdir(path, options, (err, files) =&gt; { if (err) { throw err; } resolve(files); }); }); }, readFile: function (path, options) { return new Promise( resolve =&gt; { fs.readFile(path, options, (err, content) =&gt; { if (err) { throw err; } resolve(content); }); }); }};// 使用const fs = require('./FileSystem');fs.readFile('../README.md','utf-8').then(content =&gt;{ console.log(content);}) 把任意异步操作包装成 Promise123456789101112131415161718// 弹出窗体let confirm = popupManager.confirm('您确定么？');confirm.promise.then(() =&gt; { // do confirm staff}).catch(() =&gt; { // do cancel staff});// 窗体的构造函数class Confirm { constructor() { this.promise = new Promise( (resolve, reject) =&gt; { this.confirmButton.onClick = resolve; this.cancelButton.onClick = reject; }) }} 两步执行12345678910111213// 对已完成的 promise 执行let promise = new Promise(resolve =&gt;{ setTimeout(() =&gt; { console.log('the promise fulfilled'); resolve('hello,world'); },1000)})setTimeout(()=&gt;{ promise.then( value =&gt;{ console.log(value); })},3000) 实际开发会对请求进行 promise 化，两种情况 返回的数据直接更改值 12345678910getlist(data){ this.api.getlist(data).then(res=&gt;{ this.list = res.data.data; })}// 下拉刷新pullDown(){ this.getlist(data);} 返回数据传递给下个调用的函数 123456789101112getlist(data){ return this.api.getlist(data).then(res=&gt;{ return Promise.resolve(res.data.data); })}// 模糊搜索querySearchAsync(){ this.getlist(data).then((value)=&gt;{ this.searchlist = value; })} jQueryjQuery 已经实现了 Promise。1.5 版开始尝试， 3.0版完成的 Promise。 参考 jQuery 的 ajax 实现。 12345$.ajax(url,{ dataType: 'json'}).then(json =&gt;{ // 进行操作}) IE如果需要在 IE 中使用 Promise，有两个选择： 只想实现异步队列：jQuery.defered 需要兼容所有平台：bluebirdPromise polyfill Fetch APIFetch API 是 XMLHttpRequest 的现代化替代方案。可以在 service workers、Cache API 使用。 更强大，更友好。 直接返回一个 Promise 实例。 response 是一个二进制数据流，需要调用 json() 方法可以转换成 json 数据 1234567fetch('some.json').then( res =&gt;{ return res.json()}).then( json =&gt;{ // do something with the json}).catch( err =&gt;{ console.log(err);}) async/awaitES2017 新增运算符，新的语言元素 赋予 JavaScript 以顺序手法编写异步脚本的能力 既保留异步运算的无阻塞特性，还继续使用同步写法。 还能正常使用 return/try/catch。 async/await 仍然需要 Promise！ 希望全面了解，请参考 async/await 入门。 1234async function f1(){ const result = await resolveAfter2Seconds(); console.log(result);} 协程 协程A开始执行。 协程A执行到一半，进入暂停，执行权转移到协程B。 （一段时间后）协程B交还执行权。 协程A恢复执行。 Thunk参数求值 传名调用，在执行时求值12345678910111213function f(m){ return m * 2;}f(x + 5);// 等同于var thunk = function () { return x + 5;};function f(thunk){ return thunk() * 2;} 在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。 123456789101112// 正常版本的readFile（多参数版本）fs.readFile(fileName, callback);// Thunk版本的readFile（单参数版本）var readFileThunk = Thunk(fileName);readFileThunk(callback);var Thunk = function (fileName){ return function (callback){ return fs.readFile(fileName, callback); };}; 任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。下面是一个简单的 Thunk 函数转换器。 12345678910111213var Thunk = function(fn){ return function (){ var args = Array.prototype.slice.call(arguments); return function (callback){ args.push(callback); return fn.apply(this, args); } };};// 使用上面的转换器，生成 fs.readFile 的 Thunk 函数。var readFileThunk = Thunk(fs.readFile);readFileThunk(fileA)(callback); Thunkify 模块生产环境的转换器，建议使用 Thunkify 模块 Thunk 函数的自动流程管理控制执行权 12345678910111213141516171819202122232425262728293031323334var fs = require('fs');var thunkify = require('thunkify');var readFile = thunkify(fs.readFile);var gen = function* (){ var r1 = yield readFile('/etc/fstab'); console.log(r1.toString()); var r2 = yield readFile('/etc/shells'); console.log(r2.toString());};var g = gen();var r1 = g.next();r1.value(function(err, data){ if (err) throw err; var r2 = g.next(data); r2.value(function(err, data){ if (err) throw err; g.next(data); });});function run(fn) { var gen = fn(); function next(err, data) { var result = gen.next(data); if (result.done) return; result.value(next); } next();}run(gen); GeneratorGenerator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 123456789101112131415function* gen(x){ // * 号区别try { var y = yield x + 2; // yield 暂停} catch (e){ console.log(e);} return y;}var g = gen(1); // 返回的是指针对象g.next() // { value: 3, done: false } value 属性是 yield 语句后面表达式的值g.next() // { value: undefined, done: true } Generator 是否执行完毕// 有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。g.next(2) // { value: 2, done: true }g.throw（'出错了'） // 捕获错误并抛出 相关资料Promise 入门√Generator 函数的含义与用法√Thunk 函数的含义和用法√fetch polyfill兼容库彻底搞懂JS事件中的循环机制 Event Loop巨大的提升！重启的async函数和promises“译” async/await的基础用法 Promise 初入门径Promise 探讨jQuery的deferred对象详解Promises/A+ 规范 相关代码 –开源es6-promise","link":"/2020/04/18/Blog-about-learning-71/"},{"title":"大前端试听课","text":"大前端时代20~40K 前端职位描述 与 UI 设计、产品经理、后端研发紧密合作，高效高质地完成页面的实现工作；熟悉模块化、前端编译和构建工具，如 Yarn、Webpack 等；对持续集成/持续交付有相关经验者优先；协助 PM 完成完善产品需求，提供完善的技术实现方案；理解 angularjs/vue 中任一框架背后的工作原理；对前端工程化有一定的认识，熟练使用构建工具 Webpack/Gulp；负责与后端进行接口的对接、联调，实现 Web 前端与后端服务器之间的数据上传与获取；至少精通 Angluar、React、Vue 等其中的一种，熟悉 Webpack 等打包工具，精通 nodejs 尤佳；了解常用数据库操作（如：Oracle、Mysql、Mongodb 等），具备 3 年以上的 Apache 或 Nginx 使用经验。 企业需要中高级前端大前端时代新需求 扎实的前端业务开发能力，交互理解 多角色沟通协调能力 多端、跨端的开发能力，新技术的学习能力 课程内容 开发环境搭建 工作中的痛点问题 DevOps 内容介绍 JS 框架选型 前端工程化简介 真机调试技巧 缺陷控制 什么是 Mock 数据 登录鉴权 课程重点知识 前端开发环境搭建 六大常见场景教学 自动化流程、多端跨端应用 软件项目开发 项目生命周期 项目定义阶段 没有明确项目的目标、资源、工期 没有进行合理的评估与预算 客户沟通不及时、不充分、不具体 项目需求分析阶段 详细的需求分析，项目预算 资源计划与合理的分工 客户沟通不及时、不充分、不具体 项目开发阶段 项目收尾 没有规范的收尾流程，草草结束 没有对文档进行归档，对项目进行总结，形成组织资产 资源回收不及时，造成资源浪费 解决方案 对组织人员培训，转变思维向自动化/规范化转型 配合效率工具（自动化）对流程进行简化/标准化 全员参与并实际 DevOps 内容介绍 开发环境搭建 本地环境Node.js(npm/cnpm/yarn) + nvm (Node.js 版本管理)IDE(Webstorm/Vscode/Atom)Vue-CLi安装命令：npm install -g @vue/cli快速原型开发：npm install -g @vue/cli-service-global Linux 测试环境虚拟机自建环境（Parallels/Vmware/Hyperv）购买云服务（&gt;1C + 2G）安装 Docker 安装 Docker 服务 12curl -fsSL https://get.docker.com -o get-docker.shsh get-docker.sh 免密码链接 Linux 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 查看操作系统lsb_release -a// 查看 dockerdocker --version// 下载 docker-composesudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose// 给执行权限sudo chmod +x /usr/local/bin/docker-compose// 查看 docker 版本docker-compose -v// 下载 mongo4docker pull mongo:4// 如果下载失败配置镜像源// /etc/docker/daemon.json// 添加// {// &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]// }// 编辑 /etc/docker/daemon.jsonvi /etc/docker/daemon.jsoni// 黏贴// {// &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]// }ESC 键推出// 保存推出:wq// 重启 docker 服务service docker restart// 查看下载镜像docker images// 运行 mongodocker run --name some-mongo -d mongo:4 -p 10050:27017// 查看当前 docker 运行的服务docker ps// 关闭防火墙// Ubuntu: service ufw stop// Centos: service firewalld stop// 将 10050 添加到放行中去// 对于 Ubuntu 使用// Ubuntu：ufw allow Port端口号firewall-cmd --zone=public --add-port=10050/tcp --permanent// 查看是否成功firewall-cmd --reloadfirewall-cmd --state 远程链接管理 mongo 的工具Robo 3T Win10 安装虚拟机、安装 Linux 系统 、安装 docker 的一条龙上手指南准备工作Oracle VM VirtualBoxUbuntu 镜像Centos 镜像 虚拟机的安装和使用 创建运行环境，并加载 Linux 镜像： 首先点击新建，填写对应的内容： 选择内存大小，对性能有需求的就调整的大一点，但是也需要根据自己电脑的配置来，如果电脑配置不高可能会非常卡： 选择虚拟机的硬盘，硬盘类型选择默认，大小选择固定（使用 docker 或配置网络环境建议 20G 以上）： 点击创建之后它就开始去创建空间了，等待它完成。 可以看到主面板上有一个创建好的虚拟机： 选择这个虚拟机，点击右边的启动按钮，然后我们进入 Linux 的安装。 虚拟机上安装 Linux 系统（Ubuntu 镜像）第一次启动虚拟机之后会弹出一个黑框框，然后告诉你没有盘，这时候选择旁边文件夹的图标，选择下载好的 Linux 镜像。 键盘选择的是默认，然后到下一个画面，问你要安装完整版还是最小版，然后还问你是不是要在安装的时候更新，选择最小版和取消安装时更新。因为，主要是用 Linux 环境，并不是真的使用，所以没必要安装一些不用的 office 套件之类的软件，取消安装时更新是因为安装的时候会连接国外的服务器去更新，速度巨慢，后面会介绍换国内源的方式更新。 下一步后，选择默认的”清除整个磁盘安装 Ubuntu”。然后”现在安装”，再点”继续”。 接下来还有一些配置。时区默认就行，用户名密码的地方建议选择自动登录，密码可以设置的短一点，反正是在本地环境运行的。 再继续就开始安装了，安装需要一点时间，看你机器的配置和网络情况，这期间你可以干点其他的事。安装的时候，下方进度条前方有个小三角，点击后会展开详细信息。详细信息并不重要，重要的是后会出现一个 skip 的按钮，如果这个按钮处于能点的状态那就点了，让安装快一些： 安装完毕会让你重启，没得选了，只能重启。 之后可能会提示你”移除安装媒体，然后按回车”，我们不管什么安装媒介，直接按回车就行。等待重启，就自动进入系统了。第一次进系统会蹦出一堆没什么用的介绍，还有发送系统信息之类的（我选择不发送），总之一直继续就好。 在安装完系统之后更新。更新系统不是必须的，但是推荐这么做。首先更改系统更新的源到国内，这样做比安装的时候更新快的多，具体步骤看下面的图片： 把下载自中的源换成国内大厂的（阿里、华为之类的），选择”其他站点”就会出来对应的列表，（选择的时候可能会让你输入密码，输入你创建账户时候的密码。关闭的时候可能会蹦一个提示，点”重新载入”），反正最终我们要换成想要换的源就行。这个比较重要，因为之后我们在 Linux 中下载软件什么的也会快很多。 然后再自动检查更新，点完就自动检查更新了，然后会弹出更新的包，因为我们换了国内的源，比安装的时候更新快很多（可能会让输入密码，之后所有让输入密码的地方都是输入注册时候填的密码，不再赘述），更新完之后重启： 如果你愿意长期使用这个虚拟机中的 Linux 系统，推荐在虚拟机菜单中找到 设备 -&gt; 安装增强功能，安装完重启，这样你在电脑上看到的 Linux 系统分辨率就是正常的了（这步不操作也行，反正我们后面也基本是本地命令行连接虚拟机中的系统去操作），同样的在这个菜单下有一个”共享粘贴板”，设置成双向，这样 window 中的东西可以复制粘贴到虚拟机中： 接下来的操作是让我们可以在 win10 中用命令行窗口连接虚拟机，因为我认为既然是模拟服务器环境，我们操作的时候最好也模拟这样的环境，在本地系统中用命令行来连接这个虚拟机。当然如果你觉得这样做多此一举不做也行，Linux 安装的部分就结束了，可以直接跳到下一节中。如果你觉得这样操作有必要，就往下看。 虚拟机中开一个命令行窗口（Ctrl+Alt+T），为了方便操作，我们先切换到 root 权限： 1sudo su - 输入如下命令： 1ssh localhost 如果这时候报错了，说明 ssh 没开，再输入（没有 root 权限自行加 sudo）： 1apt-get install openssh-server 然后会进行安装（需要输 yes 的地方输 yes，需要输密码的地方输密码），安装之后再试 ssh localhost，如果不报错，让输入确认或者密码之类的了，就 OK 了。 接下来的操作就是把虚拟机中的 22 端口开放出来。 设置 关掉 Linux 系统（不关也行，但保险起见最好先关闭），然后找到我们创建的虚拟机镜像，点击”设置”：然后选择 网络 -&gt; 网卡 1 -&gt; 连接方式选择”网络地址转换 NAT” -&gt; 高级 -&gt; 端口转发，在打开的窗口中，名称随便填，两个端口号填 22： 下面在 windows 中找到虚拟机安装的网卡，看看 ip 地址。路径：控制面板 -&gt; 网络和 Internet -&gt; 网络和共享中心 -&gt; 更改适配器配置 你不会看也没事，我直接告诉你，地址是 192.168.56.1，这个地址是默认的，记住这个地址。 然后我们就可以在本地开一个命令行窗口然后输入： 1ssh 你注册的用户名@192.168.56.1 第一次连接可能会让你确认是不是要连接，输入 yes，然后输入密码，就可以本地连接虚拟机的系统了： 安装 docker已经有一个 Linux 系统环境了，你可以用它来做练习或者学习使用 Linux。接下来的内容是关于怎么在这个系统中安装 docker，切换 docker 的下载为国内源，以及简单的使用。这里只是一些简单的介绍，如果想要更详细的上手指南，比如不同系统的安装以及更详细的操作，推荐这里： Docker — 从入门到实践 卸载旧版本没有安装过可以跳过，但是为了文章的完整性，贴在这里：（没有权限的自行加 sudo，要么像上文提到的切换到 root，下同） 1apt-get remove docker \\ docker-engine \\ docker.io 3.2 使用 APT 安装1234567# 更新apt-get update# 添加使用 HTTPS 传输的软件包以及 CA 证书。apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ software-properties-common# 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。(国内源，下同)curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 向 source.list 中添加 Docker 软件源add-apt-repository \\ &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 3.3 安装 Docker1apt-get install docker-ce 3.4 启动 Docker123456# 添加自启动systemctl enable docker# 启动dockersystemctl start docker# 测试docker启动是否成功 其实就是去下一个官方的提供的hello worlddocker run hello-world 运行完最后一行命令，之后显示出”Hello from Docker!This message shows that your installation appears to be working correctly…bulabulabula”，就说明 docker 安装成功并启动了，而且你还下载了一个测试的镜像并运行成功了。 3.5 切换 docker 下载镜像为国内的源因为 docker 下载镜像默认是国外，所以下载起来会非常慢，最好在之后操作之前，先把下载源改成国内的。在进行下个步骤之前，我强烈建议你给 Linux 安装个 vim。 1apt-get install vim 用 Linux 编辑器打开/etc/docker/daemon.json 文件，然后写入下面的内容，保存退出（注意，这必须是一个标准的 json）： 123{ &quot;registry-mirrors&quot;: [&quot;https://mirror.ccs.tencentyun.com&quot;,&quot;http://hub-mirror.c.163.com&quot;]} 说明一下：第一个是腾讯的源，第二个是网易的，速度都很快。不知道现在 docker-cn 是否恢复，如果没恢复写大厂的镜像源就可以了。写完保存之后重载配置然后重启 docker，如果上面配置写的不对，会报错。 1systemctl daemon-reload systemctl restart docker 重启后没有报错说明生效了。下载个 MySQL 试一下： 1docker run --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d -p 39000:3306 --restart=always mysql 解释一下上面的命令： -d 后台运行 –name 自定义容器名称 -p 指定端口，前面是映射端口，后面是容器运行端口 MySQL 启动时会要求输入密码，这里就是 123456 前面的-e 是设置环境变量 –restart 容器开机运行不出意外的话，运行后你会发现换国内源之后下载镜像的速度变快了（当然，到底快不快还是要看自己的网速）。 下面是一些简单的 docker 操作查看容器、删除容器以及删除镜像我们可以使用 docker ps -a 查看所有的容器（包括没有运行的）。应该会看到刚才我们下载的那个测试镜像”hello-world”还有”MySQL”。 看所有的容器 hello-world 这个镜像已经没用了我们删除它：如果要删除一个正在运行的镜像，需要用 docker stop 名称/id 让容器停止运行，然后再用 docker rm 名称/id 进行删除，这个 hello-world 并没有在运行，所以我们直接输入：docker rm d74199ead137 删除它。想要硬盘删除这个镜像，用 docker images 查看有哪些镜像，然后 docker rmi 镜像 id 就可以了（要删除镜像首先得删除容器，也就是上一步操作，否则会报错告诉你删不了）。 连接 MySQL然后我们用 Navicat 来连接一下这个镜像中的 MySQL（相当于远程连接服务器上的 MySQL）。现在命令行中进行如下操作： 1.进入容器： docker exec -it mysql bash 2.用刚才创建的密码登录 mysql：mysql -uroot -p123456 3.查看一下 root 等用户信息：select user,host,plugin from mysql.user;。如果发现 root 后面是’caching_sha2_password’，那么执行下面两条命令 1ALTER user 'root'@'%'IDENTIFIED WITH mysql_native_password BY '123456';FLUSH PRIVILEGES; 在 Navicat 中设置如下，密码填你刚才用 docker 运行 MySQL 时候设置的密码，我设置的是 123456： 不出意外的话，点击连接测试是连不上的。这个时候需要用上文提到的方法，在虚拟机中进行端口转发，把我们设置安装 MySQL 时设置的对外端口 39000 添加进去（图就不截了）。然后再连接，就可以连接上了： 其他的 docker 常用命令12345678910# 查看运行的镜像docker ps# 启动一个已经停止的容器docker start 名称/ID# 重启一个容器docker restart 名称/ID# 查看docker版本docker --version# 查看docker系统信息docker info 以上就是 win10 下安装虚拟机、虚拟机中安装 Linux 系统、Linux 系统中安装 docker 并安装 MySQL 容器外加 Navicat 连接测试的全部内容了。 Docker 入门之安装教程官方的介绍 Docker Engine is available for Linux (CentOS, Debian, Fedora, Oracle Linux, RHEL, SUSE, and Ubuntu) or Windows Server operating systems and is based on containerd - the open source container runtime project that Docker donated to the Cloud Native Computing Foundation (CNCF) in 2017. It is available as both a free community-supported engine and as a commercially-supported enterprise engine (Docker Engine-Enterprise) that also forms the foundation for an enterprise container platform. Mac OS 上的 Docker 安装方法方法一官方 dmg：Docker Descktop for Mac对系统的要求： Requires Apple Mac OS Sierra 10.12 or above. Download Docker Toolbox for previous OS versions.只要系统是 Mac OS Sierra 10.12 以上即可。下载完 Docker.dmg 安装包之后，双击即可以安装，可能需要系统管理员权限，输入密码即可。运行过后，小图标： 安装完之后，在终端工具中，使用 docker version 来查看 Docker 版本。 1docker version 设置中国区加速地址： 阿里云加速：Docker 镜像加速器 方法二 brew cask： 1234brew updatebrew cask install docker# 删除的方法, 还需要手动删除Docker.appbrew cask uninstall docker 上面的命令将会把 Docker 安装在 Applications 目录下。 Windows 上 Docker 安装官方下载地址：Docker Desktop for Windows 对系统的要求： Requires Microsoft Windows 10 Professional or Enterprise 64-bit. For previous versions get Docker Toolbox. 需要 Windows 10 专业版及企业的 64 位版本，在 Windows server 2016 以上亲测是可用的。Windows 8/7/Vista/Xp 之类的，就别想了，老实去装 Windows 10 或者虚拟机中去使用。 Linux 上 Docker 安装Centos 中 Docker 安装方法1、先删除旧的版本(如果没有可以跳过) 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2、安装必须的依赖 123$ sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 添加stable的 Docker-ce 的源： 123$ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 3、安装 docker-ce: 1$ sudo yum install docker-ce docker-ce-cli containerd.io 4、选择指定的安装版本(可选) 123456$ yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 我们来举个例子，比如我们要安装 3:18.09.1-3.el7 这个版本，使用如下命令结构： 1$ sudo yum install docker-ce- docker-ce-cli- containerd.io 命令说明：第一部分是 docker-ce，第二部分是版本号 18.09.1，看明白了吗？就是这样子： 1$ sudo yum install -y docker-ce-18.09.1 docker-ce-cli-18.09.1 5、启动服务并测试一下： 12345678910111213141516171819202122232425262728293031# 启动服务sudo systemctl start docker# 来一个Hello World吧sudo docker run hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-world1b930d010525: Pull completeDigest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ 如果看到上面的提示，说明 Docker 已经成功安装并运行了了。 6、关于升级&amp;删除：升级： 12345# 更新所有yum -y update# 更新指定yum -y update docker-ce docker-ce-cli containerd.io 删除： 1234sudo yum remove docker-ce# 删除文件系统sudo rm -rf /var/lib/docker Debian 中 Docker 的安装方法1、删除旧的版本(可跳过) 1$ sudo apt-get remove docker docker-engine docker.io containerd runc 2、安装依赖： 123456789101112131415161718$ sudo apt-get update$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg2 \\ software-properties-common# 添加GPG key$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -$ sudo apt-key fingerprint 0EBFCD88pub 4096R/0EBFCD88 2017-02-22 Key fingerprint = 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid Docker Release (CE deb)sub 4096R/F273FCD8 2017-02-22 3、使用 stable 安装源 x86_64 / amd64 armhf arm64 1234$ sudo add-apt-repository \\&quot;deb [arch=amd64] https://download.docker.com/linux/debian \\$(lsb_release -cs) \\stable&quot; 4、安装 docker-ce： 123$ sudo apt-get update$ sudo apt-get install docker-ce docker-ce-cli containerd.io 5、安装指定的版本（可选） 1234567$ apt-cache madison docker-ce docker-ce | 5:18.09.1~3-0~debian-stretch | https://download.docker.com/linux/debian stretch/stable amd64 Packages docker-ce | 5:18.09.0~3-0~debian-stretch | https://download.docker.com/linux/debian stretch/stable amd64 Packages docker-ce | 18.06.1~ce~3-0~debian | https://download.docker.com/linux/debian stretch/stable amd64 Packages docker-ce | 18.06.0~ce~3-0~debian | https://download.docker.com/linux/debian stretch/stable amd64 Packages ... 安装格式： 1$ sudo apt-get install docker-ce= docker-ce-cli= containerd.io 举例说明：比如要安装 5:18.09.13-0debian-stretch 版本的 docker 的话 1$ sudo apt-get install docker-ce=18.09.1 docker-ce-cli=18.09.1 containerd.io 6、启动服务并测试： 123456$ sudo service docker start# 查看Docker运行状态$ sudo service docker status$ sudo docker run hello-world Ubuntu 中 Docker 安装方法1、删除旧的版本(可跳过) 1$ sudo apt-get remove docker docker-engine docker.io containerd runc 2、安装依赖： 123456789101112131415161718$ sudo apt-get update$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common# 添加GPG key$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -$ sudo apt-key fingerprint 0EBFCD88pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid [ unknown] Docker Release (CE deb)sub rsa4096 2017-02-22 [S] 3、使用 stable 安装源： x86_64/amd64 armhf arm64 ppc64le (IBM Power) s390x (IBM Z) 1234$ sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 4、安装 docker-ce 123$ sudo apt-get update$ sudo apt-get install docker-ce docker-ce-cli containerd.io 5、安装指定的版本：(可选) 1234567$ apt-cache madison docker-ce docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 18.06.1~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages docker-ce | 18.06.0~ce~3-0~ubuntu | https://download.docker.com/linux/ubuntu xenial/stable amd64 Packages ... 安装格式： 1$ sudo apt-get install docker-ce= docker-ce-cli= containerd.io 举例说明：比如要安装 5:18.09.13-0ubuntu-xenial 版本的 docker 的话： 1$ sudo apt-get install docker-ce=18.09.1 docker-ce-cli=18.09.1 containerd.io 启动服务并测试： 123456$ sudo service docker start# 查看Docker运行状态$ sudo service docker status$ sudo docker run hello-world Docker-compose 集合命令Compose 工具是一个批量工具，用于运行与管理多个docker容器。 官方文档：Install Docker Compose 在 Mac/Windows 中，已经集成了 docker-compose 命令 在 WindowsServer 中先启动 PowerShell 1[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 然后运行如下命令： 1Invoke-WebRequest &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-Windows-x86_64.exe&quot; -UseBasicParsing -OutFile $Env:ProgramFiles\\Docker\\docker-compose.exe 然后测试一下：docker-compose –version Linux 中： 123456789# 下载docker-composesudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# 给予执行权限sudo chmod +x /usr/local/bin/docker-compose# 测试命令$ docker-compose --versiondocker-compose version 1.23.2, build 1110ad01 12$ sudo apt-get update$ sudo apt-get install docker-ce docker-ce-cli containerd.io UI 框架选型 判断使用场景（PC、移动 Web、小程序、响应式） 组件丰富、成熟的模板、方便集成 成熟的社区，成熟的生态 PC 端LayuiiViewAnt DesignElement 移动端Mint UICube UIVant JS 框架选型 根据团队技术能力选择框架，按需取用 了解框架背后的原理，并思考如何实现一个 JS 框架，应用场景（后台、性能要求、时间要求） 成熟的社区、成熟的生态，多读文档，求助社区，高效开发 Vue：方便集成、学习成本低React：Angular： todolist 前端工程化前端工程化是指将前端开发的流程规范化、标准化，包括开发流程、技术选项、代码规范、构建发布，用于提升前端工程师的开发效率和代码质量 为什么要前端工程化 复杂度高：前端项目的多功能、多页面、多状态、多系统 规模大：团队开发、多人协作、代码质量管理 要求高：页面性能优化（CDN/异步加载/请求合并），CSS 兼容、单页面应用、服务端渲染 怎么做 从业务着手简单的单页面应用，使用 gulp 打包 + 同步工具实现开发流程 从复杂度考虑jenkenis git/gitlab webpak React/Vue/Angluar 从已知向未知扩展不同的技术有不同的适应点，选择合适的才是最好的。 考虑前后端技术是否更好的融合前后端分离，接口安全性vue 或 react 是否适合制作静态页面PHP 是否更好的集合 最佳实践组件化/脚手架/工程 cli 工具Git flowwebpackJenkins + Docker webpack 核心gulp 入口输出loader插件模式 怎么学 webpack模式loader 倒序执行引用插件 脚手架工具ESlint 实现脚手架Commanderpromptyeoman 创建脚手架 CLI 脚手架工作原理什么是脚手架 脚手架是为了保证各施工过程顺利进行而搭设的工作平台。——百度百科 vue-cli 的官方解释 Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，Vue CLI 致力于将 Vue 生态中的工具基础标准化。它确保了各种构建工具能够基于智能的默认配置即可平稳衔接，这样你可以专注在撰写应用上，而不必花好几天去纠结配置的问题。与此同时，它也为每个工具提供了调整配置的灵活性，无需 eject。 简单来说，脚手架就是「为了减少重复性工作而做的工具」 通常我们使用 vue-cli 创建项目会如下图所示，用交互的方式，选择用户需要的功能，最后创建一个项目，那么它内部是怎么实现的呢？今天我们这篇文章就简单介绍一下 vue-cli 工具的核心原理，以及实现一个简单的 cli 工具。 基本组成通常来说，cli 工具都必须用到下面的一些插件。 commander作用：解析参数 inquirer作用：交互式命令作用 download-git-report作用：在官网上下载模板 chalk作用：在命令行增加色彩 metalsmith作用：读取文件，实现模板渲染 consoledate作用：统一的模板引擎（比如：对 ejs 的解析） 核心代码的实现下面，会通过代码的形式，一步一步的来做一个简单的CLI的项目。首先，我新建了一个项目，并且进行npm init的初始化工作。新建一个bin的目录，然后在该目录下新建www的文件。在package.json中，把 bin 指向 bin 目录下的www.js文件。如下图 bin/www.js 的文件内容 12#! /usr/bin/env nodeconsole.log(&quot;111&quot;); 这个时候，执行npm link就可以把package.js中配置的bin命令生效了。试一下： 利用 Commander 来解析用户的参数这里需要安装 Commander 的插件了。npm i commander`如何查看用户传递过来的参数呢？先对 bin/www.js 文件进行如下修改 1require(&quot;../src/main&quot;); 新建 src 目录，新建 main.js 和 constance.js 123456789101112// constance.jsconst { version } = require(&quot;../package.json&quot;);module.exports = { version,};// main.jsconst program = require(&quot;commander&quot;);console.log(process.argv);const { version } = require(&quot;./constants.js&quot;);program.version(version).parse(process.argv); 上述代码做了这几件事情： 从 package 里拿到当前版本 解析用户传递的参数 当我们运行toimooc –version的时候，会输出以下内容。 创建一个 create 的命令1234567891011121314// main.jsconst program = require(&quot;commander&quot;);const { version } = require(&quot;./constants.js&quot;);program .command(&quot;create&quot;) .alias(&quot;c&quot;) .description(&quot; create a project&quot;) .action(() =&gt; { console.log(&quot;done&quot;); });// 解析用户传递的参数program.version(version).parse(process.argv); 上述命令通过 command 创建了一个create的命令，别名是c. 操作的内容是打印done。当我们运行toimooc create的时候，会打印如下内容： 通常情况下，需要的命令一定不止create一个，这样的话，就需要对命令进行封装了。下面对该部分代码进行封装 123456789101112131415161718192021222324252627282930313233343536// main.js// 定义映射对象const mapActions = { create: { alias: &quot;c&quot;, description: &quot;create a project&quot;, examples: [&quot;toimooc-cli create &lt;project-name&gt;&quot;], }, config: { alias: &quot;c&quot;, description: &quot;config project variable&quot;, examples: [&quot;toimooc-cli config set &lt;k&gt; &lt;v&gt;&quot;, &quot;toimooc-cli config get &lt;k&gt;&quot;], }, &quot;*&quot;: { alias: &quot;c&quot;, description: &quot;command not found&quot;, examples: [], },};// 循环映射对象Reflect.ownKeys(mapActions).forEach((action) =&gt; { program .command(action) .alias(mapActions[action].alias) .description(mapActions[action].description) .action(() =&gt; { // console.log('done') if (action === &quot;*&quot;) { console.log(mapActions[action].description); } else { console.log(action); } });}); 为了代码的层次化结构更加清晰，action 里面的所有操作， 需要拆分到独立的 js 文件中，使每个函数文件独立完成自己需要完成的事情。新建 src/create.js 文件： 123module.exports = (projectName) =&gt; { console.log(&quot;create&quot;, projectName);}; 修改 Main.js 1234567891011121314Reflect.ownKeys(mapActions).forEach((action) =&gt; { program .command(action) .alias(mapActions[action].alias) .description(mapActions[action].description) .action(() =&gt; { // console.log('done') if (action === &quot;*&quot;) { console.log(mapActions[action].description); } else { require(path.resolve(__dirname, action))(...process.argv.slice(3)); } });}); 此时执行 create projectName 就会打印出我们需要的内容： 监听 help 事件通常用户会使用 help 来查看帮助命令，这个是如何实现的呢？ 12345678// 监听用户的help事件program.on(&quot;--help&quot;, () =&gt; { Reflect.ownKeys(mapActions).forEach((action) =&gt; { mapActions[action].examples.forEach((example) =&gt; { console.log(&quot; &quot; + example); }); });}); 从 GitHub 拉取代码github 官网提供了拉取代码的Api 接口通过这个地址可以获取我在 github 上面所有的项目https://api.github.com/users/haimingyue/repos](https://api.github.com/users/haimingyue/repos) user/**后面的haimingyue是我的github**的名称。可以替换成你个人的。 完善 create 文件代码create 的功能是创建项目，拉取所有的项目列表，让用户选择安装哪个项目。 123456789101112131415const axios = require(&quot;axios&quot;);// 获取项目列表const fetchRepoList = async () =&gt; { const { data } = await axios.get( &quot;https://api.github.com/users/haimingyue/repos&quot; ); return data;};module.exports = async (projectName) =&gt; { // console.log('create', projectName) let repos = await fetchRepoList(); repos = repos.map((item) =&gt; item.name); console.log(repos);}; 接下来需要用到 ora 和 Inquirer 插件。 ora 的作用是 Loading 效果 Inquirer 的作用是和用户进行交互式命令 123456789101112131415161718192021222324252627282930313233343536// 封装loading效果const waitFnloading = (fn, message) =&gt; async (...args) =&gt; { const spinner = ora(message); spinner.start(); const result = await fn(...args); spinner.succeed(); return result;};//根据github接口，获取项目的tag信息const fetchTagList = async () =&gt; { const { data } = await axios.get( &quot;https://api.github.com/repos/haimingyue/mmall-fe/tags&quot; ); return data;};// 使用Inquirer实现交互式命令module.exports = async (projectName) =&gt; { let repos = await waitFnloading(fetchRepoList, &quot;fetching template&quot;)(); repos = repos.map((item) =&gt; item.name); const { repo } = await Inquirer.prompt({ name: &quot;repo&quot;, type: &quot;list&quot;, message: &quot;please choise a template to create project&quot;, choices: repos, }); let tags = await waitFnloading(fetchTagList, &quot;fetching tags&quot;)(repo); const { tag } = await Inquirer.prompt({ name: &quot;tag&quot;, type: &quot;list&quot;, message: &quot;please choise a tag&quot;, choices: tags, }); tags = tags.map((item) =&gt; item.name); console.log(&quot;tags&quot;, tags);}; 使用 download-git-repo 下载这一步的主要目的是使用download-git-repo插件下载仓库的文件，并保存到本地的临时文件夹内。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// constants.js// 选择下载模板的目录const downloadDirectory = `${ process.env[process.platform === &quot;darwin&quot; ? &quot;HOME&quot; : &quot;USERPROFILE&quot;]}/.template`;module.exports = { downloadDirectory,};// create.jsconst { promisify } = require(&quot;util&quot;);let downloadGitRepo = require(&quot;download-git-repo&quot;);downloadGitRepo = promisify(downloadGitRepo);const downloadDirectory = require(&quot;./constants&quot;);// 封装拉取项目的代码const download = async (repo, tag) =&gt; { let api = `haimingyue/${repo}`; if (tag) { api += `#${tag}`; } const dest = `${downloadDirectory}/${repo}`; await downloadGitRepo(api, dest); return dest;};module.exports = async (projectName) =&gt; { let repos = await waitFnloading(fetchRepoList, &quot;fetching template&quot;)(); repos = repos.map((item) =&gt; item.name); const { repo } = await Inquirer.prompt({ name: &quot;repo&quot;, type: &quot;list&quot;, message: &quot;please choise a template to create project&quot;, choices: repos, }); let tags = await waitFnloading(fetchTagList, &quot;fetching tags&quot;)(repo); const { tag } = await Inquirer.prompt({ name: &quot;tag&quot;, type: &quot;list&quot;, message: &quot;please choise a tag&quot;, choices: tags, }); tags = tags.map((item) =&gt; item.name); const result = await download(repo, tag); console.log(&quot;tags&quot;, tags);}; 把下载好的文件赋值到当前文件夹 ncp Asynchronous recursive file &amp; directory copying下载复制文件夹是需要使用插件ncp的。 npm install ncp 12345678910const path = require('path');let ncp = require('ncp');ncp = promisify(ncp);...module.exports = async (projectName) =&gt; { ... // 其他代码 const result = await waitFnloading(download, 'do') (repo, tag) ncp(result, path.resolve(projectName))} 这里把临时文件复制到当前的文件夹。 到这里，CLI 工作原理的介绍就基本完成了。这里只是简单的实现了模板的下载过程，复杂的 cli 工具还需要处理文件是否存在，ejs 等模板引擎的解析等等。完成 CLI 的代码之后，发布到 npm 上面，就可以被用户使用了。 三类真机调试技能真机调试总结 Chrome + Android / Safari + iOS Fiddler / Charles Weinre,Spy-Debugger,vConsole Safari + iOS 手机和服务处于同一个网段、同一个局域网内，用手机连接电脑，通过手机的 Safari 访问服务和端口号 Windows 版 Safari 浏览器Apple 不再提供 Windows 版 Safari 浏览器更新。Windows 版 Safari 浏览器 5.1.7 是适用于 Windows 的最后一个版本，而且现已过时。发布日期： 2018 年 09 月 24 日 windows 可能只能装黑苹果了。 Chrome + Android手机打开开发者模式，数据线连接电脑，手机与电脑保持在同一网络下。 出现白板 查看电脑端的 Chrome 是否是最新的 升级手机浏览器达到最新版 添加谷歌的访问服务、开启虚拟专有网络 调试 Webpack 以上是我对下列视频及文章的归纳和总结。大前端试听课 相关连接docker-install 下载docker compose 下载docker hub 下载docker hub 下载 相关文章韦玮：解决 Ubuntu 的 root 账号无法登录 SSH 问题-Permission denied, please try again.印记中文多入口 webpack 配置配置yeomanCommander.jsprompt 相关工具Robo 3T 下载VMware 下载Oracle VM VirtualBox 下载","link":"/2020/04/18/Blog-about-learning-72/"},{"title":"Blog-about-learning-81","text":"Webpack最低配置手册和示例","link":"/2020/05/12/Blog-about-learning-81/"},{"title":"Egg.js 框架入门与实战","text":"Egg.js 框架介绍Egg.js 是基于 Node.js 和 Koa 的一个企业级应用开发框架，可以帮助团队降低开发成本和维护成本。 Egg.js 特性 提供基于 Egg 的定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于 Koa 开发性能优异 框架稳定，测试覆盖率高 渐进式开发 搭建 Egg.js12345mkdir egg-example &amp;&amp; cd egg-example// simple 模板npm init egg --type=simplenpm inpm run dev 目录介绍 app 核心目录、业务逻辑、数据库操作 config 针对插件配置 test 单元测试 以上是我对下列视频及文章的归纳和总结。Egg.js 框架入门与实战","link":"/2020/05/18/Blog-about-learning-82/"},{"title":"","text":"","link":"/2020/05/11/Blog-about-learning-80/"},{"title":"","text":"","link":"/2020/05/22/Blog-about-learning-84/"},{"title":"前端优化","text":"资源 资源压缩(去除无用代码、函数、资源压缩)(线上：极端压缩。debug模式：不压缩) 网路请求 减少网络请求(资源合并例如：图片采用：tpg、webp、雪碧图、base64。html合并、js合并、css合并)(首屏加载、根据相关性加载) 缓存(http cache、localstorage缓存、使用离线包)(高时效性页面：cgi、html合并。低时效性页面：缓存(离线包)) 相关资料多 “维” 优化——前端高并发策略的更深层思考完整攻略！让你的网页加载时间降低到 1s 内！解读新一代 Web 性能体验和质量指标","link":"/2020/05/24/Blog-about-learning-85/"},{"title":"axios 在 vue 中的应用","text":"AxiosAxios 是什么 Axios 是一个基于 promise 的 HTTP 库 可以用于浏览器和 node.js Axios 有哪些特性 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF Axios 浏览器支持 Axios 基础用法axios 请求方法：get、post、put、patch、delete get：获取数据 post：提交数据（表单提交 + 文件上传） put：更新数据（所有数据推送到后端） patch：更新数据（只将修改的数据推送到后端） delete：删除数据 get 请求123456789axios.get(&quot;/data.json&quot;, { params: { id: 12, } }).then((res) =&gt; { if(res.status== 200){ console.log(res.data); }}) .catch((err) =&gt; { console.log(err);}); 1234567891011axios({ method: &quot;get&quot;, url: &quot;/data.json&quot;, params: { id: 12, },}) .then((res) =&gt;{ if (res.status == 200){ console.log(res.data); } }) .catch((err) =&gt; { console.log(err); }); post 请求常用提交数据方式 application/json：json 格式 application/x-www-form-urlencoded multipart/form-data：表单提交 application/json1234567axios .post(&quot;/post&quot;,{ id: 12 }) .then((res) =&gt; { console.log(res); }) .catch((err) =&gt; { console.log(err); }); 1234567axios({ method: &quot;post&quot;, url: &quot;/post&quot;, data: { id: 12 }, }) .then((res) =&gt; { console.log(res); }) .catch((err) =&gt; { console.log(err); }); multipart/form-data1234567891011121314151617181920212223242526 let data = { id: 12, }; let formData = new FormData(); for (let key in data) { formData.append(key, data[key]); } axios .post(&quot;/post&quot;, formData) .then((res) =&gt;{ console.log(res); }) .catch((err) =&gt; { console.log(err); });import qs from 'qs' import request from '@/utils/request' //user api // 用户信息 export function getUserInfo(params) { return request({ url: '/user/userinfo', method: 'post', data: qs.stringify(params), hideloading: true // 隐藏 loading 组件 }) } put 请求1234axios.put('/put',{ id: 12 }) .then(res=&gt;{ console.log(res); }) patch 请求1234axios.patch('/patch',{ id: 12 }) .then(res=&gt;{ console.log(res); }) delete 请求123456axios .delete(&quot;/delete&quot;, { params: { id: 12 } }) .then((res) =&gt; { console.log(res); }).catch((err) =&gt; { console.log(err); }); 123456axios .delete(&quot;/delete&quot;, { data: { id: 12 } }) .then((res) =&gt; { console.log(res); }) .catch((err) =&gt; { console.log(err); }); 并发请求并发请求：同时进行多个请求，并统一处理返回值 12345axios.all([ axios.get('/data.json'), axios.get('/city.json') ]) .then( axios.spread((dataRes,cityRes)=&gt;{ console.log(dataRes,cityRes) }) ) Axios 进阶用法创建 axios 实例1234567let instance = axios.create({ baseURL: &quot;http://localhost:8080&quot;, timeout: 2000,});instance .get(&quot;/data.json&quot;, { params: { id: 12, }, }).then((res) =&gt; { console.log(res);}); 实例的配置配置12let instance = axios.create({ baseURL: &quot;http://localhost:8080&quot;, timeout: 2000,ur:'/data.json', method:'get', headers: { token:'' }, params: {}, data: { } }); 配置优先级：全局配置 &lt; 实例配置 &lt; 请求配置 全局配置1axios.defaults.timeout = 1000; axios.defaults.baseURL = 'http://localhost:8080' 实例配置1let instance = axios.create(); instance.defaults.timeout = 3000; 请求配置1234instance .get(&quot;/data.json&quot;,{ params: { id: 12, }, }, { timeout: 5000, } ).then((res) =&gt; { console.log(res);}); 实际开发12345678910111213141516let instance = axios.create({ baseURL: &quot;http://localhost:8080&quot;, timeout: 1000});let instance1 = axios.create({ baseURL: &quot;http://localhost:9090&quot;, timeout:3000});instance .get(&quot;/data.json&quot;, { params: { id: 12, }, }) .then((res) =&gt; { console.log(res); });instance1 .get(&quot;/data.json&quot;, { params: { id: 12, }, },{timeout: 5000 }) .then((res) =&gt; { console.log(res); }); 拦截器拦截器：在请求和响应被处理前拦截他们请求拦截器、响应拦截器 123456789101112131415161718192021222324252627282930313233343536// 请求拦截器 axios.interceptors.request.use((config) =&gt; { // 在发送请求前做些什么 return config; },err =&gt; { // 在请求错误的时候做些什么 return Promise.reject(err) }); // 响应拦截器 axios.interceptors.response.use((res) =&gt; { // 请求成功对响应数据做处理 return res; }, (err) =&gt; { // 响应错误做些什么 return Promise.reject(err); }); // 取消拦截器 let interceptors = axios.interceptors.request.use((config) =&gt; { config.headers = { auth: true, }; return config; }); axios.interceptors.request.eject(interceptors); // 例子 登录状态（token:''） let instance = axios.create({}); instance.interceptors.request.use((config) =&gt; { config.headers.token = &quot;&quot;; return config; }); // 移动端开发 let instance_phone = axios.create({}); instance_phone.interceptors.request.use((config) =&gt; { // 加载动画显示 $(&quot;#modal&quot;).show(); return config; }); instance_phone.interceptors.response.use((res) =&gt; { // 加载动画隐藏 $(&quot;#modal&quot;).hide(); return res; }); 错误处理错误处理：请求错误时进行的处理 1234567891011121314151617181920212223let instance = axios.create();// 请求拦截器instance.interceptors.request.use((config) =&gt; { return config;}, (error) =&gt; { // 请求错误 一般 http 状态码以 4开头，常见：401超时，404 not found $(&quot;#modal&quot;).show(); setTimeout(() =&gt; { $('#modal').hide(); } ,2000); return Promise.reject(error);} );// 响应拦截器instance.interceptors.response.use( (res) =&gt; { return res;}, (error) =&gt; { //响应错误处理 一般 http 状态码以 5 开头，500 系统错误，502，系统重启 $(&quot;#modal&quot;).show(); setTimeout(() =&gt; { $('#modal').hide(); },2000); return Promise.reject(error); } ); instance .get() .then( (res) =&gt; { console.log(res); }) .catch( (err) =&gt; { console.log(err); }); 取消请求取消请求：用于取消正在进行的 http 请求 123456789let source = axios.CancelToken.source();axios .get(&quot;/data.json&quot;, { cancelToken:source.token,}) .then((res) =&gt; { console.log(res);}) .catch((err) =&gt; { console.log(err);});// 取消请求 source.cancel('cancel http') Axios 封装对 Axios 二次封装 http.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import axios from &quot;axios&quot;;import service from &quot;./contactApi&quot;;import { Toast } from &quot;vant&quot;;// service 循环遍历输出不同的请求方法let instance = axios.create({ baseURL: &quot;http://localhost:9000/api&quot;, timeout: 1000,});const Http = {};// 包裹请求方法的容器for (let key in service) { let api = service[key]; // url method // saync 作用：避免进入回调地狱 Http[key] = async ( params, // 请求参数 get:url put, post, patch(data),delete:url isFormData = false, // 标识是否是form-data 请求 config = {} // 配置参数 )=&gt; { let newParams = {}; // content-type 是否是 form-data 的判断 if (params &amp;&amp; isFormData) { newParams = new FormData(); for (let key in params) { newParams.append(key, params[key]); } }else { newParams = params; } // 不同请求的判断 let response = {}; if (api.method === &quot;put&quot; || api.method === &quot;post&quot; || api.method === &quot;patch&quot; ) { try{ response = await instance[api.method](api.url, newParams, config); } catch(error) { response = error; } } else { config.params = newParams; try { response = await instance[api.method](api.url, config); } catch (error) { response = error; } } return response; // 返回响应值 }; } instance.interceptors.request.use( (config) =&gt; { // 发起请求前做些什么 Toast.loading({ mask: false, duration: 0, forbidClick: true, message:&quot;加载中……&quot;, }); return config; }, () =&gt; { // 请求错误 Toast.clear(); Toast(&quot;请求错误，请稍后重试&quot;); } ); instance.interceptors.response.use( (res) =&gt;{ Toast.clear(); return res.data; }, () =&gt; { // 请求错误 Toast.clear(); Toast(&quot;请求错误，请稍后重试&quot;); } );export default Http; 接口分离 contactApi.js 12345678910111213141516171819202122232425const CONTACT_API = { // 获取联系人列表 getContactList: { method: &quot;get&quot;, url:&quot;/contactList&quot;, }, // 新建联系人 form-data newContactForm: { method: &quot;post&quot;, url: &quot;/contact/new/form&quot;, }, // 新建联系人 json newContactJson: { method:&quot;post&quot;, url: &quot;/contact/new/json&quot;, }, // 编辑联系人 editContact: { method: &quot;put&quot;, url: &quot;/contact/edit&quot;, }, // 删除联系人 delContact: { method: &quot;delete&quot;, url: &quot;/contact&quot;, }, };export default CONTACT_API; 挂载 main.js 12import Http from &quot;./service/http&quot;;Vue.prototype.$Http = Http; 使用 12async onDelete(info) { let res = await this.$Http.delContact({ id: info.id, });if (res.code == 200) { Toast(&quot;删除成功&quot;); this.getList(); } } 总结1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// http.js// 封装 axiosimport axios from 'axios'/* 1、创建实例 *不同的地址请求：多个实例、覆盖 baseURL */const instance = axios.create({ baseURL: 'https://some-domain.com/api/', timeout: 1000,});// 2、添加请求拦截instance.interceptors.request.use(function (config) { // 发送请求前 config.headers.[Token] = '123' return config;}, (error) =&gt; { // 请求错误 console.log(error); return Promise.reject(error);});// 3、添加响应拦截instance.interceptors.response.use((response)=&gt; { let res = response.data if(res.code == 200 ){ return res; }else{ // 错误处理 }}, (error)=&gt; { // 错误处理 return Promise.reject(error);}default instance;// article.jsimport request from '@/utils/request'export function fetchList(query) { return request({ url: '/vue-element-admin/article/list', method: 'get', params: query })}// article.vueimport { fetchList } from article.jsfetchList().then(res=&gt;{ console.log(res);}).catch(err)=&gt;{ console.log(err);} 相关资料[视频]axios 在 vue 中的使用√ 【爬坑日记】利用axios进行post提交formdata Github axiosnpm axios四种常见的 POST 提交数据方式FormDataUsing FormData ObjectsURLSearchParamsVant 示例postcss-pxtoremlib-flexiblebrowserslistvue 项目配置 autoprefixer 报出警告问题vue-element-adminaxios 是如何封装 HTTP 请求的学习 axios 源码整体架构，打造属于自己的请求库vue中Axios的封装和API接口的管理前端 api 请求缓存方案 示例代码axios-learnaxios_node_api","link":"/2020/05/22/Blog-about-learning-83/"},{"title":"微信小程序实践","text":"相关资料接口调整退出微信小程序微信小程序三种授权登录的方式解密userinfo乱码token存储小程序体验版不能获取数据关于小程序onLaunch只执行一次uni-app在微信小程序端如何获取手机号码微信人脸核验接口能力如何实现一个简单的http请求的封装we.request请求封装如何用async、await将wx.login封装成同步执行的？promise封装请求后如何跳转？现在有了全局引进组件的功能，不知道有没有全局引进文件的功能？有些自己封装好常用方法。却要每个文件引入将小程序原生异步函数promisify后，在async/await中使用","link":"/2020/05/27/Blog-about-learning-88/"},{"title":"项目管理优化","text":"代码库规范 commit 信息我们可以利用 commitizen 和 husky 来规范代码库的 commit。 如果安装过 commitizen，那么先全局安装： 1npm install commitizen -g 安装以下依赖: 1npm install @commitlint/cli @commitlint/config-conventional husky -D 在 package.json 中增加 husky 字段。 1234567{ &quot;husky&quot;: { &quot;hooks&quot;: { &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot; } },} husky 是 git hook 工具，使用 husky，我们可以方便的在 package.json 中配置 git hook 脚本，例如: pre-commit、 pre-push、 commit-msg 等的。 创建 commitlint.config.js 文件 123module.exports = { extends: [&quot;@commitlint/config-conventional&quot;],}; 使用 git cz 来进行填写 commit 的内容。 不喜欢默认的交互,可以使用 cz-customizable 来进行定制。 自定义提交说明12// 安装 cz-customizablenpm install cz-customizable -D cz-customizable 是可自定义的 Commitizen 插件，可帮助实现一致的 commit message。 cz-customizable 适合大型团队去自定义 scope，和 commit type。 在项目根目录下创建 .cz-config.js 文件： cz-customizable 会首先在项目根目录下寻找: .cz-config.js 或 .config/cz-config.js，如果找不到，会去主目录寻找。我们也可以在 package.json 中手动去指定配置文件的路径。 12345678&quot;config&quot;: { &quot;commitizen&quot;: { &quot;path&quot;: &quot;node_modules/cz-customizable&quot; }, &quot;cz-customizable&quot;: { &quot;config&quot;: &quot;config/path/to/my/config.js&quot; }} 我们希望提交到git库的代码，都能够通过 eslint 检查或者是通过测试。我们可以借助于 pre-commit 这个钩子来做这些事情。 代码提交前检查 12// 安装依赖npm install lint-staged -D 使用 pre-commit 的 hook 1234567891011&quot;husky&quot;: { &quot;hooks&quot;: { &quot;pre-commit&quot;: &quot;lint-staged&quot; }},&quot;lint-staged&quot;: { &quot;**/*.js&quot;: [ &quot;prettier --write&quot;, &quot;eslint&quot; ]} 这样配置之后，每次提交的时候，都会对要提交的文件（并不是对整个项目）进行 prettier 格式化和 eslint 检查，都通过之后，才能 commit 成功。 eslint 和 prettier 配置react 项目配置。 12// 安装 eslint 和 prettier 相关依赖：npm install eslint eslint-config-prettier eslint-plugin-promise eslint-plugin-react eslint-plugin-react-hooks prettier babel-eslint -D 新建 .prettierrc.js 也可以在 package.json 的 prettier 字段中配置，配置成了独立的文件，以便后期维护。 1234module.exports = { printWidth: 100, //长度超过100断行 singleQuote: true,//使用单引号}; 不需要 prettier 进行格式化，那么可以新建一个 .prettierignore 文件。 123distnode_modulespublic 新建 .eslintrc.js 文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112module.exports = { settings: { react: { pragma: 'React', version: 'detect' } }, // babel parser to support ES6/7 features parser: 'babel-eslint', parserOptions: { ecmaVersion: 7, ecmaFeatures: { experimentalObjectRestSpread: true, jsx: true }, sourceType: 'module' }, extends: [ 'prettier', 'prettier/react' ], plugins: [ 'promise', 'react', 'react-hooks' ], env: { browser: true, es6: true, node: true }, rules: { 'no-compare-neg-zero': 2, //禁止与 -0 进行比较 'no-cond-assign': 2, //禁止条件表达式中出现赋值操作符 'no-console': 1, //禁用 console 'no-constant-condition': 1, //禁止在条件中使用常量表达式 'no-control-regex': 1, //禁止在正则表达式中使用控制字符 'no-debugger': 2, //禁用 debugger 'no-dupe-args': 2, //禁止 function 定义中出现重名参数 'no-dupe-keys': 2, //禁止对象字面量中出现重复的 key 'no-duplicate-case': 2, //禁止出现重复的 case 标签 'no-const-assign': 1, //禁止修改const声明的变量 'no-empty': 1, //禁止出现空语句块 'no-empty-character-class': 2, //禁止在正则表达式中使用空字符集 'no-ex-assign': 2, //禁止对 catch 子句的异常参数重新赋值 'no-extra-boolean-cast': 1, //禁止不必要的布尔转换 'no-extra-semi': 1, //禁止不必要的分号 'no-func-assign': 2, //禁止对 function 声明重新赋值 'no-inner-declarations': 0, //禁止在嵌套的块中出现变量声明或 function 声明,ES6中无需禁止 'no-invalid-regexp': 2, //禁止 RegExp 构造函数中存在无效的正则表达式字符串 'no-irregular-whitespace': 1, //禁止在字符串和注释之外不规则的空白 'no-obj-calls': 2, //禁止把全局对象作为函数调用，比如Math() JSON() 'no-regex-spaces': 1, //禁止正则表达式字面量中出现多个空格 'no-sparse-arrays': 1, //禁用稀疏数组 'no-unexpected-multiline': 1, //禁止出现令人困惑的多行表达式 'no-unreachable': 1, //禁止在return、throw、continue 和 break 语句之后出现不可达代码 'no-unsafe-finally': 2, //禁止在 finally 语句块中出现控制流语句 'no-unsafe-negation': 1, //禁止对关系运算符的左操作数使用否定操作符 'use-isnan': 2, //要求使用 isNaN() 检查 NaN，如 isNaN(foo),而非foo == NaN 'valid-typeof': 2, //强制 typeof 表达式与有效的字符串(如: 'undefined', 'object', 'boolean', 'number', 'string', 'function','symbol')进行比较 'no-case-declarations': 1, //不允许在 case 子句中使用词法声明 'no-empty-pattern': 2, //禁止使用空解构模式 'no-fallthrough': 2, //禁止 case 语句落空 'no-global-assign': 2, //禁止对原生对象或只读的全局对象进行赋值 'no-octal': 1, //禁用八进制字面量 'no-redeclare': 1, //禁止多次声明同一变量 'no-self-assign': 1, //禁止自我赋值 'no-unused-labels': 1, //禁用出现未使用过的标 'no-useless-escape': 1, //禁用不必要的转义字符 'no-delete-var': 2, //禁止删除变量 'no-undef': 2, //禁用使用未声明的变量，除非它们在 /*global */ 注释中被提到 'no-unused-vars': 1, //禁止出现未使用过的变量 'constructor-super': 2, //要求在构造函数中有 super() 的调用 'no-class-assign': 2, //禁止给类赋值 'no-dupe-class-members': 2, //禁止类成员中出现重复的名称 'no-new-symbol': 2, //禁止 Symbol 和 new 操作符一起使用 'no-this-before-super': 2, //禁止在构造函数中，在调用 super() 之前使用 this 或 super 'require-yield': 2, //要求 generator 函数内有 yield 'no-mixed-spaces-and-tabs': 1, //要求不适用space，tab混用 'react/forbid-prop-types': [1, { forbid: ['any'] }], //禁止某些propTypes 'react/prop-types': 1, //没用对props类型进行校验 'react/jsx-closing-bracket-location': 1, //在JSX中验证右括号位置 'react/jsx-curly-spacing': [1, { when: 'never', children: true }], //在JSX属性和表达式中加强或禁止大括号内的空格。 'react/jsx-key': 2, //在数组或迭代器中验证JSX具有key属性 'react/jsx-max-props-per-line': [1, { maximum: 1 }], // 限制JSX中单行上的props的最大数量 'react/jsx-no-duplicate-props': 2, //防止在JSX中重复的props 'react/jsx-no-undef': 1, //在JSX中禁止未声明的变量 'react/no-string-refs': 1, //Using string literals in ref attributes is deprecated 'react/jsx-uses-react': 1, //防止反应被错误地标记为未使用 'react/jsx-uses-vars': 1, //防止在JSX中使用的变量被错误地标记为未使用 'react/no-danger': 1, //防止使用危险的JSX属性 'react/no-did-update-set-state': 2, //防止在componentDidUpdate中使用setState 'react/no-did-mount-set-state': 0, //防止在componentDidUpdate中使用setState 'react/no-direct-mutation-state': 2, //防止this.state赋值 'react/no-unknown-property': 2, //防止使用未知的DOM属性 'react/prefer-es6-class': 1, //为React组件强制执行ES5或ES6类 'react/react-in-jsx-scope': 0, //使用JSX时，必须要引入React 'react/sort-comp': 0, //强制组件方法顺序 'react/sort-prop-types': 0, //强制组件属性顺序 'react/jsx-sort-props': 1, 'react/no-deprecated': 1, //不使用弃用的方法 'react/jsx-equals-spacing': 1, //在JSX属性中强制或禁止等号周围的空格 'react/wrap-multilines': 0, 'comma-dangle': 1, //对象字面量项尾不能有逗号 'react/no-multi-comp': 0, //防止每个文件有多个组件定义 'flowtype/generic-spacing': 0, //泛型对象的尖括号中类型前后的空格规范 'flowtype/space-after-type-colon': 0, //类型注解分号后的空格规范 // react-hooks 'react-hooks/rules-of-hooks': 'error', 'react-hooks/exhaustive-deps': 'warn' }}; Vue CLI 3 插件1vue add @ziyi2/ui-cz 以上是我对下列视频及文章的归纳和总结花十分钟的时间武装你的代码库 参考资料cz-customizableCz工具集使用介绍 - 规范Git提交说明","link":"/2020/05/26/Blog-about-learning-87/"},{"title":"async&#x2F;await 入门","text":"相关资料async 函数js async await 终极异步解决方案async functionawaitasync 函数的含义和用法8 张图帮你一步步看清 async/await 和 promise 的执行顺序Promise 和 Async/Await 用法整理Async/Await 优于 Promise 的 6 个理由有了 async/await，你可以丢掉 promise 链了关于 Promise 和 Async/Await 你可能不知道的事Promise 与 async/await精读《async/await 是把双刃剑》Async：简洁优雅的异步之道async/await 原理及执行顺序分析","link":"/2020/05/27/Blog-about-learning-89/"},{"title":"JavaScript 的 API 文档生成","text":"看公众号有一篇关于 JS 工具函数大全，心想着纳入我的博客中，又想起用过 vue-element-admin 中有个日期过滤器不错，也总结到一起，一看过滤器脚本中注释中有 @param 由此便引出了这篇博客。 JSDoc什么是 JSDocJSDoc 3是用于JavaScript的API文档生成器，类似于Javadoc或phpDocumentor。您可以将代码注释直接添加到源代码中，并直接添加到源代码中。JSDoc工具将扫描您的源代码并为您生成一个HTML文档网站。JSDoc的目的是记录您的JavaScript应用程序或库的API。假定您将要记录诸如模块，名称空间，类，方法，方法参数之类的内容。JSDoc 注释一般应该放置在方法或函数声明之前，它必须以 / ** 开始， 使用 JSDoc1234567891011121314151617181920212223242526/** * Book类，代表一个书本. * @constructor * @param {string} title - 书本的标题. * @param {string} author - 书本的作者. */function Book(title, author) { this.title = title; this.author = author;}Book.prototype = { /** * 获取书本的标题 * @returns {string|*} */ getTitle: function () { return this.title; }, /** * 设置书本的页数 * @param pageNum {number} 页数 */ setPageNum: function (pageNum) { this.pageNum = pageNum; },}; 块标签@event 描述：描述一个事件。 @fires： 表明方法可以触发该事件 @listens 表明用这个表示来侦听该事件 示例： 1234567891011121314151617/** * Throw a snowball. * * @fires Hurl#snowball */Hurl.prototype.snowball = function () { /** * Snowball event. * * @event Hurl#snowball * @type {object} * @property {boolean} isPacked - Indicates whether the snowball is tightly packed. */ this.emit(&quot;snowball&quot;, { isPacked: this._snowball.isPacked, });}; @external 描述:标识一个外部的类，命名空间，或模块。别名: @host 例如，描述内置类添加方法： 12345678910111213/** * The built in string object. * @external String * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String|String} *//** * Create a ROT13-encoded version of the string. Added by the `foo` package. * @function external:String#rot13 * @example * var greeting = new String('hello world'); * console.log( greeting.rot13() ); // uryyb jbeyq */ 例如，描述的外部的命名空间： 12345678910/** * The jQuery plugin namespace. * @external &quot;jQuery.fn&quot; * @see {@link http://learn.jquery.com/plugins/|jQuery Plugins} *//** * A jQuery plugin to make stars fly around your home page. * @function external:&quot;jQuery.fn&quot;.starfairy */ 例如，扩展一个外部类： 1234567891011/** * The built-in class for sending HTTP requests. * @external XMLHttpRequest * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest *//** * Extends the built-in `XMLHttpRequest` class to send data encoded with a secret key. * @class EncodedRequest * @extends external:XMLHttpRequest */ 例如，记录一个嵌套的外部标识： 1234567891011/** * External namespace for security-related classes. * @external security * @see http://example.org/docs/security *//** * External class that provides Transport Layer Security (TLS) encryption. * @class TLS * @memberof external:security */ @module 记录一个 JavaScript 模块。 例如，如果没有提供导出模块的名称： 123456# from src/jsdoc ./test.js # module name 'test'# from src's parent directory:jsdoc src/test.js # module name 'src/test'jsdoc -r src/ # module name 'test' 123456789/** @module myModule */// 模块私有的/** will be module:myModule~foo */var foo = 1;// 由模块导出一个静态函数/** will be module:myModule.bar */var bar = function () {}; 例如，定义导出的标识符为’this’的成员： 123456/** @module bookshelf *//** @class */this.Book = function (title) { /** The title. */ this.title = title;}; 例如，定义导出的标识符为 module.exports 或 exports 的成员: 1234567/** @module color/mixer */module.exports = { /** Blend two colours together. */ blend: function (color1, color2) {},};/** Darkens a color. */exports.darken = function (color, shade) {}; @param 描述: 记录传递给一个函数的参数。别名： arg argument 注释变量名 、 变量类型 和 变量说明，例如： 123456/** * @param {string} somebody - Somebody's name. */function sayHello(somebody) { alert(&quot;Hello &quot; + somebody);} 例如，描述一个对象参数的属性： 123456789/** * Assign the project to an employee. * @param {Object} employee - The employee who is responsible for the project. * @param {string} employee.name - The name of the employee. * @param {string} employee.department - The employee's department. */Project.prototype.assign = function (employee) { // ...}; 例如，描述参数的属性值在数组中： 123456789/** * Assign the project to a list of employees. * @param {Object[]} employees - The employees who are responsible for the project. * @param {string} employees[].name - The name of an employee. * @param {string} employees[].department - The employee's department. */Project.prototype.assign = function (employees) { // ...}; 一个可选参数（使用 JSDoc 语法），例如： 1234567891011121314151617181920/** * @param {string} [somebody] - Somebody's name. */function sayHello(somebody) { if (!somebody) { somebody = &quot;John Doe&quot;; } alert(&quot;Hello &quot; + somebody);}// 选参数和默认值：/** * @param {string} [somebody=John Doe] - Somebody's name. */function sayHello(somebody) { if (!somebody) { somebody = &quot;John Doe&quot;; } alert(&quot;Hello &quot; + somebody);} 例如，允许一个类型或另一个类型： 1234567891011/** * @param {(string|string[])} [somebody=John Doe] - Somebody's name, or an array of names. */function sayHello(somebody) { if (!somebody) { somebody = &quot;John Doe&quot;; } else if (Array.isArray(somebody)) { somebody = somebody.join(&quot;, &quot;); } alert(&quot;Hello &quot; + somebody);} 例如，允许任何类型： 123456/** * @param {*} somebody - Whatever you want. */function sayHello(somebody) { console.log(&quot;Hello &quot; + JSON.stringify(somebody));} 例如，可重复使用的参数： 1234567891011/** * Returns the sum of all numbers passed to the function. * @param {...number} num - A positive or negative number. */function sum(num) { var i = 0, n = arguments.length, t = 0; for (; i &amp;lt; n; i++) { t += arguments[i]; } return t;} 例如，参数接受一个回调函数： 123456789101112131415/** * This callback type is called `requestCallback` and is displayed as a global symbol. * * @callback requestCallback * @param {number} responseCode * @param {string} responseMessage *//** * Does something asynchronously and executes the callback on completion. * @param {requestCallback} cb - The callback that handles the response. */function doSomethingAsynchronously(cb) { // code} @returns 描述: 记录一个函数的返回值。 返回值的类型和描述，例如： 123456789/** * Returns the sum of a and b * @param {Number} a * @param {Number} b * @returns {Number} Sum of a and b */function sum(a, b) { return a + b;} 返回值可以有不同的类型，例如： 12345678910111213/** * Returns the sum of a and b * @param {Number} a * @param {Number} b * @param {Boolean} retArr If set to true, the function will return an array * @returns {Number|Array} Sum of a and b or an array that contains a, b and the sum of a and b. */function sum(a, b, retArr) { if (retArr) { return [a, b, a + b]; } return a + b;} @constructs 描述: 这个函数成员将成为类的构造函数。 @lends：将一个字面量对象的所有属性标记为某个标识符（类或模块）的成员。 @param：标明这个标识属于哪个父级标识。 例如， @constructs 和 @lends 结合使用： 12345678910111213var Person = makeClass( /** @lends Person.prototype */ { /** @constructs */ initialize: function (name) { this.name = name; }, /** Describe me. */ say: function (message) { return this.name + &quot; says: &quot; + message; }, }); 不和@lends结合使用的时候，你必须提供一个类的名称: 123456789101112makeClass('Menu', /** * @constructs Menu * @param items */ function (items) { }, { /** @memberof Menu# */ show: function(){ } }); 内联标签@link 描述: 链接到文档中的另一个项目。 别名： @linkcode：强制使用等宽字体链接文本。 @linkplain：强制显示为正常的文本，没有等宽字体链接文本。 例如，提供链接文本： 123456/** * See {@link MyClass} and [MyClass's foo property]{@link MyClass#foo}. * Also, check out {@link http://www.google.com|Google} and * {@link https://github.com GitHub}. */function myFunction() {} @tutorial 描述: 链接到一个教程。 下面的例子显示了提供给{@tutorial}标签链接文本的所有方式，例如： 123456/** * See {@tutorial gettingstarted} and [Configuring the Dashboard]{@tutorial dashboard}. * For more information, see {@tutorial create|Creating a Widget} and * {@tutorial destroy Destroying a Widget}. */function myFunction() {} 以上是我对下列视频及文章的归纳和总结。JSDoc 注释规范Js 注释JS Doc3 + Docstrap 生成ES6规范下的JS代码的API文档jsdoc的使用VSCode + JSDoc 完美实现（almost）JavaScript代码提示 相关资料YUIDoc 语法参考使用 JSDocJSDoc 中文文档","link":"/2020/05/26/Blog-about-learning-86/"},{"title":"JavaScript中设计模式 从入门到实践应用","text":"原生小程序中没有状态管理，看别人写状态管理需要观察者模式便来补一下。vue 中也使用了观察者模式，vue2 中用的 Object ……get、set 实现的。 构造器模式用于在为其分配了内存后初始化新创建的对象。 1234567function Car(model, year, miles) { this.model = model; this.year = year; this.miles = miles;}// Usage:var bmw = new Car('M4', '2019', '1000'); moModuleattern 对象文字符号 模块模式 AMD模块 CommonJS模块 ECMAScript Harmony模块 123456var newObject = { variableKey：variableValue， functionKey：function（）{ //… }}; 模块模式： 1234567891011121314var testModule = (function() { var counter = 0; return { incrementCounter: function() { return ++counter; }, resetCounter: function() { counter = 0; } };})();// Usage:testModule.incrementCounter();testModule.resetCounter(); 显示模块模式当我们要从另一个对象调用一个公共方法或访问公共变量时，避免重复主对象的名称。 1234567891011121314151617181920var myRevealingModule = (function() { var privateVariable = 'not okay', publicVariable = 'okay'; function privateFun() { return privateVariable; }function publicSetName(strName) { privateVariable = strName; }function publicGetName() { privateFun(); }return { setName: publicSetName, message: publicVariable, getName: publicGetName };})();//Usage:myRevealingModule.setName('Marvin King'); 单例模式1234567891011121314151617181920212223242526272829303132var singletonPattern = (function() { var instance; function init() { // Singleton function privateMethod() { console.log('privateMethod'); } var privateVariable = 'this is private variable'; var privateRandomNumber = Math.random(); return { publicMethod: function() { console.log('publicMethod'); }, publicProperty: 'this is public property', getRandomNumber: function() { return privateRandomNumber; } }; }return { // Get the singleton instance if one exists // or create if it doesn't getInstance: function() { if (!instance) { instance = init(); } return instance; } };})();// Usage:var single = singletonPattern.getInstance(); 观察者模式/发布-订阅模式当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。 123456789101112131415161718function ObserverList() { this.observerList = [];}ObserverList.prototype.Add = function(obj) { return this.observerList.push(obj);};ObserverList.prototype.Empty = function() { this.observerList = [];};ObserverList.prototype.Count = function() { return this.observerList.length;};ObserverList.prototype.Get = function(index) { if (index &gt; -1 &amp;&amp; index &lt; this.observerList.length) { return this.observerList[index]; }};//... 中介者模式中介体模式通过确保组件而不是彼此明确引用来促进松散耦合。 12345678910111213141516171819202122232425262728293031var mediator = (function() { var topics = {}; var subscribe = function(topic, fn) { if (!topics[topic]) { topics[topic] = []; } topics[topic].push({ context: this, callback: fn }); return this; };// publish/broadcast an event to the rest of the application var publish = function(topic) { var args; if (!topics[topic]) { return false; } args = Array.prototype.slice.call(arguments, 1); for (var i = 0, l = topics[topic].length; i &lt; l; i++) { var subscription = topics[topic][i]; subscription.callback.apply(subscription.content, args); } return this; }; return { publish: publish, subscribe: subscribe, installTo: function(obj) { obj.subscribe = subscribe; obj.publish = publish; } }; })(); 原型模式123456789101112var myCar = { name: 'bmw', drive: function() { console.log('I am driving!'); }, panic: function() { console.log('wait, how do you stop this thing?'); }};//Usages:var yourCar = Object.create(myCar);console.log(yourCar.name); //'bmw' 工厂模式12345function Car(options) { this.doors = options.doors || 4; this.state = options.state || 'brand new'; this.color = options.color || 'silver';} Mixin模式混合类是提供功能的类，这些功能可以由子类或子类组轻松继承以进行功能复用。 1234567891011121314var Person = function(firstName, lastName) { this.firstName = firstName; this.lastName = lastName; this.gender = 'male';};var clark = new Person('Clark', 'kent');var Superhero = function(firstName, lastName, powers) { Person.call(this.firstName, this.lastName); this.powers = powers;};SuperHero.prototype = Object.create(Person.prototype);var superman = new Superhero('Clark', 'Kent', ['flight', 'heat-vision']);console.log(superman); //output personal attributes as well as power 装饰器模式12345678910111213141516171819202122232425262728293031323334function MacBook() { this.cost = function() { return 997; }; this.screenSize = function() { return 11.6; };}// Decorator 1function Memory(macbook) { var v = macbook.cost(); macbook.cost = function() { return v + 75; };}// Decorator 2function Engraving(macbook) { var v = macbook.cost(); macbook.cost = function() { return v + 200; };}// Decorator 3function Insurance(macbook) { var v = macbook.cost(); macbook.cost = function() { return v + 250; };}var mb = new MacBook();Memory(mb);Engraving(mb);Insurance(mb);mb.cost(); // 1522 10个每个开发人员都喜欢的JavaScript模式√菜鸟教程 观察者模式JavaScript 设计模式与开发实践 第8章不知道怎么封装代码？看看这几种设计模式吧！JavaScript 设计模式学习总结与感悟","link":"/2020/05/27/Blog-about-learning-90/"},{"title":"你的第一本Python基础入门书","text":"PythonPython 优势 上手容易、代码量更少、高效开发 生态丰富、第三方库众多 语言核心特性 数据类型 数值运算和比较 变量定义、赋值 数组、字符串 分支跳转 循环 函数 语言扩展特性 异常机制 类 模块与包 内置数据结构 内置函数 迭代器 生成器 装饰器 函数式特性 动态类型 以及其它常用语言特性 语言周边知识和功能 标准库 IO 操作 进程线程 序列化 代码规范 以及运行环境相关，如 Python 解释器、虚拟环境，Java 的 JVM 等 扩展为什么需要程序语言 计算机实际运行的是计算机指令序列。指令序列的直接表现形式是一连串的 0 和 1，也就是机器码。用机器码的 0 和 1 这两个字符来编程是困难和低效的。为了提高生产效率，我们需要一种容易书写和阅读的标记来表达机器码指令。使用方式是用这种标记进行程序编码，编码完成后再将这些标记翻译为机器码。最初达到这个目的的是汇编语言，汇编语言一种是程序语言，不过是低级程序语言，它和机器码之间有着比较直接的一一对应关系。扩展：计算机的世界里「抽象」这次词表示屏蔽掉内部纷繁复杂的细节，直接触达其核心功能，为外部建立起更高效更易用的使用入口和操作方法。 C 语言有非常高的执行效率，和马马虎虎的开发效率，在一些极度依赖执行效率和底层控制的领域独占鳌头，比如操作系统开发。 Java 借助于 JVM 得以跨越不同的操作系统和计算机架构而运行 Java 程序。Java 也拥有良好的执行效率和稳定性，它的执行效率与 C 语言相比，最高能保持在同一个数量级上。 Python 与 C 和 Java 相比有较大的不同，Python 是解释型语言，没有显式编译的过程，代码可直接由解释器解释执行，同时借助于解释器，其代码也可以跨平台运行。另一方面它是动态语言，在一定程度上更加灵活。Python 的理念是优雅和简单，虽然执行效率相较于 C 和 Java 大约慢一到两个数量级，不过 Python 的开发效率却数倍高于它们。","link":"/2020/06/01/Blog-about-learning-91/"},{"title":"Python Web学习路线","text":"以上是我对下列视频及文章的归纳和总结。终于等到你——【Python Web学习路线】干货满满速收藏！","link":"/2020/06/02/Blog-about-learning-92/"},{"title":"Chrome 调试","text":"alertconsole基本输出123456console.log(&quot;打印字符串&quot;); // 在控制台打印字符串console.error(&quot;我是个错误&quot;); // 在控制台打印错误信息console.info(&quot;我是个信息&quot;); // 在控制台打印信息console.warn(&quot;我是个警告&quot;); // 在控制台打印警告信息console.debug(&quot;我是个调试&quot;); // 在控制台打印调试信息console.clear(); // 清空控制台 格式化输出123456console.log(&quot;%s年&quot;,2016); // %s表示字符串console.log(&quot;%d年%d月&quot;,2016,11); // %d表示整数console.log(&quot;%f&quot;,3.1415926); //%f小数console.log(&quot;%o&quot;,console); //%o表示对象console.log(&quot;%c自定义样式&quot;,&quot;font-size:30px;color:#00f&quot;);console.log(&quot;%c我是%c自定义样式&quot;,&quot;font-size:20px;color:green&quot;,&quot;font-size:10px;color:red&quot;); DOM输出12var ul = document.getElementsByTagName(&quot;ul&quot;);console.dirxml(ul) 对象输出12var o = {name:&quot;Lily&quot;,age:18};console.dir(obj) 123var stu = [{name:&quot;Bob&quot;,age:13,hobby:&quot;playing&quot;},{name:&quot;Lucy&quot;,age:14,hobby:&quot;reading&quot;},{name:&quot;Jane&quot;,age:11,hobby:&quot;shopping&quot;}];console.log(stu);console.table(stu); 成组输出12345console.group(&quot;start&quot;); // 引号里是组名console.log(&quot;sub1&quot;);console.log(&quot;sub1&quot;);console.log(&quot;sub1&quot;);console.groupEnd(&quot;end&quot;); 函数计数和跟踪123456789101112function fib(n){ // 输出前n个斐波那契数列值 if( n == 0) return; console.count(&quot;调用次数&quot;); // 放在函数里，每当这句代码运行输出所在函数执行次数 console.trace(); // 显示函数调用轨迹(访问调用栈） var a = arguments[1] || 1; var b = arguments[2] || 1; console.log(&quot;fib=&quot; + a); [a, b] = [b, a + b]; fib(--n, a, b);}fib(6); 计时123console.time() // 计时开始fib(100); // 用上述函数计算100个斐波那契数console.timeEnd() // 计时结束并输出时长 断言语句12console.assert(true, &quot;我错了&quot;);console.assert(false,&quot;我真的错了&quot;); 性能分析1234567891011121314151617function F(){ var i = 0; function f(){ while(i++ == 1000); } function g(){ while(i++ == 100000); } f(); g();}console.profile();F();console.profileEnd(); 注：Chrome开发者工具中的Audits标签页也可以实现性能分析。 debugger12345678910111213var arr = [];for(var i = 0; i &lt; 10; i++){ arr[i] = (function(i){ return function (){ debugger; return i; } })(i)}for(var j = 0; j&lt; arr.length; j++){ console.log(arr[j]() + &quot; &quot;);} Pause/Resume script execution：暂停/恢复脚本执行（程序执行到下一断点停止）。 Step over next function call：执行到下一步的函数调用（跳到下一行）。 Step into next function call：进入当前函数。 Step out of current function：跳出当前执行函数。 Deactive/Active all breakpoints：关闭/开启所有断点（不会取消）。 Pause on exceptions：异常情况自动断点设置。 Watch：Watch表达式 Call Stack: 栈中变量的调用，这里是递归调用，肯定是在内存栈部分调用。 Scope：当前作用域变量观察。 BreakPoints：当前断点变量观察。 XHR BreakPoints：面向Ajax，专为异步而生的断点调试功能。 DOM BreakPoints：主要包括下列DOM断点，注册方式见下图： 当节点属性发生变化时断点（Break on attributes modifications） 当节点内部子节点变化时断点（Break on subtree modifications） 当节点被移除时断点（Break on node removal）Global Listeners：全局事件监听Event Listener Breakpoints：事件监听器断点，列出了所有页面及脚本事件，包括：鼠标、键盘、动画、定时器、XHR等等。 chrome中的调试技巧 DOM元素的控制台书签：Chrome开发者工具和Firebug都提供了书签功能，用于显示你在元素标签页（Chrome）或HTML标签页（Firebug）中最后点击的DOM元素。如果你依次选择了A元素、B元素和C元素，那么$0 表示C元素， $1 表示B元素， $2 表示A元素（这个和正则表达式的$符号类似，不过顺序不同）。 如果你想调试f函数，用debug(f)语句可以增加这种断点。 Sources标签页左侧面板上有一个代码片段（Snippet）子标签页，可用于保存代码片段，帮你调试代码。 可以用Chrome开发者工具Sources标签页中的格式化按钮（Pretty Print Button）格式化压缩后的代码。 在Network面板，选择一个资源文件，右键Copy Response可快速复制响应内容。 利用媒体查询，这个主要是在Device Mode调节不同的分辨率显示。 选择Elements，按 Esc &gt; Emulation &gt; Sensors进行传感器模拟。 选择Elements，按 Esc &gt; Emulation &gt; Sensors进行传感器模拟。 点击渐入效果样式图标（紫色图标），可以预览动画效果，并可对相应的贝塞尔曲线(cubic-bezier)进行调节动画效果。 在Source中按住Alt键并拖动鼠标进行多列内容选择。 Elements面板右键执行DOM元素节点，选择Force Element State或者点击右侧Toggle Element State图标可以出发伪类。 Network面板中选择一张图片，在右侧图片上鼠标右键选择copy it as a Data URI,就可以获取图片的Data URL (base64编码)。 通过按住Ctrl键可以添加多个编辑光标，同时对多处进行编辑。按下Ctrl + U可以撤销编辑。 Elements面板右侧的Style编辑器中，点击颜色十六进制编码前的小色块，会弹出一个调色板。 按下Alt键并且鼠标双击选择DOM元素前面的箭头，就会展开该DOM元素下的所有字节点元素. 快捷键： 快速定位到行：快捷键 Ctrl+O(Mac: CMD+O)，输入：行号:列号 来进行定位 元素搜索：快捷键 Ctrl+F(Mac: CMD+F)，试试在搜索栏输入ID选择符或者类选择符就可以定位到元素啦 ctrl+p 查找当前网站已加载的资源文件 ctrl+shift+p 显示所有命令 ctrl+l 清空console面板数据 ctrl+R/ f5 正常重新加载 ctrl+shift+R/shift f5 硬性重新加载 调试过程注意事项 1、避免记录引用类型 当记录对象或数组时，永远记得你在记录什么。记录原始类型时，使用带断点的watch表达式。如果是异步代码，避免记录引用类型。 12345var arr = [{ num: 0 }];setInterval( function (){ console.log(arr); arr[0].num += 1;}, 1000); 2、尽可能使用 source map。有时生产代码不能使用source map，但不管怎样，你都不应该直接对生产代码进行调试。 以上是我对下列视频及文章的归纳和总结。Chrome 调试技巧√Chrome DevTools开发者工具调试指南 相关资料 相关工具Chrome","link":"/2020/06/02/Blog-about-learning-93/"},{"title":"WebSocket 从入门到实战开发","text":"socket 官网的例子 1234567891011121314151617181920212223&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var socket = io(); var form = document.getElementById('form'); var input = document.getElementById('input'); form.addEventListener('submit', function(e) { e.preventDefault(); if (input.value) { // 发送消息 socket.emit('chat message', input.value); input.value = ''; } }); // 接受消息 socket.on('chat message', function(msg) { var item = document.createElement('li'); item.textContent = msg; messages.appendChild(item); window.scrollTo(0, document.body.scrollHeight); });&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132const app = require('express')();const http = require('http').Server(app);const io = require('socket.io')(http);app.get('/', (req, res) =&gt; { res.sendFile(__dirname + '/index.html');});io.on('connection', (socket) =&gt; { console.log('a user connected'); socket.on('disconnect', () =&gt; { console.log('user disconnected'); }); // 接受消息 socket.on('chat message', (msg) =&gt; { console.log('message: ' + msg); }); // 广播 服务器端发送消息 socket.broadcast.emit('hi'); socket.emit('hi'); // 一对一 socket.to(id).emit('chat message', input.value); // 断开连接 socket.on('disconnecting',function(){ });});http.listen(3000, () =&gt; { console.log('listening on *:3000');}); 客户端 socket.io-client 相关资料手摸手教你使用WebSocket你不知道的WebSocket零距离接触websocketsocketio 5000字！带你零距离接触websocket！","link":"/2020/06/02/Blog-about-learning-94/"},{"title":"常用数组方法","text":"相关资料JS合并两个数组的3种方法详解JS数组的交集、并集、差集，数组去重，获取两个数组重复的元素，去除两个数组相同的元素JavaScript数组去重（12种方法，史上最全）ES6数组方法15个非常著名JavaScript数组方法，每个前端开发人员都应该知道js二维数组转一维数组方法js获取当前日期的前30天存入数组","link":"/2020/12/05/Blog-about-learning-95/"},{"title":"ES6~ES10 从入门到实战","text":"相关资料ES6 入门教程Javascript ES6 教程 14—ES6 对象解构9个常用ES6特性归纳","link":"/2020/06/08/Blog-about-learning-96/"},{"title":"Hybrid App 从入门到实战","text":"现有混合方案Hybrid App，俗称混合应用，即混合了 Native 技术 与 Web 技术 进行开发的移动应用。现在比较流行的混合方案主要有三种，主要是在 UI 渲染机制上的不同： 基于 WebView UI 的基础方案，市面上大部分主流 App 都有采用，例如微信 JS-SDK，通过 JSBridge 完成 H5 与 Native 的双向通讯，从而赋予 H5 一定程度的原生能力。 基于 Native UI 的方案，例如 React-Native、Weex。在赋予 H5 原生 API 能力的基础上，进一步通过 JSBridge 将 js 解析成的虚拟节点树(Virtual DOM)传递到 Native 并使用原生渲染。 另外还有近期比较流行的小程序方案，也是通过更加定制化的 JSBridge，并使用双 WebView 双线程的模式隔离了 JS 逻辑与 UI 渲染，形成了特殊的开发模式，加强了 H5 与 Native 混合程度，提高了页面性能及开发体验。 以上的三种方案，其实同样都是基于 JSBridge 完成的通讯层，第二三种方案，其实可以看做是在方案一的基础上，继续通过不同的新技术进一步提高了应用的混合程度。 Hybrid 技术原理Hybrid App 的本质，其实是在原生的 App 中，使用 WebView 作为容器直接承载 Web 页面。因此，最核心的点就是 Native 端 与 H5 端 之间的双向通讯层，其实这里也可以理解为我们需要一套跨语言通讯方案，来完成 Native(Java/Objective-c/…) 与 JavaScript 的通讯。这个方案就是我们所说的 JSBridge，而实现的关键，便是作为容器的 WebView，一切的原理都是基于 WebView 的机制。 （一）JavaScript 通知 Native基于 WebView 的机制和开放的 API, 实现这个功能有三种常见的方案： API 注入，原理其实就是 Native 获取 JavaScript 环境上下文，并直接在上面挂载对象或者方法，使 js 可以直接调用，Android 与 IOS 分别拥有对应的挂载方式 WebView 中的 prompt/console/alert 拦截 ，通常使用 prompt，因为这个方法在前端中使用频率低，比较不会出现冲突 WebView URL Scheme 跳转拦截 第二三种机制的原理是类似的，都是通过对 WebView 信息冒泡传递的拦截，从而达到通讯的，接下来我们主要从 原理-定制协议-拦截协议-参数传递-回调机制 5 个方面详细阐述下第三种方案 – URL 拦截方案。 1、实现原理在 WebView 中发出的网络请求，客户端都能进行监听和捕获。 2、协议的定制我们需要制定一套 URL Scheme 规则，通常我们的请求会带有对应的协议开头，例如常见的 https://xxx.com 或者 file://1.jpg，代表着不同的含义。我们这里可以将协议类型的请求定制为： 1xxcommand://xxxx?param1=1&amp;param2=2 不同的协议头代表着不同的含义，这样便能清楚知道每个协议的适用范围。 (2) 这里不要使用 location.href 发送，因为其自身机制有个问题是同时并发多次请求会被合并成为一次，导致协议被忽略，而并发协议其实是非常常见的功能。我们会使用创建 iframe 发送请求的方式。 (3) 通常考虑到安全性，需要在客户端中设置域名白名单或者限制，避免公司内部业务协议被第三方直接调用。 3、协议的拦截客户端可以通过 API 对 WebView 发出的请求进行拦截： IOS：shouldStartLoadWithRequest Android：shouldOverrideUrlLoading 当解析到请求 URL 头为制定的协议时，便不发起对应的资源请求，而是解析参数，并进行相关功能或者方法的调用，完成协议功能的映射。 4、协议回调 由于协议的本质其实是发送请求，这属于一个异步的过程，因此我们便需要处理对应的回调机制。这里我们采用的方式是 JS 的事件系统，这里我们会用到 window.addEventListener 和 window.dispatchEvent 这两个基础 API。 1.发送协议时，通过协议的唯一标识注册自定义事件，并将回调绑定到对应的事件上 。 2.客户端完成对应的功能后，调用 Bridge 的 dispatch API，直接携带 data 触发该协议的自定义事件 5、参数传递方式 由于 WebView 对 URL 会有长度的限制，因此常规的通过 search 参数 进行传递的方式便具有一个问题，既 当需要传递的参数过长时，可能会导致被截断，例如传递 base64 或者传递大量数据时。 因此我们需要制定新的参数传递规则，我们使用的是函数调用的方式。 (二) Native 通知 Javascrip由于 Native 可以算作 H5 的宿主，因此拥有更大的权限，上面也提到了 Native 可以通过 WebView API 直接执行 Js 代码。这样的权限也就让这个方向的通讯变得十分的便捷。 (三) JSBridge 的接入JS 部分(bridge): 在 JS 环境中注入 bridge 的实现代码，包含了协议的拼装/发送/参数池/回调池等一些基础功能。Native 部分(SDK)：在客户端中 bridge 的功能映射代码，实现了 URL 拦截与解析/环境信息的注入/通用功能映射等功能。 将这两部分一起封装成一个 Native SDK，由客户端统一引入。客户端在初始化一个 WebView 打开页面时，如果页面地址在白名单中，会直接在 HTML 的头部注入对应的 bridge.js。这样的做法有以下的好处： 双方的代码统一维护，避免出现版本分裂的情况。有更新时，只要由客户端更新 SDK 即可，不会出现版本兼容的问题 App 的接入十分方便，只需要按文档接入最新版本的 SDK，即可直接运行整套 Hybrid 方案，便于在多个 App 中快速的落地 H5 端无需关注，这样有利于将 bridge 开放给第三方页面使用。 注意：协议的调用，一定是需要确保执行在 bridge.js 成功注入后。由于客户端的注入行为属于一个附加的异步行为，从 H5 方很难去捕捉准确的完成时机，因此这里需要通过客户端监听页面完成后，基于上面的回调机制通知 H5 端，页面中即可通过 window.addEventListener(‘bridgeReady’,e=&gt;{})进行初始化。 (四) App 中 H5 的接入方式将 H5 接入 App 中通常有两种方式： (1) 在线 H5，这是最常见的一种方式。我们只需要将 H5 代码部署到服务器上，只要把对应的 URL 地址 给到客户端，用 WebView 打开该 URL，即可嵌入。该方式的好处在于： 独立性强，有非常独立的开发/调试/更新/上线能力 资源放在服务器上，完全不会影响客户端的包体积 接入成本很低，完全的热更新机制 但相对的，这种方式也有对应的缺点： 完全的网络依赖，在离线的情况下无法打开页面； 首屏加载速度依赖于网络，网络较慢时，首屏加载也较慢； 通常，这种方式更适用在一些比较轻量级的页面上，例如一些帮助页、提示页、使用攻略等页面。这些页面的特点是功能性不强，不太需要复杂的功能协议，且不需要离线使用。在一些第三方页面接入上，也会使用这种方式，例如我们的页面调用微信 JS-SDK。 (2) 内置包 H5，这是一种本地化的嵌入方式，我们需要将代码进行打包后下发到客户端，并由客户端直接解压到本地储存中。通常我们运用在一些比较大和比较重要的模块上。其优点是： 由于其本地化，首屏加载速度快，用户体验更为接近原生； 可以不依赖网络，离线运行； 但同时，它的劣势也十分明显： 开发流程/更新机制复杂化，需要客户端，甚至服务端的共同协作 会相应的增加 App 包体积 这两种接入方式均有自己的优缺点，应该根据不同场景进行选择 内容来源: Hybrid App 技术解析 – 原理篇 相关链接推荐:Hybrid 应用中 H5 与 Native 通信的那点事儿Hybrid App 技术解析 – 实战篇什么是 Native、Web App、Hybrid、React Native 和 Weex？JSBridge 深度剖析例子","link":"/2020/01/05/Blog-about-learning-9/"},{"title":"Web项目开发及线上部署","text":"Web项目开发及线上部署","link":"/2020/06/08/Blog-about-learning-98/"},{"title":"java 开发环境搭建","text":"javajava JDKApache MavenApache Maven 下载安装配置 IntelliJ IDEANavicatTomcat 相关资料Maven 环境配置Java 开发环境配置Java SE Downloads2020.1.2 IDEA 正版激活，IntelliJ IDEA 注册码，2020.1.2 IDEA 激活码最新 IntelliJ 2020.1.2 IDEA 激活码，IDEA 注册码，持续更新中IntelliJ IDEA安装与使用最新版IntelliJ IDEA2019.3 破解教程(2020.04.01更新)使用IntelliJ IDEA 前最好修改的配置Navicat Premium 15安装教程(完整激活版)如何使用JavaScript对数字数组进行排序？","link":"/2020/06/08/Blog-about-learning-99/"},{"title":"书单","text":"封面图片出处Pexels 上的 Wendy Wei 拍摄的照片 《富爸爸穷爸爸》、《小狗钱钱》、《财务自由之路》、《邻家的百万富翁》、《巴比伦最富有的人》《财报就像一本故事书》、《手把手教你读财报》、《投资中最简单的事》、《投资中最重要的事》《巴菲特的护城河》、《学习估值，轻松投资》、《指数基金投资指南》、《穷查理宝典》《怎样选择成长股》、《彼得林奇的成功投资》、《证券分析》、《聪明的投资者》、《影响力》《估值》、《价值评估》、《精益创业》、《资本论》、《事实》、《终身成长》、《枪炮、病菌与钢铁》《清单革命》、《了不起的盖茨比》、《HTML5 与 CSS3 基础教程》（第 8 版）、《时间简史》《父母效能训练手册》、《正面管教》、《不成熟的父母》、《深度工作》、《12 个工作习惯》《优秀的绵羊》、《人类群星闪耀时》、《古罗马的日常生活》、《如何假装懂音乐》、《故事知道怎么办》《陪伴式成长》、《教出乐观的孩子》、《游戏力》、《教养的迷思》、《原生家庭》、《不吼不叫》《乔布斯的魔力演讲》、《刻意练习：如何从新手到大师》、《学习之道》、《练习的心态：如何培养耐心、专注和自律》《如何高效记忆》（原书第2版）、《如何高效阅读》、《如何高效学习》、《如何成为一个学习忍者》、《精进：如何成为一个厉害的人》、《麦肯锡工作法》、《习惯的力量》、《自控力》、《高效能人士的七个习惯》、《聪明人用的方格笔记》、《杀死一只知更鸟》 《君主论》、《潜规则》、《血酬定律》、《爱的博弈》、《洞穴奇案》、《纯真告别》、《飘》、《平凡的世界》 《瓦尔登湖》、《艺术的故事》、《从一到无穷大》、《万古江河》、《乡土中国》《Apache Cordova实战》《霍乱时期的爱情》","link":"/2019/12/28/Book-list/"},{"title":"小狗钱钱","text":"财富法则 一开始，必须明确金钱对你的意义。 确立最重要的目标。为什么我们必须特别强调在我们“长长的愿望清单中”的某几个目标？ 为什么梦想储蓄罐和梦想相册很重要？我们的潜意识如何支持着我们？我们为此需满足哪些前提条件？ 为什么仅有较高的收入绝不可能解决我们的财务难题？ 如何使我们不放弃已经作出的决定——想象的艺术。 总会有一些人想要阻止我们实现自己的目标，阻力甚至经常来自我们的亲戚朋友，但还是有一些不让自己迷失的方法。 为什么一本成功日记能促使我们的收入不断地增加？为什么自信是最关键的因素？ 人们如何将自己最大的爱好作为职业，并由此再次大幅度提高自己的收入？ 重要性和紧迫性之间有什么区别？如何保证在任何情况下都不偏离制订的目标？ 付诸实施的关键：72 小时规定。 如何以轻松的方式挣到许多钱？ 关于如何处理债务的 4 个忠告。 一只下金蛋的鹅的故事——人们如何量入为出。 如何正确使用银行并使之成为一种乐趣？ 幸福的本质以及我们如何才能获得更多的幸福。 爱钱有什么不对吗？保险箱里留多少现金比较合适？ “金钱是‘中性’的”指的是什么意思？钱与幸福之间有什么联系？ 归还我们的一部分所得是十分重要的。（做慈善和公益事业。） 对待恐惧的最佳方式。成功日记所起的作用。 增加金钱的最有效途径之一：投资俱乐部。保证成功的 5 条规定。 白手起家的魔法。 适用于所有投资的 3 条最重要的规定。 什么是股票？股票是如何运作的？收益是如何产生的？你是否适合股票投资？ 为什么偶尔放弃熟悉的环境、从事我们畏惧的事情很重要？ 怎样确保每年获得 12%以上的利息？近乎完美的投资形式和投资战略是什么？ 为什么股票基金是保险的，而且可以为你带来丰厚的利润？挑选保险的基金的 3 个注意事项。 投资基金为什么很简单？ 在投资基金的情况下，你的钱变成了什么——利滚利的力量。 浮动利率：如何平衡风险和赢利。 如何轻松地计算利息与复利？ 当汇率下跌时应当做什么？如何在这种情况下获得高额利润？ 用基金获得可靠的高利润的前提。 通货膨胀的真正含义以及如何轻松计算出它对财产的影响。如何使通货膨胀成为你最好的朋友——当你正确选择投资对象时。 金钱对我们生活中的其他领域会产生什么影响？当我们更多地研究金钱这个题目时，将会发生怎样的变化？ 并非困难使我们放弃，而是因为我们放弃，才显得如此困难 钱的数目并不是决定性因素，更重要的是我们怎么来使用它。我们首先必须学会量入为出，只有这样，我们才有能力获得更多的钱。 有一只海鸥曾经对我说过：‘在你展翅飞翔之前，你就必须相信自己能到达目的地。 “让我们痛心的阻力总是从我们最想不到的地方来的。” 你是否能挣到钱，最关键的并不是你有没有好点子，也不是你有多聪明，而是你的自信程度。 建立自信的方法：准备一个本子，然后把所有做成功的事情记录进去。你最好每天都做这件事，每次都写至少 5 条你的个人成果，任何小事都可以。 为别人解决一个难题，那么你就能赚到许多钱。把精力集中在你知道的、能做的和拥有的东西上。 不去寻找机会的人，最多不过是在走运的时候捡到天上掉下来的馅饼。 无论在什么时候都不能把希望只寄托在一份工作上，它持续的时间不会像你设想的那么长，所以你要立即寻找另一份替代的工作。你肯定会遇到一些困难,这些困难是你现在还难以预料的,情况顺利的时候，人人都能挣到钱。只有在逆境中，一切才能见分晓. 首先，在遇到困难的时候，仍然要坚持自己的想法。一切正常的时候，每个人都能做到这一点。只有当真正的困难出现时才能见分晓。只有少数人能坚定不移地贯彻自己的计划。那些非常成功的人，甚至有能力在他们最困难的时候作出最杰出的表现。 72 小时规定当你决定做一件事情的时候，你必须在 72 小时之内完成，否则你很可能永远不会再做了。 解决负债问题:欠债的人应当毁掉所有的信用卡。应当尽可能少地偿还贷款 —— 分期付款。针对消费贷款，将不用于生活的那部分钱的一半存起来，另一半用于偿还贷款。将扣除生活费后剩下的钱的一半存起来，剩下的一半用于支付消费贷款。最好根本不申请消费贷款。这真的有必要吗？ 把钱存起来，让他为你生产价值。 幸运其实只是充分准备加上努力工作的结果。 勇敢的人也会害怕，一个人虽然害怕却仍然敢于前进，这才叫勇敢。 金钱会暴露一个人的本性 金钱能成为我们生活中非常强大的助推力。金钱可以在一定程度上提高我们的生活水平——生活的许多方面都是以钱为基础的。有了钱，我们就更容易实现我们的目标和梦想。 没有人能强迫你做你不愿意做的事情。只有你自己才能强迫自己去做。 最珍贵的礼物是我们自己争取来的。克服了丢面子的恐惧，世界就会向你敞开大门！ 当你朝着积极的目标去思考的时候，就不会心生畏惧。 挑选基金时的注意事项：基金应该至少有 10 年历史。应该选择大型的跨国股票基金。对基金的走势图进行比较。 72 公式72 除以投资的年利润百分比，得出的数字就是这笔钱翻一倍所要的年数。计算通货膨胀,在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。72 除以通货膨胀率计算。 不要为失去的东西而忧伤，而要对拥有它的时光心存感激。","link":"/2020/02/06/Book1/"},{"title":"JavaScript语言精粹","text":"页码3有资源误删 精华分析 JavaScript好的想法：函数、弱类型、动态对象和对象字面量表示法。坏的想法：全局变量。 JSlint、ESLint 语法注释书中建议避免使用 /* */ 注释，而用 // 注释代替。例如： 123/*var rm_a = /a*/.match(s);*/ 对象语句JavaScript 可以通过条件语句（if 和 switch），循环语句（while、for 和 do）、强制跳转语句（break、return 和 throw）和函数调用来改变这个执行序列。 函数继承数组正则表达式方法代码风格优美的特性附录糟粕鸡肋JSLint语法图JSON// 页码 26","link":"/2020/08/04/Book10/"},{"title":"深入解析CSS","text":"盒模型和 border-box 盒模型指的是网页元素的结构。当指定一个元素的宽度或高度时，便设置了元素内容的尺寸——任何内边距（padding）、边框（border）、外边距（margin）都会基于它叠加。 给元素设置 box-sizing: border-box会改变盒模型，使其获得更好的可预测性。指定宽度或高度时，会设置整个元素尺寸，包括内边距和边框。 基础回顾层叠层叠指的就是这一系列规则。它决定了如何解决冲突，是CSS语言的基础。 层叠会依据三种条件解决冲突。 样式表的来源 选择器优先级 源码顺序 层叠的规则是按照这种顺序来考虑的。 以下是CSS中的一行。它被称作一个声明。该声明由一个属性（color）和一个值（black）组成。 1color : black; 包含在大括号内的一组声明被称作一个声明块。声明块前面有一个选择器。 1234body{ color : black; font-family: Helvetica;} 选择器和声明块一起组成了规则集（ruleset）。@规则（at-rules）是指用“@”符号开头的语法。比如@import规则或者@media查询。 优先级按照由高到低排列如下所示 作者的！important（带！important的样式） 作者（编写的样式） 用户代理（浏览器默认样式） 浏览器将优先级分为两部分：HTML的行内样式和选择器的样式。 用 HTML 的 style 属性写样式，这个声明只会作用于当前元素。实际上行内元素属于“带作用域的”声明，它会覆盖任何来自样式表或者&lt;style&gt;标签的样式。行内样式没有选择器，因为它们直接作用于所在的元素。 选择器优先级的准确规则如下。 如果选择器的ID数量更多，则它会胜出（即它更明确）。 如果ID数量一致，那么拥有最多类的选择器胜出。 如果ID数量一致，那么拥有最多类的选择器胜出。 注意：伪类选择器（如：hover）和属性选择器（如[type=&quot;input&quot;]）与一个类选择器的优先级相同。通用选择器（＊）和组合器（&gt;、+、~）对优先级没有影响。 优先级标记 通常最好让优先级尽可能低，这样当需要覆盖一些样式时，才能有选择空间。 可以通过控制源码顺序，来给特殊链接添加样式。如果两个冲突选择器的优先级相同，则出现得较晚的那个胜出。 链接加样式要按照一定的顺序书写选择器。这是因为源码顺序影响了层叠。 12345678910111213a:link{ color: blue; text-decoration: none;}a:visited{ color: purple;}a:hover{ text-decoration: underline;}a:active{ color: red;} 优先级相同时，后出现的样式会覆盖先出现的样式。如果一个元素同时处于两个或者更多状态，最后一个状态就能覆盖其他状态。如果用户将鼠标悬停在一个访问过的链接上，悬停效果会生效。如果用户在鼠标悬停时激活了链接（即点击了它），激活的样式会生效。 这个顺序的记忆口诀是“LoVe/HAte”。即link（链接）、visited（访问）、hover（悬停）、active（激活）。 注意，如果将一个选择器的优先级改得跟其他的选择器不一样，这个规则就会遭到破坏，可能会带来意想不到的结果。 如果一个声明在层叠中“胜出”，它就被称作一个层叠值。元素的每个属性最多只有一个层叠值。如果CSS为同一个属性指定了不同的值，层叠最终会选择一个值来渲染元素，这就是层叠值。 层叠值——作为层叠结果，应用到一个元素上的特定属性的值。 两条经验法则 在选择器中不要使用ID。就算只用一个ID，也会大幅提升优先级。 不要使用！important。 关于重要性的一个重要提醒 当创建一个用于分发的JavaScript模块（比如NPM包）时， 正确的做法是在包里包含一个样式表。如果组件需要频繁修改样式，通常最好用JavaScript给元素添加或者移除类。这样用户就可以在使用这份样式表的同时，在不引入优先级竞赛的前提下，按照自己的喜好选择编辑其中的样式。 继承 默认情况下，只有特定的一些属性能被继承，它们主要是跟 文本相关的属性：color、font、font-family、font-size、font-weight、font-variant、font-style、line-height、letter-spacing、text-align、text-indent、text-transform、white-space以及word-spacing。 列表属性：list-style、list-style-type、list-style-position以及list-style-image。表格的边框属性border-collapse和border-spacing也能被继承。 注意，这些属性控制的是表格的边框行为，而不是常用于指定非表格元素边框的属性。 使用开发者工具是最好的追踪方式 特殊值使用inherit关键字想用继承代替一个层叠值，可以用inherit关键字，可以用它来覆盖另一个值，这样该元素就会继承其父元素的值。 initial关键字撤销作用于某个元素的样式，可以用initial关键字来实现。 说明声明display: initial等价于display: inline。不管应用于哪种类型的元素，它都不会等于display: block。这是因为initial重置为属性的初始值，而不是元素的初始值。inline才是display属性的初始值。 简写属性简写属性会默默覆盖其他样式避免在&lt;body&gt;元素的通用样式以外使用font。 总结 控制选择器的优先级。 不要混淆层叠和继承。 某些属性会被继承，包括文本、列表、表格边框相关的属性。 不要混淆initial和auto值。 简写属性要注意TRouBLe的顺序，避免踩坑。 相对单位emCSS为网页带来了后期绑定（late-binding）的样式：直到内容和样式都完成了，二者才会结合起来。 响应式——在CSS中指的是样式能够根据浏览器窗口的大小有不同的“响应”。 96px通常等于一个物理英寸的大小。 em 是最常见的相对长度单位，适合基于特定的字号进行排版。在CSS中，1em等于当前元素的字号，其准确值取决于作用的元素。 这里设置内边距的值为1em。浏览器将其乘以字号，最终渲染为16px。这一点很重要：浏览器会根据相对单位的值计算出绝对值，称作计算值（computedvalue）。 em 的好处。可以定义一个元素的大小，然后只需要改变字号就能整体缩放元素。 提示如果知道字号的像素值，但是想用em声明，可以用一个简单的公式换算：用想要的像素大小除以父级（继承）的像素字号。比如，想要一个10px的字体，元素继承的字体是12px，则计算结果是10/12 = 0.8333em。如果想要一个16px的字体，父级字号为12px，则计算结果是16/12 = 1.3333em。 对大多数浏览器来说，默认的字号为16px。准确地说，medium关键字的值是16px。 rem当浏览器解析HTML文档时，会在内存里将页面的所有元素表示为DOM（文档对象模型）。它是一个树结构，其中每个元素都由一个节点表示。&lt;html&gt;元素是顶级（根）节点。它下面是子节点，&lt;head&gt;和&lt;body&gt;。再下面是逐级嵌套的后代节点。 根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但是html的优先级相当于一个类名，而不是一个标签。 rem是root em的缩写。rem不是相对于当前元素，而是相对于根元素的单位。 我一般会用rem设置字号，用px设置边框，用em设置其他大部分属性，尤其是内边距、外边距和圆角（不过我有时用百分比设置容器宽度）。 提示拿不准的时候，用rem设置字号，用px设置边框，用em设置其他大部分属性。 将浏览器的默认字号16px 缩小为10px的缺点： 我们被迫写很多重复的代码。10px对大部分文字来说太小了，所以需要覆盖它，最后就得给段落设置1.4rem，给侧边栏设置1.4rem，给导航链接设置1.4rem，等等。这样一来，代码容易出错的地方更多；当需要修改代码时，要改动的地方更多；样式表的体积也更大。 这种做法的本质还是像素思维。虽然在代码里写的是1.4rem，但是在心里仍然想着“14像素”。在响应式网页中，需要习惯“模糊”值。1.2em到底是多少像素并不重要，重点是它比继承的字号要稍微大一点。如果在屏幕上的效果不理想，就调整它的值，反复试验。这种方式同样适用于像素值。（在第13章中，我们将进一步研究具体规则来改进这种方法。） 1234567891011121314151617/* 设置真正的默认字号 */:root { /* 使用 HTML 选择器 */ font-size: 0.875em; /*14/16(理想的px/继承px) = 0.875*/}.panel { padding: 1em; border-radius: 0.5em; border: 1px solid #999;}.pannel &gt; h2 { margin-top: 0; /* 将多余空间移除 */ font-size: 0.8rem; font-weight: bold; text-transform: uppercase;} 12345678&lt;div class=&quot;panel&quot;&gt; &lt;h2&gt;ssss&lt;/h2&gt; &lt;div class=&quot;panel-body&quot;&gt; fjkdsljfkjsd;fdsklf &lt;a href=&quot;/batch-size&quot;&gt;smalljfjdslk&lt;/a&gt; fsdlfk; &lt;/div&gt;&lt;/div&gt; 媒体查询，即@media规则，可以指定某种屏幕尺寸或者媒体类型（比如，打印机或者屏幕）下的样式。这是响应式设计的关键部分。 123456789101112131415:root { font-size: 0.75em;}@media (min-width: 800px) { :root { font-size: 0.875em; }}@media (min-width: 1200px) { :root { font-size: 1em; }} 缩放单个组件 123456789101112131415161718.panel { font-size: 1rem; padding: 1em; border: 1px solid #999; border-radius: 0.5em;}.panel &gt; h2{ margin-top: 0; font-size: 0.8em; font-weight: bold; text-transform: uppercase;}/* 放大 */.panel.large { font-size: 1.2rem;} 视口——浏览器窗口里网页可见部分的边框区域。它不包括浏览器的地址栏、工具栏、状态栏。 vh：视口高度的1/100。 vw：视口宽度的1/100。 vmin：视口宽、高中较小的一方的1/100（IE9中叫vm，而不是vmin）。 vmax：视口宽、高中较大的一方的1/100（本书写作时IE和Edge均不支持vmax） 比如，50vw等于视口宽度的一半，25vh等于视口高度的25%。vmin取决于宽和高中较小的一方，这可以保证元素在屏幕方向变化时适应屏幕。在横屏时，vmin取决于高度；在竖屏时，则取决于宽度。 视口相对长度非常适合展示一个填满屏幕的大图。我们可以将图片放在一个很长的容器里，然后设置图片的高度为100vh，让它等于视口的高度 提示相对视口的单位对大部分浏览器而言是较新的特性，因此当你将它跟其他样式结合使用时，会有一些奇怪的bug。可在Can I Use网站中检索Viewportunits: vw, vh, vmin, vmax中的“Known Issues”。 使用vw定义字号,这样做的好处在于元素能够在这两种大小之间平滑地过渡，这意味着不会在某个断点突然改变。当视口大小改变时，元素会逐渐过渡。 使用calc()定义字号，加号和减号两边必须有空白。 123:root { font-size: calc(0.5em + 1vw);} 我们不用媒体查询就实现了大部分的响应式策略。省掉三四个硬编码的断点，网页上的内容也能根据视口流畅地缩放。 无单位的数值和行高有些属性允许无单位的值（即一个不指定单位的数）。支持这种值的属性包括line-height、z-index、font-weight（700等于bold,400等于normal，等等）。 有些属性允许无单位的值（即一个不指定单位的数）。支持这种值的属性包括line-height、z-index、font-weight（700等于bold,400等于normal，等等）。 怪异特性：当一个元素的值定义为长度（px、em、rem，等等）时，子元素会继承它的计算值。当使用em等单位定义行高时，它们的值是计算值，传递到了任何继承子元素上。如果子元素有不同的字号，并且继承了line-height属性，就会造成意想不到的结果，比如文字重叠。 长度——一种用于测量距离的CSS值的正式称谓。它由一个数值和一个单位组成，比如5px。长度有两种类型：绝对长度和相对长度。百分比类似于长度，但是严格来讲，它不是长度。 使用无单位的数值时，继承的是声明值，即在每个继承子元素上会重新算它的计算值。这样得到的结果几乎总是我们想要的。 相关资料深入解析CSS代码库","link":"/2020/06/07/Book11/"},{"title":"Vue.js 实战","text":"源码Vue.js 实战","link":"/2020/10/31/Book13/"},{"title":"CSS 权威指南 （第三版）","text":"第1章 CSS 和文档Web 的衰落随着 HTML 的发展，渐渐的出现了一些需求，迫于压力开始出现了诸如 &lt;font&gt;&lt;big&gt;之类的标记元素。原来描述结构的语言开始描述外在表现了。 一片混乱为了页面设计而被迫牺牲结构以及含义。 非结构化页面使得建立内容索引极为困难。 缺乏结构性会降低可访问性。 高级页面表现只能应用于某种文档结构。 结构化标记更易于维护。 块级元素行内元素XHTML 层次结构要求：行内元素可以继承块元素。","link":"/2020/11/28/Book14/"},{"title":"富爸爸穷爸爸","text":"增加资产：打工、创业、投资 提升打工的能力是「增加资产」最有效的方法，所谓的原始积累，提升打工的能力换句话说就是提升专业能力、人际关系、职业素养等等， 减少负债：不能给你带来现金流入的都是负债。不买车子 致富的核心技能有会计、投资、营销、法律， 富人不为钱工作 普通雇员的思维 《富爸爸，穷爸爸》这本书有何价值？一个 23 岁的年轻人，手上有 2 万有什么好的理财建议？每个月有 5000 元结余，买基金定投好还是扔余额宝？","link":"/2020/01/29/Book2/"},{"title":"微信小程序：开发入门及案例详解","text":"第 6 章案例分析：豆瓣电影开放平台：淘宝开放平台、腾讯开发者平台、高德 API、百度 API 等。 主要使用正在热映、即将上映、电影条目信息这 3 个 API 接口： 正在热映 API：https://api.douban.com/v2/movie/in_theaters? city=北京即将上映 API: https://api.douban.com/v2/movie/in_theaters?start=0&amp;count=20电影条目信息 API：https://api.douban.com/v2/movie/subject/1324043 由于豆瓣 API 不能支持非浏览器客户端发起的请求，非浏览器客户端需要下载对应的 SDK 来请求 API，所以小程序在微信中打开时不能直接调用豆瓣 API 接口，所以我们利用自己的服务器做了一次请求跳转。 技术架构借用服务端三层架构模式，一个项目可分为表现层、业务逻辑层、数据访问层。 lib：放置一些最底层、第三方库，如 jquery、seajs、qrcode、echarts 等，通常 lib 层是全公司共用一套。豆瓣电影中由于没有第三方库文件，或者说小程序框架本身就是一个第三方库，所以没有 lib 层。 common：放置和项目相关的一些公共代码，如转码、工具包、公共样式设置等。根据业务需要可以将 widgets 和 common 合并为一个目录。 service：业务逻辑层，按业务类型整合相关的方法，向上暴露需要的接口方法，比如 a 页面需要调用登录和列表信息，b 页面需要调用登录和详情信息，那么这两个页面中的登录接口就会被调用两次，这时我们便可以将这种和业务紧密相关的接口调用方法封装起来，作为一个服务暴露给上层应用。业务逻辑层能降低表现层对业务的关注，让更多精力关注在页面渲染、页面交互等功能上。 widgets：一些通用的带 UI 的小组件，如 pop、header、购物车图标等等，它和 common 层有些类似，但是相对 common 层，widgets 具备 UI 界面和一个闭环的交互功能。由于业务问题，在豆瓣电影实例中没有 widgets 目录。 pages：表现层，一般表现层中一个文件夹对应一个页面所涉及的所有资源。 这种分层方式是前端项目常见的架构分层方式，适用于任何原则，同时按照组件化原则我们通常会把一个组件、包、页面所涉及的所有资源放置在一个目录中。 basestlye：一些项目公共的基本样式，被 app.wxss 引入，当前项目中没有公共样式，内容为空。 utils：基础工具包，项目中我们把系统 toast 进行了一层代理，封装到对应方法中，如果以后需要改变 toast 行为，我们便可以直接修改代码，而不用在每个调用页面进行修改。 detail：详情页相关资源。home：首页相关资源。douban：请求豆瓣接口的相关逻辑代码。 公共模块开发 在 JavaScript 整体编码中一般 handle 是需要对外暴露的公共方法的句柄，写在模块前面，_fn 是私有方法，写在后面，这样便于他人阅读代码。","link":"/2020/02/02/Book3/"},{"title":"HTML5 与 CSS3 基础教程（第8版）","text":"前言W3C 与 WHATWG如果你想仔细查看这些规范（推荐你这样做），可访问下面列出的这些规范最新版本的网址。 HTML5（W3C）http://www.w3.org/TR/html5/ HTML5.1（W3C）http://www.w3.org/TR/html51/ 开发中的 HTML 标准（WHATWG）http://www.whatwg.org/specs/web-apps/current-work/multipage/ CSS 的规范http:// www.w3.org/standards/techs/css#w3c_all。 HTML4 和 HTML5 的区别http:// www.w3.org/TR/html5-diff 123456DoctypeHTML语法要求指定doctype，以确保浏览器以标准模式呈现页面。该文档类型没有其他用途。[DOCTYPE]HTML语法的doctype声明&lt;!DOCTYPE html&gt;不区分大小写。HTML早期版本中的文档类型更长，因为HTML语言基于SGML，因此需要引用DTD。情况不再如此，仅需要doctype才能为使用HTML语法编写的文档启用标准模式。浏览器已经为此执行了操作 &lt;!DOCTYPE html&gt;。为了支持无法生成首选的简短doctype的旧式标记生成器，&lt;!DOCTYPE html SYSTEM &quot;about:legacy-compat&quot;&gt;HTML语法中允许使用doctype 。HTML语法中也允许（但不鼓励使用）用于HTML 4.0，HTML 4.01，XHTML 1.0以及XHTML 1.1的严格doctype。在XML语法中，可以使用任何doctype声明，也可以将其完全省略。具有XML媒体类型的文档始终以标准模式处理。 CSS3 变换、动画和过渡效果。要了解更多 信息，参见 www.htmlcssvqs.com/resources/。CSS3 中新的布局模型，如 FlexBox、Grid 等。这些技术致力于改变我们对页面进行 布局的方法（前提是规范进一步发展， 浏览器的支持程度更高一些）。参见 Zoe Mickley Gillenwater 的演示文档（www. slideshare.net/zomigi/css3-layout）和 Peter Gasston 的文章（www.netmagazine.com/ features/pros-guide-css-layouts）。 1234567891011&lt;header class=&quot;masthead&quot; role=&quot;banner&quot;&gt; ... &lt;nav role=&quot;navigation&quot;&gt; &lt;ul class=&quot;nav-main&quot;&gt; &lt;li&gt;&lt;a href=&quot;/&quot; class=&quot;current- ➝ page&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/about/&quot;&gt;About&lt;/a&gt; ➝&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/contact/&quot;&gt;Contact ➝ &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; ...&lt;/header&gt; Bootstrap 上 123&lt;div class=&quot;alert alert-primary&quot; role=&quot;alert&quot;&gt; A simple primary alert—check it out!&lt;/div&gt; html 里面的 role 本质上是增强语义性，当现有的 HTML 标签不能充分表达语义性的时候，就可以借助 role 来说明。通常这种情况出现在一些自定义的组件上，这样可增强组件的可访问性、可用性和可交互性。role 的作用是描述一个非标准的 tag 的实际作用。比如用 div 做 button，那么设置 div 的 role=“button”，辅助工具就可以认出这实际上是个 button。（这段解释来自于https://blog.csdn.net/mxk4869/article/details/88944927） 本书主页：www.htmlcssvqs.com/","link":"/2019/12/26/Book4/"},{"title":"JavaScript 高级程序设计","text":"第 20 章 JSONJSON 是 JavaScript 的一个严格的子集，利用了 JavaScript 中的一些模式来表示结构化数据。JSON 是一种数据格式，JSON 并不从属于 JavaScript。而且，并不是只有 JavaScript 才使用 JSON，毕竟 JSON 只是一种数据格式。很多编程语言都有针对 JSON 的解析器和序列化器。 语法JSON 的语法可以表示以下三种类型的值。 简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但JSON 不支持 JavaScript 中的特殊值 undefined。 对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。 数组：数组也是一种复杂数据类型，表示的是一组有序的值的列表，可以通过数值索引来访问其中的值。数组的值也可以是任意类型 ———— 简单值、对象或数组。 JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴。 简单值最简单的 JSON 数据形式就是简单值。例如，下面这个值是有效的 JSON 数据： 125;&quot;Hello world!&quot;; JavaScript 字符串与 JSON 字符串的最大区别在于，JSON 字符串必须使用双引号（单引号会导致语法） 对象12345678910111213141516var person = { name : &quot;Nicholas&quot;, age : 29}// JSON 中的对象要求给属性加引号，实际上，在 JavaScript 中，前面的对象字面量完全可以写成下面这样：var person = { &quot;name&quot; : &quot;Nicholas&quot;, &quot;age&quot; : 29};// JSON 表示上述对象的方式如下：{ &quot;name&quot; : &quot;Nicholas&quot;, &quot;age&quot; : 29} 与 JavaScript 的对象字面量相比，JSON 对象有两个地方不一样。 没有声明变量（JSON 中没有变量的概念）。 没有末尾的分号（因为这不是 JavaScript 语句，所以不需要分号）。对象的属性必须加双引号，这在 JSON 中是必须的。 对象中嵌套对象： 12345678{ &quot;name&quot; : &quot;Nicholas&quot;, &quot;age&quot; : 29, &quot;school&quot; : { &quot;name&quot; : &quot;Merrimack College&quot;, &quot;location&quot; : &quot;North Andover, MA&quot; }} 相关资料 红宝书第四版精读训练营 红宝书第四版精读训练营代码库","link":"/2020/01/24/Book5/"},{"title":"PWA 入门与实践","text":"性能评估工具 Lighthouse。 初识 PWA Chrome 在 72 版本中，对 Android 平台使用了 Trusted Web Activities(TWA) 和 Digital Asset Links(DAL)，将 Web 结合到了应用程序中，并支持发布到 Googleplay 商店。 2018 年 6 月，微软也宣布 PWA 可以基于 UWP 发布到 Microsoft Store 中，作为应用程序使用。 HTTP ServerPWA 必须运行在 HTTPS 环境或者 127.0.0.1 的本地服务环境下，所以在开发、测试的过程中需要有一个本地的 HTTP Server，这里建议使用 http-server，它是一个基于 Node.js 环境的简单、零配置的 HTTP Server 命令行工具。 12// -p 指定端口http-server -p 9000 调试工具调试工具建议使用 Chrome 的内置工具 DevTools。 网络层拦截图片1234567// 拦截请求self.addEventListener(&quot;fetch&quot;, (event) =&gt; { if (/network\\.jpg$/.test(event.request.url)) { // 返回响应 return event.respondWith(fetch(&quot;images/pwa.jpg&quot;)); }}); 定制 404 页面12345678910111213self.addEventListener(&quot;fetch&quot;, (event) =&gt; { if (event.request.mode == &quot;navigate&quot;) { return event.respondWith( fetch(event.request).then((res) =&gt; { // 判断状态 if (res.status == 404) { return fetch(&quot;custom404.html&quot;); } return res; }) ); }}); 离线可用1234567891011121314151617181920212223242526272829303132333435363738394041424344const CACHE_NAME = &quot;pwa&quot;; // 定义缓存名称self.addEventListener(&quot;install&quot;, (event) =&gt; { self.skipWaiting(); event.waitUntil( caches.open(CACHE_NAME).then((cache) =&gt; cache.addAll([ // 在 Service Worker 安装时，将相关资源进行缓存 &quot;images/network.jpg&quot;, &quot;custom404.html&quot;, &quot;/&quot;, &quot;index.html&quot;, ]) ) );});self.addEventListener(&quot;fetch&quot;, (event) =&gt; { return event.respondWith( fetch(event.request) .then((res) =&gt; { if (event.request.mode == &quot;navigate&quot; &amp;&amp; res.status == 404) { return fetch(&quot;custom404.html&quot;); } return res; }) .catch(() =&gt; { // 离线状态下的处理 return caches.open(CACHE_NAME).then((cache) =&gt; { // 从 Cache 里面取资源 return cache.match(event.request).then((response) =&gt; { if (response) { return response; } return cache.match(&quot;custom404.html&quot;); }); }); }) );});self.addEventListener(&quot;activate&quot;, (event) =&gt; { clients.claim();}); 预备知识JavaScript Module1&lt;script type=&quot;module&quot;&gt;&lt;/script&gt; 当项目变大时，代码也变得难以维护。们直接面临着一系列问题，包括： 命名空间冲突：每一个脚本都暴露在全局作用域下，很可能造成命名冲突，例如 JQuery 和 Zepto 都使用 window.$。 依赖关系不清晰：对于脚本的依赖、版本和加载顺序无法合理地管理。 JavaScript 的模块化发展过程为从无模块化到 Common.js 规范，再到 AMD 规范、CMD 规范、UMD 规范。 Common.js 规范是 Node.js 的模块化规范，核心是通过 require 方法加载模块，通过 module. exports 来导出模块。浏览器无法直接使用，需要依赖于打包工具进行支持，如 webpack。 &gt; AMD 规范与 Common.js 规范的主要区别是异步加载模块。 &gt; CMD 规范和 AMD 规范类似，主要区别是依赖后置，模块加载完再执行。 &gt; UMD 规范则是 AMD 规范和 Common. js 规范的结合。这三种规范在导入相应规范库的前提下，可以直接在浏览器执行。 &gt; 以上模块规范各有优缺点，最终整合为浏览器原生支持的 ES6 Module 规范，也就是本章将要介绍的 JavaScript Module。 JavaScript Module 也称为 ES Module 或 ECMAScript Module。模块化的主要共同点是允许导入和导出模块。之前的几种模块化方案都是社区实现的，并不是 JavaScript 的标准规范，而 JavaScript Module 模块化方案是一个真正的规范，是可以直接运行在浏览器中的。 JavaScript Module 主要使用到了 export 和 import 命令。在模块内，可以使用export 关键字导出 const、函数或任何其他变量绑定或声明，如 utils.mjs： 1234export const sayLen = (str) =&gt; `字符串长度为 ${str.length}`;export function insertSpace(str) { return str.split(&quot;&quot;).join(&quot; &quot;);} 要使用模块，可以用import 关键字将要使用的模块导入。例如，我们在 index.mjs 中使用 utils.mjs 模块中的 sayLen 和 insertSpace 方法： 1234import { sayLen, insertSpace } from &quot;./utils.mjs&quot;;console.log(sayLen(&quot;你好&quot;)); // 字符串长度为 2console.log(insertSpace(&quot;hello&quot;)); // hello export 关键字模块以文件来承载，模块内的所有变量外部是无法访问的，需要使用 export 关键字进行输出才可以供外部访问。有以下几种导出方式。 单个变量或函数导出123456// utils.mjsexport const a = 1;export const b = 2;export function say() { console.log(&quot;say!&quot;);} 以组对象的方式导出12345678// utils.mjsconst a = 1;const b = 2;function say() { console.log(&quot;say!&quot;);}export { a, b, say }; 使用 as 对导出的变量重命名12345678// utils.mjsconst a = 1;const b = 2;function say() { console.log(&quot;say!&quot;);}export { a as varA, b as varB, say as FnSay }; 可以使用 default 默认导出1234// utils.mjsexport default function say() { console.log(&quot;say!&quot;);} import 关键字当需要使用模块文件时，要通过 import 关键字进行导入操作，来访问模块文件 export 的值。 按变量名导入123// index.mjsimport { a, b, say } from &quot;./utils.mjs&quot;;say(); 导入重命名12import { a, b, say as FnSay } from &quot;./utils.mjs&quot;;FnSay(); 可以使用 * 进行全量导入12345import * as utils from &quot;./utils.mjs&quot;;utils.say();utils.a;utils.b; 导入 export default 类型，可以随意命名12345678// utils.mjsexport default function say() { console.log(&quot;say!&quot;);}// index.mjsimport s from &quot;./utils.mjs&quot;;s(); 同时导入 default 和其他接口1234567891011// utils.mjsconst a = 1;const b = 2;export default function say() { console.log(&quot;say!&quot;);}export { a, b };// index.mjsimport say, { a, b } from &quot;./utils.mjs&quot;;import say, * as utils from &quot;./utils.mjs&quot;; JavaScript Module 中对于 import from 的路径有严格要求，必须是完整的 URL 或者以 “/“ “./“ “../“ 开头。 12345// 支持import { each } from &quot;./lodash.mjs&quot;;import utils from &quot;../utils.mjs&quot;;import utils from &quot;/modules/utils.mjs&quot;;import utils from &quot;https://test.test/modules/utils.mjs&quot;; 动态 import 方法按需加载，需要的时候下载。 123import(&quot;./utils.mjs&quot;).then((module) =&gt; { module.say();}); 浏览器中使用 JavaScript Module12&lt;script type=&quot;module&quot; src=&quot;index.mjs&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;index-compatible.js&quot;&gt;&lt;/script&gt; 上面的代码中，module 主要用来让支持 Module 的浏览器使用 index.mjs、nomodule，让不支持 Module 的浏览器使用兼容的index-compatible.js，同时忽略 type=”module”。 加载时机浏览器对&lt;script&gt; 标签不同属性的加载及运行时机有所不同。 写 nomodule 的时候建议也加入 defer 属性 1&lt;script nomodule defer src=&quot;index-compatible.js&quot;&gt;&lt;/script&gt; 扩展名对于JavaScript Module的脚本，浏览器要求服务器的相应类型必须是JavaScriptMIME type text/javascript，扩展名并不重要。上面我们用．mjs作为JavaScriptModule的扩展名主要有两个原因： mjs 可以让开发者知道这个文件是JavaScript Module，很容易进行区分 mjs 的扩展名可以让Node.js 或者 Babel 等默认按照 Module 进行解析，作为Module的交叉兼容方式。 执行次数JavaScript Module的执行次数与传统的JavaScript也是不同的。相同的JavaScript Module加载完成后只会执行一次，而传统的JavaScript加载几次就执行几次 12345678910// a.js 执行多次&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;// b.mjs 只执行一次&lt;script type=&quot;module&quot; src=&quot;b.mjs&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot; src=&quot;b.mjs&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; import './b.mjs'&lt;/script&gt; 跨域如果JavaScript Module文件存在跨域，需要相应的服务器提供必需的CORSHeader来进行支持，如Access-Control-Allow-Origin: *。 为什么要用 JavaScript ModuleJavaScript Module有如下优势： 提供了一种更好的方式来组织变量和函数。 可以把代码分割成更小的、可以独立运行的代码块。 支持更多的现代浏览器语法，书写起来更方便。 支持PWA Service Worker的所有主流浏览器，也支持JavaScriptModule，所以不需要做任何适配旧浏览器的代码转化，直接将代码提供给各个浏览器即可。也就是忽略了不支持的旧浏览器。 Promise回调方式主要会导致两个关键问题： 嵌套太深导致代码可读性太差。 行逻辑必须串行执行。 Promise 对象用于表示一个异步操作的结果，最终结果可能是“完成”“失败”或者其结果的值。Promise将嵌套的回调改造成一系列使用．then的链式调用，去除了层层嵌套的劣式代码风格。Promise不是一种解决具体问题的算法，而是一种更好的代码组织模式。 Promise对象的特点 对象的状态不受外界影响。 Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）、 Rejected（已失败）。根据异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，表示无法通过其他手段改变对象的状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved；从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，再对Promise对象添加回调函数，也会立即得到这个结果， Promise 构造函数 参数executor是一个带有resolve和reject两个参数的函数。executor函数在Promise构造函数执行时同步执行，被传递到resolve和reject函数（executor函数在Promise构造函数返回新建对象前被调用）。resolve和reject函数被调用时，分别将Promise的状态改为fulfilled（完成）或rejected（失败）。executor内部通常会执行一些异步操作，一旦完成，则可以调用resolve函数来将Promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。如果在executor函数中抛出一个错误，那么该Promise状态为rejected。executor函数的返回值被忽略。 1234567new Promise((resolve,reject) =&gt; { if(done) { resolve(value); }else{ reject(error) }}) 实例方法then()1promiseObj.then(onResolved,onRejected) 参数：onResolved：函数类型。用于处理当前 Promise 对象 Resolved 状态的回调，参数为 Resolved 的值。onRejected：函数类型。可选。用于处理当前 Promise 对象 Rejected 状态的回调，参数 Rejected 的值。 12345678910111213141516// 处理 Resolved 回调new Promise(resolve =&gt;{ resolve(&quot;resolve value&quot;);}).then(value = &gt;{ console.log(&quot;onResolved&quot;,value);})// 处理 onRejected 回调new Promise((resolve,reject)=&gt;{ reject(&quot;reject value&quot;);}).then( value =&gt; {}, value =&gt; { console.log(&quot;onRejected&quot;,value) }) catch1promiseObj.catch(onRejected); 该方法用于添加当前 Promise 对象 Rejected 的状态回调，并返回 Promise 对象的方法。它的行为与调用 promiseObj.then(undefined, onRejected) 相同。 12345new Promise((resolve,reject) =&gt;{ reject(&quot;reject value&quot;);}).catch(value =&gt; { console.log(&quot;onRejected&quot;,value);}) finally1promiseObj.finally(onFinally) 该方法用于添加当前Promise对象的状态回调，无论结果是Resolved还是Rejected，都会执行这个回调函数，其返回值为Promise。 123456new Promise((resolve,reject) =&gt; { resolve(&quot;resolve value&quot;); // reject(&quot;reject value&quot;);}).finally(()=&gt;{ console.log(&quot;finally&quot;);}) 关系图12345678910taskA().then( () =&gt; taskB(), () =&gt; taskB()}).then(() =&gt; { taskD()}).catch(() =&gt; { taskE()}).finally(()=&gt;{ taskF();}) 静态方法Promise 接口包含如下静态方法：resolve、reject、all、race。 resolve123Promise.resolve(value)Promise.resolve(promise)Promise.resolve(thenable) 该方法返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable（即带有then方法的对象），返回的Promise对象的最终状态由then方法执行决定；否则（即该value为空、基本类型或者不带then方法的对象），返回的Promise对象状态为Resolved，并且将该value传递给对应的then方法。有时需要将现有对象转换为Promise对象，Promise.resolve方法就起到这个作用： 12345678910111213141516171819202122Promise.resolve(&quot;data&quot;);// 等同于new Promise(resolve =&gt; resolve(&quot;data&quot;));// valuePromise.resolve(&quot;value&quot;).then(value =&gt; { console.log(value);})// promiseconst originPromise = Promise.resolve(&quot;originPromise&quot;);Promise.resolve(originPromise).then(value =&gt;{ console.log(value);})Promise.resolve({ then:function(onResolved,onReject){ onReject(&quot;onReject!&quot;); }}).then(value =&gt;{ console.log(value);}) reject实践方案系统集成系统集成项目组Fugu音频和视频的捕获可以通过MediaDevices API来实现音频和视频的捕获。这个API主要用来访问连接媒体输入的设备，如摄像头和麦克风，以及屏幕共享等。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div&gt; &lt;button id=&quot;btnVi&quot;&gt;捕获视频&lt;/button&gt;&lt;/div&gt;&lt;video id=&quot;vi&quot; controls width=&quot;350&quot; height=&quot;200&quot;&gt;&lt;/video&gt;&lt;div&gt; &lt;button id=&quot;btnAu&quot;&gt;捕获音频&lt;/button&gt;&lt;/div&gt;&lt;audio id=&quot;au&quot; controls&gt;&lt;/audio&gt;&lt;script&gt; document.getElementById(&quot;btnVi&quot;).onclick = () =&gt; { getStream(&quot;video&quot;, document.getElementById(&quot;vi&quot;)); }; document.getElementById(&quot;btnAu&quot;).onclick = () =&gt; { getStream(&quot;audio&quot;, document.getElementById(&quot;au&quot;)); }; function getStream(type, el) { if (!navigator.mediaDevices) { alert(&quot;mediaDevices API 不支持&quot;); return; } navigator.mediaDevices .getUserMedia({ [type]: true }) .then(stream =&gt; { if (&quot;srcObject&quot; in el) { el.srcObject = stream; } else { el.src = window.URL.createObjectURL(stream); } el.onloadedmetadata = () =&gt; { el.play(); }; }) .catch(err =&gt; { console.log(&quot;捕获视频错误：&quot;, err); }); }&lt;/script&gt; 视频流的截图通过ImageCapture API来控制设备摄像头的高级设置，例如缩放、白平衡、ISO或对焦等，并根据这些设置进行照片生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div&gt; &lt;button id=&quot;btnVi&quot;&gt;捕获视频&lt;/button&gt;&lt;/div&gt;&lt;video id=&quot;vi&quot; controls width=&quot;350&quot; height=&quot;200&quot;&gt;&lt;/video&gt;&lt;div&gt; &lt;button id=&quot;btnPhoto&quot;&gt;视频截图&lt;/button&gt;&lt;/div&gt;&lt;img id=&quot;photo&quot; style=&quot;border: 1px solid #aaa;width:350px;height:200px;&quot; /&gt;&lt;script&gt; let vStream; document.getElementById(&quot;btnVi&quot;).onclick = () =&gt; { getStream(&quot;video&quot;, document.getElementById(&quot;vi&quot;)); }; document.getElementById(&quot;btnPhoto&quot;).onclick = () =&gt; { takePhoto(vStream); }; function getStream(type, el) { if (!navigator.mediaDevices) { alert(&quot;mediaDevices API 不支持&quot;); return; } navigator.mediaDevices .getUserMedia({ [type]: true }) .then(stream =&gt; { vStream = stream; if (&quot;srcObject&quot; in el) { el.srcObject = stream; } else { el.src = window.URL.createObjectURL(stream); } el.onloadedmetadata = () =&gt; { el.play(); }; }) .catch(err =&gt; { console.log(&quot;捕获视频错误：&quot;, err); }); } function takePhoto(stream) { if (!stream) { alert(&quot;请先进行视频捕获。&quot;); return; } if (!(&quot;ImageCapture&quot; in window)) { alert(&quot;ImageCapture API 不支持。&quot;); return; } new ImageCapture(stream.getVideoTracks()[0]) .takePhoto() .then(data =&gt; { document.getElementById(&quot;photo&quot;).src = URL.createObjectURL(data); }) .catch(err =&gt; console.log(&quot;截图错误: &quot;, err)); }&lt;/script&gt; 视频流下载对于视频录制，很多场景下需要提供下载录制的视频的功能。这里可以借助MediaRecorder API来实现这个功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;div&gt; &lt;button id=&quot;btnVi&quot;&gt;捕获视频 &amp; 开始记录&lt;/button&gt;&lt;/div&gt;&lt;video id=&quot;vi&quot; controls width=&quot;350&quot; height=&quot;200&quot;&gt;&lt;/video&gt;&lt;div&gt; &lt;button id=&quot;btnPhoto&quot;&gt;下载&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt; let vStream; let vRecorder; let recorderData = []; document.getElementById(&quot;btnVi&quot;).onclick = () =&gt; { getStream(document.getElementById(&quot;vi&quot;)); }; document.getElementById(&quot;btnPhoto&quot;).onclick = () =&gt; { download(); }; function getStream(el) { if (!navigator.mediaDevices) { alert(&quot;mediaDevices API 不支持&quot;); return; } navigator.mediaDevices .getUserMedia({ video: true, audio: true }) .then(stream =&gt; { vStream = stream; if (&quot;srcObject&quot; in el) { el.srcObject = stream; } else { el.src = window.URL.createObjectURL(stream); } el.onloadedmetadata = () =&gt; { el.play(); }; try { vRecorder = new MediaRecorder(stream, { mimeType: &quot;video/webm&quot; }); console.log(&quot;创建 MediaRecorder: &quot;, vRecorder); } catch (e) { return console.error(&quot;创建 MediaRecorder 失败：&quot;, e); } vRecorder.ondataavailable = e =&gt; { if (e.data.size == 0) { return; } recorderData.push(event.data); }; vRecorder.start(100); // 设置 ondataavailable 的触发间隔 }) .catch(err =&gt; { console.log(&quot;捕获视频错误：&quot;, err); }); } function download() { if (!vStream || !vRecorder) { alert(&quot;请先捕获视频&quot;); return; } console.log(&quot;开始下载&quot;); vRecorder.stop(); vStream.getTracks()[0].stop(); vStream.getVideoTracks()[0].stop(); const aDom = document.createElement(&quot;a&quot;); document.body.appendChild(aDom); aDom.style = &quot;display: none&quot;; aDom.href = URL.createObjectURL( new Blob(recorderData, { type: &quot;video/webm&quot; }) ); aDom.download = &quot;download.webm&quot;; aDom.click(); recorderData = []; vStream = vRecorder = null; }&lt;/script&gt; 语音识别Web目前提供的语音识别相关的API，可以实现语音的获取及识别能力，这也是Web的另一种常用的输入能力。这里主要使用SpeechRecognition API来实现语音识别输入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div style=&quot;border:1px solid #ccc; width: 350px; height: 200px; &quot;&gt; &lt;span id=&quot;content-final&quot;&gt;&lt;/span&gt; &lt;span id=&quot;content-tmp&quot; style=&quot;color:gray&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt; &lt;button id=&quot;btn&quot;&gt;开始识别&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt; let btnDom = document.getElementById(&quot;btn&quot;); let contentFinalDom = document.getElementById(&quot;content-final&quot;); let contentTmpDom = document.getElementById(&quot;content-tmp&quot;); let recognition; btnDom.onclick = () =&gt; { window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition; if (!SpeechRecognition) { alert(&quot;不支持 SpeechRecognition API&quot;); return; } if (btnDom.innerText === &quot;开始识别&quot;) { recognition = new SpeechRecognition(); recognition.continuous = true; // 边说边识别 recognition.interimResults = true; // 临时识别的结果也显示。通过 isFinal 来确定 recognition.lang = &quot;cmn-Hans-CN&quot;; // 中文普通话。遵循 BCP-47 规范 recognition.start(); btnDom.innerText = &quot;停止识别&quot;; recognition.onstart = () =&gt; { contentFinalDom.innerText = &quot;&quot;; contentTmpDom.innerText = &quot;&quot;; console.log(&quot;识别开始&quot;); }; recognition.onresult = event =&gt; { console.log(&quot;识别中&quot;, event.results); let content = &quot;&quot;; let contentTmp = &quot;&quot;; for (let i = 0; i &lt; event.results.length; i++) { if (event.results[i].isFinal) { content += event.results[i][0].transcript; } else { contentTmp += event.results[i][0].transcript; } } contentFinalDom.innerText = content; contentTmpDom.innerText = contentTmp; }; recognition.onerror = event =&gt; { console.log(&quot;识别错误&quot;, event); }; recognition.onend = () =&gt; { console.log(&quot;识别结束&quot;); }; return; } recognition.stop(); recognition = null; btnDom.innerText = &quot;开始识别&quot;; };&lt;/script&gt; 剪切板操作在传统的Web能力中是不允许读取剪切板的，但目前有了Clipboard API，我们可以通过这个API对剪切板很方便地进行写和读操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;input id=&quot;copy&quot; value=&quot;这是一段文字&quot; /&gt;&lt;div&gt; &lt;button id=&quot;btnCopy&quot;&gt;复制&lt;/button&gt;&lt;/div&gt;&lt;input id=&quot;paster&quot; /&gt;&lt;div&gt; &lt;button id=&quot;btnPaster&quot;&gt;粘贴&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt; let btnCopyDom = document.getElementById(&quot;btnCopy&quot;); let btnPasterDom = document.getElementById(&quot;btnPaster&quot;); let copyValueDom = document.getElementById(&quot;copy&quot;); let pasterValueDom = document.getElementById(&quot;paster&quot;); btnCopyDom.onclick = () =&gt; { if (!&quot;clipboard&quot; in navigator) { alert(&quot;不支持 clipboard API&quot;); return; } navigator.clipboard .writeText(copyValueDom.value) .then(() =&gt; { console.log(`复制 ${copyValueDom.value} 成功`); }) .catch(err =&gt; { console.error(`复制失败`, err); }); }; btnPasterDom.onclick = () =&gt; { if (!&quot;clipboard&quot; in navigator) { alert(&quot;不支持 clipboard API&quot;); return; } navigator.clipboard .readText() .then(e =&gt; { pasterValueDom.value = e; console.log(`粘贴 ${e} 成功`); }) .catch(err =&gt; { console.error(`粘贴失败`, err); }); };&lt;/script&gt; 网络类型及速度信息可以通过Network Information API获取设备网络相关信息，开发者可以根据这些网络信息进行定制化处理。 12345678910if (!navigator.connection) { console.log(&quot;不支持 Network Information API&quot;); return;}console.log(&quot;底层连接类型：&quot; + navigator.connection.type);console.log(&quot;有效连接类型：&quot; + navigator.connection.effectiveType);console.log(&quot;最大下行速度(MB)：&quot; + navigator.connection.downlinkMax);navigator.connection.onchange = info =&gt; { }; // 网络信息发生变化时触发 网络状态信息可以通过navigator.onLine及一些在线、离线事件来监听网络变化，根据网络变化来做一些用户交互。响应事件代码如下所示 12345678910111213if (navigator.onLine) { console.log(&quot;你的网络当前在线&quot;);} else { console.log(&quot;你的网络当前离线&quot;);}window.ononline = () =&gt; { console.log(&quot;网络状态变化：当前网络在线&quot;);};window.onoffline = () =&gt; { console.log(&quot;网络状态变化：当前网络离线&quot;);}; 电池状态信息可以通过BatteryManager API来获取设备的电池状态。 1234567891011121314151617if (!navigator.getBattery || !navigator.battery) { console.log(&quot;不支持 BatteryManager API&quot;);} else { (navigator.getBattery() || Promise.resolve(navigator.battery)).then( battery =&gt; { console.log(&quot;当前电池充电：&quot; + battery.charging); console.log(&quot;距离充电完成还剩(S)：&quot; + battery.chargingTime); // 0 为充电完成 console.log(&quot;距离电池耗尽还剩(S)&quot; + battery.dischargingTime); console.log(&quot;电池放点等级：&quot; + battery.level); battery.onchargingchange; //电池充电状态更新时被调用。 battery.onchargingtimechange; // 电池充电时间更新时被调用。 battery.ondischargingtimechange; //电池断开充电时间更新时被调用。 battery.onlevelchange; //电池电量更新时被调用。 } );} 设备内存信息可以通过deviceMemory API来获取设备的内存信息，根据内存信息来调整性能，提升各个端的体验。 12console.log(&quot;当前设备内存大小：&quot; + navigator.deviceMemory + &quot; GB&quot;);// 当前设备内存大小：8 GB 地理定位在Web中可以通过Geolocation API获取位置数据，通常它会基于GPS和网络进行定位。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;div id=&quot;content&quot; style=&quot;width: 420px; height: 200px;border: 1px solid #333;&quot;&gt;&lt;/div&gt;&lt;div&gt; &lt;button id=&quot;btnGet&quot;&gt;获取位置&lt;/button&gt; &lt;button id=&quot;btnWatch&quot;&gt;监听位置变化&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt; let btnGet = document.getElementById(&quot;btnGet&quot;); let btnWatch = document.getElementById(&quot;btnWatch&quot;); let contentDom = document.getElementById(&quot;content&quot;); let watcher; btnGet.onclick = () =&gt; { if (!&quot;geolocation&quot; in navigator) { alert(&quot;不支持 Geolocation API&quot;); return; } navigator.geolocation.getCurrentPosition( info =&gt; { console.log(&quot;获取位置成功&quot;, info); contentDom.innerText += `获取位置：\\n纬度 ${info.coords.latitude} 经度 ${info.coords.longitude}\\n`; }, err =&gt; { console.log(&quot;获取位置错误&quot;, err); }, { enableHighAccuracy: false, // 低精度，获取速度快 timeout: Infinity, // 设备必须在多长时间内获取值 ms maximumAge: 0 // 定位信息的缓存时间 ms } ); }; btnWatch.onclick = () =&gt; { if (!&quot;geolocation&quot; in navigator) { alert(&quot;不支持 Geolocation API&quot;); return; } if (btnWatch.innerText == &quot;监听位置变化&quot;) { if (watcher) { return; } watcher = navigator.geolocation.watchPosition( info =&gt; { console.log(&quot;监听位置变化：&quot;, info); contentDom.innerText += `监听位置变化：\\n纬度 ${info.coords.latitude} 经度 ${info.coords.longitude}\\n`; }, err =&gt; { console.log(&quot;监听位置变化错误&quot;, err); }, {} ); btnWatch.innerText = &quot;停止监听位置变化&quot;; return; } watcher &amp;&amp; navigator.geolocation.clearWatch(watcher); contentDom.innerText += &quot;监听停止\\n&quot;; console.log(&quot;监听停止&quot;); btnWatch.innerText = &quot;监听位置变化&quot;; };&lt;/script&gt; 设备位置在Web中可以使用Device Orientation API来实现获取陀螺仪、指南针等数据，也可以通过Generic Sensor API和Orientation Sensor API来获取设备方向数据。 12345678910111213// 绝对位置let aos = new AbsoluteOrientationSensor();// 创建一个相对于地球的参考坐标系统的设备的物流方向的对象aos.addEventListener(&quot;reading&quot;,listener); // 方向发生变化时的事件aos.start(); // 开始监听aos.quaternion; // 获取方向信息// 相对位置let ros = new RelativeOrientationSensor();// 创建一个相对固定参考坐标系统的设备物理方向的对象ros.addEventListener('reading',listener); // 方向发生变化时的事件aos.start(); // 开始监听aos.quaternion; // 获取方向信息 12345678910111213141516171819 &lt;img id=&quot;img&quot; src=&quot;img.png&quot; /&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot;&gt; let img = document.getElementById(&quot;img&quot;); let content = document.getElementById(&quot;content&quot;); window.ondeviceorientation = e =&gt; { let { gamma, beta, alpha } = e; console.log(alpha, beta, gamma); img.style.transform = `rotate(${alpha}deg) rotate3d(1, 0, 0, ${beta}deg)`; content.innerHTML = ` alpha(方向): ${alpha} deg&lt;br /&gt; beta(前后): ${beta} deg&lt;br /&gt; gamma(左右): ${gamma} deg `; };&lt;/script&gt; 相关资料FetchEvent.respondWith√Request.mode√ES6 模块化的时代真的来临了么？Using MJS√ 源码PWA 入门与实践","link":"/2020/10/17/Book12/"},{"title":"微信小程序项目开发实战：用WePY、mpvue、Taro打造高效的小程序","text":"第 11 章实战：使用 Taro 实现星座测试小程序Taro 是一套遵循 React 语法规范的多端开发解决方案。 Taro 遵循 React 语法规范，它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。 采用 Taro 开发小程序具有以下的优秀特效： 支持使用 npm/yarn 安装管理第三方依赖。 支持使用 ES7/ES8 甚至更新的 ES 规范，一切都可自行配置。 支持使用 CSS 预编译器，例如 Sass 等。 支持使用 Redux 进行状态管理。 支持使用 Mobx 进行状态管理。 小程序 API 优化、异步 API Promise 化等。 Taro 项目的编写采用 React 语法，所以引入本地静态文件应当使用 import 语句 12import bg from '../../public/bg.jpeg'import './index.less' Taro 提供的 Image 组件可完成图片内容的显示 1&lt;Image src={bg} mode=&quot;widthFix&quot; className=&quot;bg&quot; /&gt; 在组件中绑定的监听事件,需要使用.bind 的方式声明事件。 1onClick={this.onTap.bind(this,item)} 该方法要执行的事件，需要在组件中声明。 12345onTap(name){ Taro.navigateTo({ url:'' })} URL 地址传参 123Taro.navigateTo({ url: '/pages/page/path/name?id=2&amp;type=test'}) 在 componentWillMount 方法里通过 this.$router.params 获取到传入的参数。 123componentWillMount () { console.log(this.$router.params) // 输出 { id: 2, type: 'test' }} 发起网络请求，支持 Promise 化使用。Taro.request() 赋值setState（） 项目编译与生成Taro 并不是所有的内容都被各类小程序所支持的，不同小程序也因为平台的不同对部分 API 的支持不同，所以开发者为了开发全平台支持的小程序，需要尽可能地使用 Taro 提供的通用组件。 编译为微信小程序 1npm run build:weap 编译为百度小程序 1npm run build:swan 需要下载安装百度开发者工具 编译为支付宝小程序 1npm run build:alipay 需要下载安装支付宝开发者工具 编译为字节跳动小程序 1npm run build:tt 编译为 H5 1npm run build:h5 相关代码仓库:WeChat","link":"/2020/02/01/Book6/"},{"title":"Vue 企业开发实战","text":"第 1 章 大觅项目架构设计1.2.2 什么是 NPMNode.js 的包管理器 NPM 是全球最大的开源库生态系统，它集成在 Node.js 中，在安装 Node.js 的时候就已经自带了 NPM 包管理工具。验证 NPM 是否安装成功的方法同验证 Node.js 的方法。 在命令行窗口中输入“npm -v”可得到 NPM 的版本，说明 NPM 已经安装成功，如图 1.10 所示。 NPM 常用命令 1234npm install&lt;Module Name&gt;-g //安装模块 加不加“-g”代表是不是全局安装npm list&lt;Module Name&gt; //查看某个模块的版本号npm uninstall&lt;Module Name&gt; //卸载模块npm update&lt;Module Name&gt; //更新模块 注意： 全局安装和非全局安装的区别： 举例说明，使用“npm install express -g”安装express框架后，就可以在计算机的任意一个文件夹下打开命令提示符窗口，直接使用express创建项目，否则会遇到“'express'不是内部或外部命令，也不是可运行的程序”错误。读者应该也遇到过类似的问题，这就是非全局安装引起的，使用“npm install express”安装express框架为局部安装，局部安装就是将模块下载到当前命令行所在目录下，只有在当前目录下才可以用。 1.2.3 安装 cnpmNPM 安装插件需要从国外服务器下载，受网络影响大，下载比较慢，容易出现异常。说明来自淘宝 NPM 镜像官网：这是一个完整的 npmjs.org 镜像，可以用此代替官方版本（只读），同步频率目前为 10 分钟一次，以保证尽量与官方服务同步。既然淘宝 NPM 镜像这样方便，那么该如何使用呢？使用方法比较简单，只需要在命令行中输入以下内容，按回车键等待安装成功即可。npm install -g cnpm –registry=https://registry.npm.taobao.org安装CNPM成功之后，输入“cnpm -v”。 1.2.3 Vue-cli 脚手架Vue-cli 是一个官方命令行工具，可用于快速搭建大型单页面应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程，只需几分钟即可创建并启动一个带热重载、保存时静态检查，以及可用于生产环境构建配置的项目。 单页面应用（Single Page Web Application，SPA）只有一个 Web 页面的应用，是一种从 Web 服务器加载的客户端，单页面跳转仅刷新局部资源，公共资源（js、css 等）仅需加载一次。多页面应用（Multi-Page Application，MPA）多页面跳转刷新所有资源，每个公共资源（js、css 等）需选择性重新加载。 全局安装 Vue-cli 1cnpm install vue-cli -g 命令交互的含义如下：➢ project name：如果输入新的项目名称，则会使用新输入的项目名称；直接回车的话，就会默认使用 webpack 后面跟的项目名称。➢ Project description：项目的描述内容，可以自定义一些内容。➢ Author: 作者，可以写上自己的邮箱或者 GitHub 的地址。➢ Vue build：打包的方式，这里直接回车即可。➢ Install vue-router? (Y/n)：是否安装 Vue 路由，建议选择 Yes，一般项目都需要路由功能。➢ Use ESLint to lint your code? (Y/n)：是否启用 ESlint 检测，选择不启用。➢ Set up unit tests (Y/n)：是否需要单元检测，建议选择不需要。➢ Setup e2e tests with Nightwatch? (Y/n)：是否需要端对端的检测，建议选择不需要。 使用原始的方式进行开发有什么问题呢？看一下原始开发存在的以下问题。➢ 难以维护➢ 加载缓慢➢ 体验差➢ 重复编码➢ 扩展困难➢ 前后端耦合度高 分层架构的主要优势在于：易维护、可扩展、易复用、灵活性高，因此深受前端开发工程师喜爱。 模块化。模块化是指解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程，有多种属性反映其内部特性，同时模块化还可以解耦实现并行开发。主要的模块化解决方案有：AMD（requirejs）、CMD（seajs）、CommonJS、ES6。模块化用来分割、组织和打包软件。 分离方式➢ 不分离➢ 部分分离➢ 完全分离  不分离和部分分离有什么缺点呢？不分离：前后端共用同一个项目目录，本地开发环境搭建成本高，项目比较复杂、不宜维护且维护成本高、发布风险高，不利于问题的定位和修改。部分分离：本地环境搭建成本较高，需要后端提供页面模板（JSP 等），更新和修改模板需要后端人员操作，效率低且不易维护，发布方式需要同时发布，且沟通成本比较高。 完全分离又分为两种：分离开发集成部署和分离开发分离部署。 分离开发分离部署。前端使用纯 HTML 通过接口的方式进行数据的交互，降低系统的复杂度，部署时单独部署到一台服务器上，使用代理进行数据的交互。 1.3.4 UI 框架UI 框架的优缺点。 优点：➢ 快速搭建 Web 页面➢ 集中精力完成业务代码➢ 缩短开发周期 缺点：➢ 冗余代码➢ 无法定制化、精细化开发 UI 框架的选择标准UI 框架是否能够满足项目要求组件丰富度，效果炫酷度UI 框架的 API 完整度、社区的活跃程度 说明–save 与–save-dev 的区别–save 会把依赖包添加到 package.json 文件 dependencies 下–save-dev 会把依赖包添加到 package.json 文件 devDependencies 下。 dependencies 是产品上线运行时的依赖，devDependencies 是产品开发时的依赖。devDependencies 下的模块是产品开发时用的。 在项目中引入 iView 框架引入方式一般是在 Webpack 的入口页面 main.js 中做如下配置： 123456789101112131415161718192021import Vue from 'vue';import VueRouter from 'vue-router';import App from 'components/app.vue';import Routers from './router.js';// 引入iView框架import iView from 'iview';// 引入iView框架样式import 'iview/dist/styles/iview.css';Vue.use(VueRouter);Vue.use(iView);// The routing configurationconst RouterConfig = { routes: Routers};const router = new VueRouter(RouterConfig);new Vue({ el: '#app', router: router, render: h =&gt; h(App)}); 组件是什么？组件是将一个或几个完成各自功能的代码段封装为一个或几个独立的部分。用户界面组件就包含了这样一个或几个具有各自功能的代码段，最终完成了用户界面。另外一种方式是按需引入组件，也就是项目中需要什么组件，就引入什么组件，实现按需加载，减少文件体积。 按需引入的加载方式：安装插件 1npm install babel-plugin-import --save-dev babel-plugin-import 插件可以从组件库中引入需要的模块，而不是把整个库都引入，从而提高性能。 然后在.babelrc 文件中添加代码： 1234567&quot;plugins&quot;: [ [&quot;import&quot;, { &quot;libraryName&quot;: &quot;iview&quot;, &quot;libraryDirectory&quot;: &quot;src/components&quot; }] ]}","link":"/2020/02/17/Book8/"},{"title":"Vue.js 快跑：构建触手可及的高性能 Web 应用","text":"第 1 章 Vue.js 基础为什么选择 Vue.js使用框架，项目代码可维护程度提高，简化了大部分工作。 使用 Ajax 下载一个列表数据并在页面上显示。 jQuery 123456789101112131415161718192021222324&lt;ul class=&quot;js-items&quot;&gt;&lt;/ul&gt;&lt;script&gt; $(function(){ $.get('https://example.com/items.json') .then(function(data){ ar $itemUL = $('.js-items'); if(! data.items.length){ var $noItems = $('li'); $noItems.text('Sorry,there are no items'); $itemsUl.append($noItems); }else{ data.items.forEach(function(item){ var $newItem = $('li'); $newItem.text(item); if(item.includes('blue')){ $newItem.addClass('is-blue'); } $itemUl.append($newItem); }) } }) })&lt;/script&gt; 这段代码执行了以下逻辑：1、使用 $.get() 发起 Ajax 请求。2、选取类名为 .js-items 的元素并将它存入 $itemUl 变量。3、如果下载的列表中没有列表项，则创建一个 li 元素，设置这个 li 元素的文本节点以表示当前没有列表项，然后将它添加到文档流中。 如果列表中存在列表项，则循环遍历每一个列表项。4、为列表中的每一项创建一个li元素，并将其文本节点设置为该列表项的值。然后判断该列表项是否包含blue字符串，如果包含则将li元素的类名设置为is-blue。最后，将li元素添加到文档流中。 Vue 12345678910111213141516171819202122&lt;ul class='js-items'&gt; &lt;li v-if='! items.length'&gt; Sorry, there are no items. &lt;/li&gt; &lt;li v-for=&quot;item in items&quot; :class=&quot;{'is-blue': item.includes('blue')}&quot;&gt; {{item}} &lt;/li&gt;&lt;/ul&gt;&lt;script&gt; new Vue({ el: '.js-items', data: { items: [] }, created(){ fetch('https://example.com/items.json') .then((res) =&gt; res.json()) .then((data) =&gt;{ this.items = data.items; }) } })&lt;/script&gt; 这段代码执行了以下逻辑：1、使用fetch()发起一个Ajax请求。2、将返回的JSON数据解析为JavaScript对象。3、将下载的列表项存储为data对象中的items属性。 vue-router 用于路由控制——根据应用的不同URL来显示不同的内容。vuex 用于状态管理——通过一个全局数据中心在组件间共享数据。vue-test-utils 用于 Vue 组件的单元测试。 安装和设置安装 Vue 不需要任何特殊的工具，使用下面的代码就可以实现： 1234567891011&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', created(){ // 这段代码会在应用启动时运行 } })&lt;/script&gt; 1、有一个 ID 为 app 的 div 元素用于初始化 Vue。2、在页面上引用 CDN 版本的 Vue 文件，也可以下载到本地并引用。3、运行一些 JavaScript 代码，创建一个 Vue 的实例，并将该实例的 el 属性指向之前提到的div元素。 vue-loader和webpackvue-loader是一个webpack的加载器，允许组件的所有HTML、JavaScript和CSS代码编写到同一个文件中。 webpack 123456789module: { loaders: [ { test: /\\.vue$/, loader: 'vue', } // ... 其他加载器 ... ]} 如果还没有配置好 webpack 或者 不知如何添加vue-loader，可以使用一份现成的模板来初始化 Vue 项目。 Vue-cli bach12$ npm install --global vue-cli$ vue init webpack 模板（Template）、数据（Data）和指令（Directive）Vue 的核心是将数据显示在页面上，这一功能通过模板实现。为正常的HTML添加特殊的属性——被称作指令——借助它来告诉 Vue 我们想要实现的效果以及如何处理提供给它的数据。 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;isMorning&quot;&gt; 早上好！ &lt;/p&gt; &lt;p v-if=&quot;isAfternoon&quot;&gt; 中午好！ &lt;/p&gt; &lt;p v-if=&quot;isEvening&quot;&gt; 晚上好！ &lt;/p&gt;&lt;/div&gt;&lt;script&gt; var hours = new Date().getHours(); new Vue({ el: '#app', data: { isMorning: hours &lt; 12, isAfternoon: hours &gt;= 12 &amp;&amp; hours &lt; 18, isEvening: hours &gt;= 18 } });&lt;/script&gt; v-if 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;hours &lt; 12&quot;&gt; 早上好！ &lt;/p&gt; &lt;p v-if=&quot;hours &gt;= 12 &amp;&amp; hours &lt; 18&quot;&gt; 中午好！ &lt;/p&gt; &lt;p v-if=&quot;hours &gt;= 18&quot;&gt; 晚上好！ &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { hours: new Date().getHours() } });&lt;/script&gt; 插值 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;p&gt;Hello, {{ greetee }}! &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { greetee: 'world' } });&lt;/script&gt; 插值和指令结合 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;path === '/'&quot;&gt;你正位于首页&lt;/p&gt; &lt;p v-else&gt; 你正位于 {{ path }} &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { path: location.pathname } });&lt;/script&gt; location.pathname 是当前页面URL的路径值。 传递数组或对象 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;p&gt;第二条狗的名字是 {{ dogs[1] }}&lt;/p&gt; &lt;p&gt;所有狗的名字是 {{ dogs }} &lt;/p&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { dogs: ['Rex','Rover','Henrietta','Alan'] } });&lt;/script&gt; v-if vs v-showv-if 12&lt;div v-if=&quot;true&quot;&gt;one&lt;/div&gt;&lt;div v-if=&quot;false&quot;&gt;two&lt;/div&gt; 输出内容 1&lt;div&gt;one&lt;/div&gt; v-show v-show 指令使用CSS样式控制元素的 显示/隐藏 。 12&lt;div v-show=&quot;true&quot;&gt;one&lt;/div&gt;&lt;div v-show=&quot;false&quot;&gt;two&lt;/div&gt; 输出内容 12&lt;div&gt;one&lt;/div&gt;&lt;div style='display: none'&gt;two&lt;/div&gt; 使用 v-if 隐藏的内部元素不会被显示,Vue 不会尝试生成对应的HTML代码；意味着隐藏尚未加载的内容时，v-if 指令更好一些。 示例：抛出一个异常 123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;div v-show=&quot;user&quot;&gt; &lt;p&gt;User name: {{ user.name }}&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue({ el: '#app', data: { user: undefined } })&lt;/script&gt; 会抛出异常是因为 Vue 尝试执行user.name —— 一个尚不存在的对象的属性。在该示例中如果使用v-if就会正常工作，因为 Vue 直到v-if语句为真时才会去尝试生成元素的内部内容。 v-if v-else-if v-else 123456789&lt;div v-if=&quot;state === 'loading'&quot;&gt; 加载中&lt;/div&gt;&lt;div v-else-if=&quot;state === 'error'&quot;&gt; 出错了&lt;/div&gt;&lt;div v-else&gt; ... 我们的内容！&lt;/div&gt; 使用 v-if 会有性能开销。每次插入或者移除元素时都必须要生成元素内部的 DOM 树，这在某些时候是非常大的工作量。而 v-show 除了在初始创建开销时之外没有额外的开销。如果希望频繁地切换某些内容，那么v-show会是最好的选择。 如果元素包含任何图片，那么仅使用CSS隐藏父节点可以使浏览器在图片显示之前就加载它，这意味着一旦v-show变为真值，图片就可以显示出来。如果是v-if指令，图片会直到要显示时才开始加载。","link":"/2020/03/06/Book9/"},{"title":"面闭 — HTML","text":"HTML5 新特性(1) 新的语言标签 (2) 增强型的表单（表单2.0） (3) 音频和视频 (4) Canvas 绘图 (5) Svg 绘图（地图） (6) 拖放 API (7) web worker (8) web storage (10) web Socket HTML 常见的兼容性问题超链接点击过后 hover 样式就不出现被点击访问过的超链接样式不在具有 hover 和 active 样式。解决方法是改变 CSS 属性的排列顺序：L-V-H-A。 IE 的 z-index 问题解决办法，理解层叠上下文，层叠级别与 ‘z-index’ 之间的关系。在可能出现定位元素相互覆盖的情况时，明确指定定位元素的 ‘z-index’特性，避免此类问题的出现。 IE8 不支持 opacity解决： 12345.opacity { opacity: 0.6; filter: alpha(opacity=60); /* internet explorer */ -ms-filter:&quot;progid:DXImageTransform.Microsoft.Alpha(opacity=60)&quot;; /*IE8*/} 为什么 HTML5 只需要写&lt;！DOCTYPE html&gt;HTML4.01 中的 doctype 需要对 DTD 进行引用，因为 HTML 4.01 基于 SGML。而 HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。其中，SGML 是标准通用标记语言，简单的说，就是比 HTML、XML 更老的标准，这两者都是由 SGML 发展而来的。 css中表示长度的单位有哪些？em、ex、ch、rem、vw、vh、vmax、vmin;cm、mm、q、in、pt、pc、px; 面试知识点 以上是我对下列视频及文章的归纳和总结。不透明不工作在img在IE8(Opacity not working on img in IE8)","link":"/2020/02/11/Interview-Question1/"},{"title":"中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂","text":"CSS盒模型 content-box (W3C 标准盒模型)border-box (IE 盒模型)padding-boxmargin-box (浏览器未实现) BFC 块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。IE 下为 Layout，可通过 zoom:1 触发触发条件:根元素position: absolute/fixeddisplay: inline-block / tablefloat 元素ovevflow !== visible规则:属于同一个 BFC 的两个相邻 Box 垂直排列属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box 的左边相接触 (子元素 absolute 除外)BFC 的区域不会与 float 的元素区域重叠计算 BFC 的高度时，浮动子元素也参与计算文字层不会被浮动层覆盖，环绕于周围应用:阻止 margin 重叠可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 div 都位于同一个 BFC 区域之中)自适应两栏布局可以阻止元素被浮动元素覆盖 层叠上下文 触发条件根层叠上下文(html)positioncss3 属性flextransformopacityfilterwill-change-webkit-overflow-scrolling层叠等级：层叠上下文在 z 轴上的排序在同一层叠上下文中，层叠等级才有意义z-index 的优先级最高 居中布局水平居中行内元素：text-align:center块级元素：margin: 0 auto","link":"/2020/02/12/Interview-Question2/"},{"title":"10小时掌握前端面试题","text":"1、call 、apply 、bind 的区别是什么？哪个性能更好一些？ 性能测试： 123console.time('A');执行代码console.timeEnd('A'); 浏览器自带性能测试 2、实现（5）.add(3).minus(2) ，使其输出结果为：6 123456789101112131415161718(function() { // 每一个方法执行完，都要返回 Number 这个类的实例，这样才可以继续调取 Number 类原型中的方法（链式写法） function checkNumber(n) { n = Number(n); return isNaN(n) ? 0 : n; } function add(n) { n = checkNumber(n); return this + n; } function minus(n) { n = checkNumber(n); return this - n; } [&quot;add&quot;, &quot;minus&quot;].forEach(item =&gt; { Number.prototype[item] = eval(item); });})(); 以上是我对下列视频及文章的归纳和总结。10 小时掌握前端面试题","link":"/2020/02/12/Interview-Question5/"},{"title":"2022年 准备","text":"封面图片出处Pexels 上的 Max Ravier 拍摄的照片 目标薪资：12K 面试：技术面试、负责人面试、HR 面试。 技术面试：主要考察技术负责人面试：考察综合。例如项目把控能力、项目深度、项目架构能力、业务相关的东西等等。HR 面试：侧重考察性格、沟通、潜力等等。 每个面试时间大致在 1 个小时~1.5 个小时。 这门课程主要分为 5 大部分面试准备面试技巧：答题技巧和沟通技巧题目演练知识梳理复习指导 课程价值 JD 描述怎么看？简历怎么写？知识怎么复习？问题该怎么回答？项目怎么准备？和负责人怎么沟通？HR 印象怎么留？ 面试准备JD 描述分析业务分析技术栈准备自我介绍 模拟一面：基础知识体系面试技巧 页面布局类CSS 盒模型 DOM 事件类HTTP 协议类 原型链类面向对象类 通信类前端安全类 前端算法类 模拟二面：注重知识的宽度和深度面试技巧渲染机制类JS 运行机制页面性能错误监控 模拟三面 面试技巧业务能力团队协作能力带人能力 模拟终面 面试技巧职业竞争力职业规划 课程总结 注意事项复习指南 授课方式明确面试技巧模拟题目，由浅入深代码实战 + 学习指南 冒泡排序 https://mp.weixin.qq.com/s/6exYIZLYmYm9eCeLELPppwhttps://juejin.im/post/5d904712e51d45781e0f5dd0?utm_source=gold_browser_extensionhttps://mp.weixin.qq.com/s/PJjRsfQJboU_XBkfrGN0sQhttps://juejin.im/post/5d7596055188253e4b2f0c29https://www.cnblogs.com/itlkNote/p/6831115.htmlhttp://caibaojian.com/interview-map/ 页面布局","link":"/2019/12/28/Interview-Question6/"},{"title":"长投学堂——银行理财课","text":"银行理财严格意义上的银行理财产品，其实是商业银行在对潜在目标客户进行分析和研究的基础上，针对特定目标客户群开发、设计并销售的资金投资和管理计划。银行先研究清楚客户的需求，然后根据这些需求、开发、设计出一些帮助客户管理钱，投资钱的产品，再把这些产品卖给客户。严格意义上的银行理财，是由银行开发、设计以及销售的。这是中国银行保险监督管理委员会，简称银保监，对银行理财的定义。从银行对投资者资金的使用情况上看，购买银行理财，更像买基金而不是买股票。银行理财和基金本质上没什么大区别，都是受人之托，代客理财，也就是帮我们管理资金。银行理财由银保监监管，基金由证监会监管，他们的信息披露、监管条款有些许差别，对投资人来说，这些区别并不影响投资。银行理财和基金产品类型也不一样。基金公司提供的产品，都需要投资人自负盈亏，而银行理财的产品中，有一部分产品是可以保证本金不会亏损的。银行除了有自营产品外，还会帮其他机构销售非本银行研发的产品，比如基金、黄金等。","link":"/2020/02/10/Journal-10/"},{"title":"我们避而不谈的性教育，可能正在侵害着这个国家的未来","text":"我看到微信公众号中一篇文章，久久不能平静我决定写一篇博客分享出来。文章在博客的下方相关资料中。 《房思琪的初恋乐园》《小学生性健康教育读本》 以上是我对下列视频及文章的归纳和总结。 相关资料关于「性」，该教育的不是孩子，而是大人。","link":"/2020/04/14/Journal-11/"},{"title":"面试 从面试到面壁 Vue 篇","text":"开始重点倾向问源码注重你在项目中做出的实践 Q：Vue3 今年发布了，请你说一下他们之间在相应式的实现上有什么区别？A：Vue2 采用的是 defineProperty 去定义 get，set，而 Vue3 改用了 proxy。也代表着 vue 放弃了兼容 ie。 Q：像 Vue-Router，Vuex 他们都是作为 Vue 插件，请说一下他们分别都是如何在 vue 中生效的？A：通过 vue 的插件系统，用 vue.mixin 混入到全局，在每个组件的生命周期的某个阶段注入组件实例。 Q：请你说一下 Vue 的设计架构。A：Vue2 采用的是典型的混入式架构，类似于 express 和 jquery，各部分分模块开发，再通过一个 mixin 去混入到最终暴露到全局的类上。 Q：请说一下你这个项目中做的事情？A：这个项目主体是一个 vue 项目，但是因为是 pc 端，为了 seo，我特意做了 ssr。然后这个项目有一套我和同事一起做的专门的组件库。在移动端，我们为了搭配 app，也做了移动混合方案。像在首页，因为数据巨大，我们采用了一些优化方案。利用本地缓存数据，对小图标进行了 base64 转码。 以上是我对下列视频及文章的归纳和总结。 相关资料","link":"/2020/12/05/Interview-Question8/"},{"title":"尚硅谷明哥心态修炼七堂课","text":"封面图片出处Pexels 上的 Pixabay 拍摄的照片 基于评价体系的自我认知 你做任何事情最后的结果,都由你做这些事情时所抱持的心态决定的。 心态会不自觉的影响你的行为举止，从以下几点可以看出你的心态 从你的声音里能听见 从你的举止里能看见 从你的身上能感受到 自我认知的实验 客观得写出自己的五个优点和五个缺点 了解一下别人对你的评价（找你最好的朋友 ，让他写下看到你的人或听到你的名字时，最先想到的形容词） 自我评价和他人评价对比 发现问题（找到贬义词或负面心态） 解决问题（改变负面心态） 企业调研报告：《招聘企业最在意的员工的职业素养》最低分 0 分，最高分 10 分进行测评 你有目标吗？ 你够勤奋吗？ 高效利用时间 你持之以恒吗？ 你安排有序吗？ 你有创造性吗？ 想方设法解决问题的能力 你精力集中吗？ 你正直吗？ 你是否有正常和正确的心态 你乐观吗？ 遇到困难是否积极的面对 你愿意与人合作嘛？ 与他人合作互相促进互相激励互相监督 你愿意接受他人的建议吗？ 这套测评可以判断你的心态，分数越高，心态越积极。 简单的心里测试： 我有一个好消息和一个坏消息，先听哪一个？如果他总是先听好消息，可能偏积极如果他总是先听坏消息，可能偏消极 别让你的情绪，变成你的性格缺陷情绪写在脸上的人不能委以重任先处理心情再处理事情 老板不会惯着你在职场上，所有的过失都要有人来买单。 不要在他人面前轻易表露自己的情绪 不要做煤气罐 不要在意别人的评价，很容易陷入困惑。不要做煤气罐，别人一点你就炸。要用体面的方式表达你的情绪否则你的情绪会被视作性格的缺陷永远不要让你的脾气比你的本事还大吵架吵得是情绪 当你情绪失控的时候认真思考三个问题： 这是别人的错吗？ 这个事情值得生气吗？ 生气能解决问题吗？闲谈莫论人非，静坐常思己过。 不要做祥林嫂这个世界上最无能的事就是抱怨。牢骚太盛防肠断，风物长宜放眼量。 让你不堪重负的不是压力，而是你承受压力的方式。 没有本事就不要表演真性情有实力才有发言权。没有不委屈的工作，也没有超完美的公司，只有玻璃心的员工。没有收拾残局的能力，就不要放纵你善变的情绪，在你成为强者之前，所有的委屈都必须吞咽和妥协，没有人会在乎弱者的眼泪。 使我们痛苦者让我们强大 自信都没有，你的世界怎么可能好你先要有自信，才有资格要求别人对你有信心。 建立自信的方法： 如果你对自己某方面的能力没有自信一点一点小的成功会积累你的自信 切忌不要定大目标大目标规划方向，小目标积累自信。一点一点小的成功会积累你的自信，一点一点小的成功积累得越来越多从量变到质变就成为了你的自信从现实出发，改变你可以改变的，接受你不能改变的。 不知道哪里不自信，整个人都不自信去做一件你一直想做没敢做的事情（对自己有益），直到你获得成功。当你有足够的自信时，你就能做成很多原本做不到的事 积极的心里暗示多给自己肯定的心里暗示 走路快一点（积极的行为可以潜移默化得增强自信） 很多人，一辈子就靠这两个字活着比较无处不在：比学习把眼光放远一点，你未来的世界远比现在的圈子大。和上个月的自己比。 比较无处不在：比对象难就难在比较二字上 比较无处不在，比收入比较是一种局限和狭隘，会让你变得不思进取。演好自己的角色，别盯着别人的剧本看，这个世界上，越是优秀的人越努力，越是富有的人越勤奋，越是智慧的人越谦卑学习优秀的人总能看到比自己更好的，平庸的人总能看到比自己更差的。 年龄越大越没有人会原谅你的穷，你现在的生活也许不是你想要的，但绝对是你自找的。 比较无处不在：比个屁。 一起比惨痛苦减半。 石黑一雄：如果说有一件事是我鼓励你们大家去做的那就是永远不要随波逐流要超越我们周围那些低级和颓废的影响 面对批评，你应该摆正一个正确姿态面对批评应该抱有闻过则喜的心态。 永远感谢愿意花时间在你身上的人。 把“为什么挨骂的总是我”变成“我能从这件事上学到什么” 如果你觉得批评是一种刁难 一开始就输了如果你觉得批评是一种雕刻 迟早都会赢的凡事先在自身找原因，不要苛求他人 面对批评的职业心态：褒贬是买主喝彩是闲人 示弱有助于解决冲突，先认错后解释。 没有问题的人，其实才是最大的问题，发现问题是好事，解决问题是大事，回避问题是蠢事，没有问题反而是坏事。他人的批评，往往是最直接地指正。 成功多半是来自精准的勤奋，而不是平庸的忙碌，批评是你成长的机会，愿意批评你的人都值得感激，闻过则喜。 面对批评摆个什么样的姿势，体现了你的内在修养和培养潜力。 这个世界上，没人该为你的选择买单选择自己所爱的，爱自己所选择的。人生中每一个重要的决定，都必须自己做，这个世界上没有任何人，应该为你的选择买单，包括你的父母。 一个人的独立是从自己选择去做某件事情开始的，不要让别人为你的行为担风险，自己的事情自己解决，否则你永远是一个长不大的孩子。 人性一个最特别的弱点：在意别人如何看待自己 不是每一个人都能活成自己想要的样子，但是你努力以后，这个失败才不可耻。 当你不再抱怨生活，下定决心为了某些追求，不断努力的时候，你才真正长大了。 走好，选择的路，别选择，好走的路。 苦难并不值得赞美，不要错将吃苦本身，当成了一种高贵的姿态，值得赞美得是能够战胜苦难的能力，以及战胜苦难之后获得的幸福。 成年人的世界里，一切都是自作自受。 越是人生重大的决定，越要自己去选，任何人帮你选了你都不会甘心，选了就认了。 选择的基本原则，两利相权取其重，两害相权取其轻。 选择永远比努力更重要。 职场最糟糕的两种心态：自我和自私警惕的六个字：我以为和我觉得 什么是自我，别人的问题与我无关。所谓不自我，就是换位思考。最深层的本性，就是渴望得到别人的重视。 今天你不帮助别人，明天一定不会有人帮助你。 你要先把别人当朋友，别人才可能把你当朋友。 什么是自私，我的利益比什么都重要。 别人帮了你，你会心存感激。你帮了别人，他会想要报答你 你越是自私，反而得到的越少。占的都是小便宜，吃的全是大亏。 如果你是蚂蚁心态，再小的石头都是障碍。如果你是雄鹰心态，再高的山峰也敢尝试。 以上是我对该视频的归纳和总结。","link":"/2020/01/15/Journal-1/"},{"title":"HTML+CSS 习题及面试题","text":"HTML/CSS1、根据下面效果图设计页面： 两点要求： 1.自适应宽度，左右两栏固定宽度，中间栏优先加载； 2.要考虑到换肤 参考1、自适应宽度、左右两栏固定宽度，中间栏优先加载，可以采用双飞翼布局。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;style type=&quot;text/css&quot;&gt; * { margin: 0; padding: 0px; } .header { background: #666; text-align: center; } .body { overflow: hidden; *zoom: 1; } .wrap-2 { margin-top: 30px; } .wrap-2 .main-2 { float: left; width: 100%; margin-bottom: -3000px; padding-bottom: 3000px; background: #f90; } .wrap-2 .main-wrap-2 { margin: 0 200px 0 150px; } .wrap-2 .sub-2 { float: left; margin-left: -100%; width: 150px; background: #6c0; margin-bottom: -3000px; padding-bottom: 3000px; } .wrap-2 .extra-2 { float: left; margin-left: -200px; width: 200px; background: #f9f; margin-bottom: -3000px; padding-bottom: 3000px; } .footer { background: #666; text-align: center; }&lt;/style&gt;&lt;div class=&quot;wrap-2&quot;&gt; &lt;div class=&quot;header&quot;&gt;Header&lt;/div&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;main-2&quot;&gt; &lt;div class=&quot;main-wrap-2&quot;&gt; &lt;p&gt;main-wrap&lt;/p&gt; &lt;p&gt;main-wrap&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;sub-2&quot;&gt; &lt;p&gt;sub&lt;/p&gt; &lt;p&gt;sub&lt;/p&gt; &lt;p&gt;sub&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;extra-2&quot;&gt; &lt;p&gt;extra&lt;/p&gt; &lt;p&gt; margin-left:350px; background:#CC0;margin-left:350px; background:#CC0; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;Footer&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt; .container { display: -moz-box; display: -webkit-box; } div { padding: 10px; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } .sider_l { width: 250px; -moz-box-ordinal-group: 1; -webkit-box-ordinal-group: 1; background: limegreen; } .middle_content { -moz-box-flex: 1; -webkit-box-flex: 1; -moz-box-ordinal-group: 2; -webkit-box-ordinal-group: 2; background: lightpink; } .sider_r { width: 250px; -moz-box-ordinal-group: 3; -webkit-box-ordinal-group: 3; background: green; }&lt;/style&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;middle_content&quot;&gt;优先加载主内容区&lt;/div&gt; &lt;div class=&quot;sider_l&quot;&gt;左边栏&lt;/div&gt; &lt;div class=&quot;sider_r&quot;&gt;右边栏&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;style&gt; html, body { width: 100%; height: 100%; margin: 0; padding: 0; } .content { width: 100%; height: 100%; position: relative; background: #cff; overflow: hidden; } .left { width: 200px; height: 100%; background: #0f0; position: absolute; z-index: 1001; top: 0; left: 0; } .center-ct { height: 100%; background: #60f; position: absolute; z-index: 900; top: 0; left: 0; margin: 0; width: 100%; } .center { margin: 0 200px; } .right { width: 200px; height: 100%; background: #ff0; position: absolute; z-index: 1000; right: 0; top: 0; }&lt;/style&gt;&lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;center-ct&quot;&gt; &lt;div class=&quot;center&quot;&gt; center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center center &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;style type=&quot;text/css&quot;&gt; body { margin: 0; padding: 0; } .main { width: 100%; position: relative; background: #fc0; } .content { margin: 0 210px; background: #f60; } .left { position: absolute; left: 0; top: 0; width: 200px; background: #00f; } .right { position: absolute; right: 0; top: 0; width: 200px; background: #0f0; } .clearfix:before, .clearfix:after { content: &quot;&quot;; display: table; } .clearfix:after { clear: both; } .clearfix { zoom: 1; }&lt;/style&gt;&lt;header&gt;头部&lt;/header&gt;&lt;div class=&quot;main clearfix&quot;&gt; &lt;div class=&quot;content&quot;&gt;中间&lt;br /&gt;中间&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左边&lt;br /&gt;左边&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右边&lt;/div&gt;&lt;/div&gt;&lt;footer&gt;底部&lt;/footer&gt; 12345678910111213141516171819202122232425&lt;style type=&quot;text/css&quot;&gt; div { outline: 1px solid red; min-height: 200px; } .m { margin: 0 200px; } .l, .r { position: absolute; width: 200px; background: #f3c; } .l { top: 0; } .r { top: 0; right: 0; }&lt;/style&gt;&lt;div class=&quot;m&quot;&gt;&lt;/div&gt;&lt;div class=&quot;l&quot;&gt;&lt;/div&gt;&lt;div class=&quot;r&quot;&gt;&lt;/div&gt; 2、根据下图编写一段 XHTML 参考 12345678910&lt;div class=&quot;dialogPractise&quot;&gt; &lt;h2&gt;对话练习&lt;/h2&gt; &lt;ul class=&quot;dialogPractise-bd&quot;&gt; &lt;li&gt; &lt;strong&gt;小明&lt;/strong&gt; &lt;span&gt;我的淘宝店成立 5 周年啦欢迎光临哦！&lt;/span&gt; &lt;/li&gt; &lt;li&gt;&lt;strong&gt;傅玉&lt;/strong&gt; &lt;span&gt;昨天销售 300 件米奇心情真爽！&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span class=&quot;dialogPractise-fo&quot;&gt;&lt;/span&gt;&lt;/div&gt; 3、请简化下面的 CSS 代码： 12345margin: 0px;padding: 10px 0 10px 0;border-width: 1px;border-style: solid;border-color: #ff5500; 参考： 123margin: 0;padding: 10px 0;border: 1px solid #ff5500; 123margin: 0;padding: 10px 0;border: 1px solid #f50; 4、有这么一段 HTML，请挑毛病： 1&lt;P&gt; 哥写的不是 HTML，是寂寞。&lt;br&gt;&lt;br&gt; 我说：&lt;br&gt;不要迷恋哥，哥只是一个传说 参考： 12345&lt;p&gt;哥写的不是 HTML，是寂寞。&lt;/p&gt;&lt;p&gt; 我说：&lt;br /&gt; 不要迷恋哥，哥只是一个传说&lt;/p&gt; 12345&lt;p&gt;哥写的不是 HTML，是寂寞。&lt;/p&gt;&lt;p&gt; 我说：&lt;br /&gt; 不要迷恋哥，哥只是一个传说&lt;/p&gt; 12345&lt;p&gt;哥写的不是 HTML，是寂寞。&lt;/p&gt;&lt;p&gt; 我说：&lt;br /&gt; &lt;q&gt;不要迷恋哥，哥只是一个传说&lt;/q&gt;&lt;/p&gt; 1234567&lt;p&gt; 哥写的不是&lt;abbr title=&quot;”Hyper&quot; Text Markup Language”&gt;HTML&lt;/abbr&gt;，是寂寞。&lt;/p&gt;&lt;p&gt; &lt;cite&gt; 我&lt;/cite&gt;说：&lt;br /&gt; &lt;q&gt;不要迷恋哥，哥只是一个传说&lt;/q&gt;&lt;/p&gt; 5、对 WEB 标准以及 W3C 的理解与认识。 参考：标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链 css 和 js 脚本、 结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更 广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提 供打印版本而不需要复制内容、提高网站易用性。 6、xhtml 和 html 有什么区别。 参考：HTML 是一种基本的 WEB 网页设计语言，XHTML 是一个基于 XML 的置标语言。最主要的不同：XHTML 元素必须被正确地嵌套。XHTML 元素必须被关闭。标签名必须用小写字母。 XHTML 文档必须拥有根元素。 7、Doctype? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义? 参考：用于声明文档使用那种规范（html/Xhtml）一般为 严格 过度 基于框架的 html 文档。加入 XMl 声明可触发，解析方式更改为 IE5.5 拥有 IE5.5 的 bug。 声明位于文档中的最前面，处于标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档 严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点 无法工作。 DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。 8、行内元素有哪些?块级元素有哪些?CSS 的盒模型? 参考：CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值， 比如 div 默认 display 属性值为“block”，成为“块级”元素； span 默认 display 属性值为“inline”，是“行内”元素。块级元素：div p h1 h2 h3 h4 form ul ol li dl dt dd行内元素: a b br i span input select em input select strongCSS 盒模型:内容，border ,margin，padding 9、CSS 引入的方式有哪些? link 和@import 的区别是? 参考： 1234567891011121314内联 内嵌 外链 导入。区别 ：link 属于 XHTML 标签，而@import 是 CSS 提供的;页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载;import 只在 IE5 以上才能识别，而 link 是 XHTML 标签，无兼容问题;link 方式的样式的权重高于@import 的权重. 使用@import 引入跟 link 方法很像，但必须放在样式表中 &lt;!– @import url(css/example.css); –&gt; 使用 STYLE 标签将样式规则写在标签之中。 &lt;!– body {color: #666;background: #f0f0f0;font-size: 12px;} td,p {color:#c00;font-size: 12px;} –&gt; @import 可以在 css 中再次引入其他样式表，比如可以创建一个主样式表，在主样式表 中再引入其他的样式表，如： main.css ———————- @import “sub1.css”; @import “sub2.css”; 这样做有一个缺点，会对网站服务器产生过多的 HTTP 请求，以前是一个文件，而现在 却是两个或更多文件了，服务器的压力增大，浏览量大的网站还是谨慎使用同时加载。前者无兼容性，后者 CSS2.1 以下浏览器不支持。Link 支持使用 javascript 改变样式，后者不可。1.使用 LINK 标签 将样式规则写在.css 的样式文件中，再以&lt;link&gt;标签引入。 &lt;link rel=stylesheet type=&quot;text/css&quot; href=&quot;example.css&quot;&gt;2.使用@import 引入 跟 link 方法很像，但必须放在&lt;STYLE&gt;...&lt;/STYLE&gt; 中 &lt;STYLE TYPE=&quot;text/css&quot;&gt; &lt;!-- @import url(css/example.css); --&gt; &lt;/STYLE&gt;3.使用 STYLE 标签 将样式规则写在&lt;STYLE&gt;...&lt;/STYLE&gt;标签之中。 &lt;STYLE TYPE=&quot;text/css&quot;&gt; &lt;!-- body {color: #666;background: #f0f0f0;font-size: 12px;} td,p {color:#c00;font-size: 12px;} --&gt; &lt;/STYLE&gt;4.使用 STYLE 属性 将 STYLE 属性直接加在个别的组件标签里，&lt;组件(标签) STYLE=&quot;性质(属性)1: 设定值 1; 性质(属性)2: 设定值 2; ...}5.使用&lt;span&gt;&lt;/span&gt;标记引入样式 &lt;span style=&quot;font:12px/20px #000000;&quot;&gt;cnwebshow.com&lt;/span&gt; 两者区别：加载顺序的差别。当一个页面被加载的时候，link 引用的 CSS 会同时被加载， 而@import 引用的 CSS 会等到页面全部被下载完再被加载。@import 可以在 css 中再次引入 其他样式表，比如可以创建一个主样式表，在主样式表中再引入其他的样式表，如： main.css ———————- @import“sub1.css”; @import“sub2.css”; 这样做有一个缺点，会对网站服务器产生过多的 HTTP 请求，以前是一个文件，而现在 却是两个或更多文件了，服务器的压力增大，浏览量大的网站还是谨慎使用。 10、CSS 选择符有哪些?哪些属性可以继承?优先级算法如何计算?内联和 important 哪个优先 级高? 参考：标签选择符 类选择符 id 选择符 继承不如指定 Id&gt;class&gt;标签选择 后者优先级高。 11、前端页面有哪三层构成，分别是什么?作用是什么? 参考：结构层 Html 表示层 CSS 行为层 js 12、css 的基本语句构成是? 参考：选择器{属性 1:值 1;属性 2:值 2;„„} 13、你做的页面在哪些流览器测试过?这些浏览器的内核分别是什么? 参考：Ie(Trident) 火狐（Gecko） 谷歌（Blink WebKit 的分支） opear(Presto 现为 Blink) 14、写出几种 IE6 BUG 的解决方法。 参考： 1.双边距 BUG float 引起的 使用 display。2.3 像素问题 使用 float 引起的 使用 dislpay:inline -3px。 3.超链接 hover 点击后失效 使用正确的书写顺序 link visited hover active。4.Ie z-index 问题 给父级添加 position:relative。5.Png 透明 使用 js 代码改。6.Min-height 最小高度 ！Important 解决’ 。7.select 在 ie6 下遮盖 使用 iframe 嵌套。 8.为什么没有办法定义 1px 左右的宽度容器（IE6 默认的行高造成的，使用 over:hidden,zoom:0.08 line-height:1px） 。 15、标签上 title 与 alt 属性的区别是什么? 参考：Alt 当图片不显示是 用文字代表。Title 为该属性提供信息。 16、描述 css reset 的作用和用途。 参考：Reset 重置浏览器的 css 默认属性 浏览器的品种不同，样式不同，然后重置，让他们统 一。css reset因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。 – 当然，初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小 的情况下初始化。 17、解释 css sprites，如何使用。 参考：Css 精灵 把一堆小的图片整合到一张大的图片上，减轻服务器对图片的请求数量。 18、浏览器标准模式和怪异模式之间的区别是什么? 参考：盒子模型 渲染模式的不同 使用 window.top.document.compatMode 可显示为什么模式。 19、你如何对网站的文件和资源进行优化?期待的解决方案包括： 参考：文件合并 文件最小化/文件压缩 使用 CDN 托管 缓存的使用 20、什么是语义化的 HTML? 参考：直观的认识标签 对于搜索引擎的抓取有好处。用正确的标签做正确的事情！ html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式 CCS 情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 123456去掉或样式丢失的时候能让页面呈现清晰的结构： html 本身是没有表现的，我们看到例如&lt;h1&gt;是粗体，字体大小 2em，加粗；&lt;strong&gt;是 加粗的，不要认为这是 html 的表现，这些其实 html 默认的 css 样式在起作用，所以去掉或 样式丢失的时候能让页面呈现清晰的结构不是语义化的 HTML 结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达 html 的语义，可以说浏览器的默认样式 和语义化的 HTML 结构是不可分割的。屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页. 例如,如果你使用的含语义的标记,屏幕阅读器就会“逐个拼出”你的单词,而不是试着去 对它完整发音。PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS 的支持较弱） 使用语义标记可以确保这些设备以一种有意义的方式来渲染网页.理想情况下,观看设备 的任务是符合设备本身的条件来渲染网页. 语义标记为设备提供了所需的相关信息,就省去了你自己去考虑所有可能的显示情况 （包括现有的或者将来新的设备）.例如,一部手机可以选择使一段标记了标题的文字以粗体 显示.而掌上电脑可能会以比较大的字体来显示.无论哪种方式一旦你对文本标记为标题,您就可以确信读取设备将根据其自身的条件来合适地显示页面。搜索引擎的爬虫也依赖于标记来确定上下文和各个关键字的权重 过去你可能还没有考虑搜索引擎的爬虫也是网站的“访客”,但现在它们他们实际上是 极其宝贵的用户.没有他们的话,搜索引擎将无法索引你的网站,然后一般用户将很难过来访问。你的页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记, 而只注重语义标记。 因此,如果页面文件的标题被标记,而不是,那么这个页面在搜索结果的位置可能会比较靠后.除了提升易用性外,语义标记有利于正确使用 CSS 和 JavaScript,因为其本身提供了许多 “钩钩”来应用页面的样式与行为。 SEO 主要还是靠你网站的内容和外部链接的。便于团队开发和维护 W3C 给我们定了一个很好的标准，在团队中大家都遵循这个标准，可以减少很多差异化的东西，方便开发和维护，提高开发效率，甚至实现模块化开发。 21、清除浮动的几种方式，各自的优缺点。 参考： 1.使用空标签清除浮动 clear:both（理论上能清楚任何标签，增加无意义的标签）。 2.使用 overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用 zoom:1 用于兼容 IE）。 3.是用 afert 伪元素清除浮动(用于非 IE 浏览器) 22、img 的 alt 和 title 的异同？ 参考：title 属性为设置该属性的元素提供建议性的信息。比如为链接添加描述性文字。为不能显示图像、窗体或 applets 的用户代理（UA）， alt 属性用来指定替换文字。使用 alt 属性是为了给那些不能看到你文档中图像的浏览者提供文字说明。 23、CSS 布局：两列，左边宽度自适应，右边宽度固定 200px。 参考： 1234567891011121314151617181920212223242526&lt;style&gt; #box1 { width: 100%; height: 600px; position: relative; } #left1 { margin-right: 200px; border: 1px solid red; height: 100%; } #right1 { width: 200px; height: 100%; position: absolute; top: 0px; right: 0px; border: 1px solid blue; }&lt;/style&gt;&lt;div id=&quot;box1&quot;&gt; &lt;div id=&quot;left1&quot;&gt;&lt;/div&gt; &lt;div id=&quot;right1&quot;&gt;&lt;/div&gt;&lt;/div&gt; 24、前端页面由哪三层构成，分别是什么?作用是什么? 参考：网页分成三个层次，即：结构层、表示层、行为层。网页的结构层（structural layer）由 HTML 或 XHTML 之类的标记语言负责创建。标签， 也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含 任何关于如何显示有关内容的信息。例如， P 标签表达了这样一种语义：“这是一个文本段。”网页的表示层（presentation layer） 由 CSS 负责创建。 CSS 对“如何显示有关内容” 的问题做出了回答。网页的行为层（behavior layer）负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM 主宰的领域。 25、常见兼容性问题？ 参考： 12345678910111213141516png24 位的图片在 iE6 浏览器上出现背景，解决方案是做成 PNG8。浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的*{margin:0;padding:0;} 来统一。IE6 双边距 bug:块属性标签 float 后，又有横行的 margin 情况下，在 ie6 显示 margin 比设置的大。浮动 ie 产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下 IE 会产生 20px 的距离，解决方案是在 float 的标签样式控制中加入 —— _display:inline;将其转化为行内属性。(_这个符号只有 ie6 会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将 IE 游览器从所有情况中分离出来。 接着，再次使用“+”将 IE8 和 IE7、IE6 分离开来，这样 IE8 已经独立识别。 .bb{ background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\\9; /*IE6、7、8 识别*/ +background-color:#a200ff;/*IE6、7 识别*/ _background-color:#1e0bd1;/*IE6 识别*/ }IE 下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用 getAttribute()获取自定义属性; Firefox 下,只能使用 getAttribute()获取自定义属性. 解决方法:统一通过 getAttribute()获取自定义属性.IE 下,even 对象有 x,y 属性,但是没有 pageX,pageY 属性; Firefox 下,event 对象有 pageX,pageY 属性,但是没有 x,y 属性.解决方法：（条件注释）缺点是在 IE 浏览器下可能会增加额外的 HTTP 请求数。Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决. 超链接访问过后 hover 样式就不出现了 被点击访问过的超链接样式不在具有 hover 和 active 了解决方法是改变 CSS 属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}respond.min.js:让不支持css3 Media Query的浏览器包括IE6-IE8等其他浏览器支持查询。(https://blog.csdn.net/zyj0209/article/details/80897112)html5shiv.js:解决ie9以下浏览器对html5新增标签的不识别.(https://www.cnblogs.com/mmykdbc/p/9395390.html) 26、html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？如 何区分 HTML 和 HTML5？ 参考： 12345678HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能 的增加。绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search新的技术 webworker, websockt, Geolocation移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u；对可用性产生负面影响的元素：frame，frameset，noframes；支持 HTML5 新标签：IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持 HTML5 新标签， 浏览器支持新标签后，还需要添加标签默认的样式：当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架 如何区分： DOCTYPE 声明\\新增的结构元素\\功能元 27、HTML5 的离线储存？ 参考：localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 数据在浏览器关闭后自动删除。 28、iframe 有那些缺点？ 参考：iframe 会阻塞主页面的 Onload 事件；iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以可以绕开以上两个问题。 29、请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 参考：cookie 在浏览器和服务器间来回传递。sessionStorage 和 localStorage 不会 sessionStorage 和 localStorage 的存储空间更大；sessionStorage 和 localStorage 有更多丰富易用的接口； sessionStorage 和 localStorage 各自独立的存储空间； sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会 话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久 化的本地存储，仅仅是会话级别的存储。而 localStorage 用于持久化的本地存储，除非主动 删除数据，否则数据是永远不会过期的。web storage 和 cookie 的区别Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。Cookie 的 大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中 浪费了带宽，另外 cookie 还需要指定作用域，不可以跨域调用。除此之外，Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需 要前端开发者自己封装 setCookie，getCookie。但是 Cookie 也是不可以或缺的：Cookie 的作 用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本 地“存储”数据而生。 30、如何实现浏览器内多个标签页之间的通信? 参考：调用 localstorge、cookies 等本地存储方式。 31、webSocket 如何兼容低浏览器？ 参考：Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于 长轮询的 XHR。 32、介绍一下 CSS 的盒子模型？ 参考：有两种，IE 盒子模型、标准 W3C 盒子模型；IE 的 content 部分包含了 border 和 pading;盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border). 33、CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3 新增伪类有那些？ 参考： 123456789101112131415161.id 选择器（ # myid）2.类选择器（.myclassname）3.标签选择器（div, h1, p）4.相邻选择器（h1 + p）5.子选择器（ul &lt; li）6.后代选择器（li a）7.通配符选择器（ * ）8.属性选择器（a[rel = “external”]）9.伪类选择器（a: hover, li: nth – child）10.群组选择器（p,div,#a）可继承的样式： font-size font-family color;不可继承的样式：border padding margin width height ;优先级就近原则，同权重情况下样式定义最近者为准;载入样式以最后载入的定位为准;优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高 34、CSS3 新增伪类举例 参考： 1234567p:first-of-type 选择属于其父元素的首个元素的每个元素。p:last-of-type 选择属于其父元素的最后元素的每个元素。p:only-of-type 选择属于其父元素唯一的元素的每个元素。p:only-child 选择属于其父元素的唯一子元素的每个元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个元素。:enabled :disabled 控制表单控件的禁用状态。:checked 单选框或复选框被选中。 35、如何居中 div？ 参考：给 div 设置一个宽度，然后添加 margin:0 auto 属性 36、position 的值， relative 和 absolute 定位原点是？ 参考： absolute：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 fixed：生成绝对定位的元素，相对于浏览器窗口进行定位。 relative：生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中。 （忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值 37、CSS3 有哪些新特性？ 参考：CSS3 实现圆角（border-radius:8px）阴影（box-shadow:10px）对文字加特效（text-shadow、）线性渐变（gradient）旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放, 定位,倾斜CSS 选择器多背景 rgba 38、对 BFC 规范的理解？ 参考：W3C CSS 2.1 规范中的一个概念,它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。 39、css 定义的权重 参考：以下是权重的规则：标签的权重为 1，class 的权重为 10，id 的权重为 100，以下例子是 12345678910111213/*权重为 1*/div{ } /*权重为 10*/.class1{ }/*权重为 100*/#id1{ }/*权重为 100+1=101*/#id1 div{ } /*权重为 10+1=11*/.class1 div{ }/*权重为 10+10+1=21*/.class1 .class2 div{ }如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现。 40、如果需要手动写动画，你认为最小时间间隔是多久，为什么？ 参考：多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms 41、display:inline-block 什么时候会显示间隙？ 参考：移除空格、使用 margin 负值、使用 font-size:0、letter-spacing、word-spacing 42、Quirks 模式是什么？它和 Standards 模式有什么区别？ 参考：从 IE6 开始，引入了 Standards 模式，标准模式中，浏览器尝试给符合标准的文档在规 范上的正确处理达到在指定浏览器中的程度。在 IE6 之前 CSS 还不够成熟，所以 IE5 等之前的浏览器对 CSS 的支持很差， IE6 将对 CSS 提供更好的支持，然而这时的问题就来了，因为有很多页面是基于旧的布局方式写的，而如 果 IE6 支持 CSS 则将令这些页面显示不正常，如何在即保证不破坏现有页面，又提供新的渲 染机制呢？ 在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的 功能，尤其是新功能不兼容旧功能时。遇到这种问题时的一个常见做法是增加参数和分支， 即当某个参数为真时，我们就使用新功能，而如果这个参数 不为真时，就使用旧功能，这 样就能不破坏原有的程序，又提供新功能。IE6 也是类似这样做的，它将 DTD 当成了这个“参 数”，因为以前的页面大家都不会去写 DTD，所以 IE6 就假定 如果写了 DTD，就意味着这个 页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式。这就是 Quirks 模式（怪癖模式，诡异模式，怪异模式）。 区别： 总体会有布局、样式解析和脚本执行三个方面的区别。 盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和 高度，而在 Quirks 模式下，IE 的宽度和高度还包含了 padding 和 border。 设置行内元素的高宽：在 Standards 模式下，给等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。 设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的， 如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用 margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模 式下却会失效。 43、div+css 的布局较 table 布局有什么优点？ 参考： 改版的时候更方便 只要改 css 文件。 页面加载速度更快、结构化清晰、页面显示简洁。 表现与结构相分离。 易于优化（seo）搜索引擎更友好，排名更容易靠前。 44、img 的 alt 与 title 有何异同？b：strong 与 em 的异同？ 参考： alt(alt text):为不能显示图像、窗体或 applets 的用户代理（UA）， alt 属性用来指定替换文字。替换文字的语言由 lang 属性指定。 (在 IE 浏览器下会在没有 title 时把 alt 当成 tool tip 显示） title(tool tip):该属性为设置该属性的元素提供建议性的信息。 strong:粗体强调标签，强调，表示内容的重要性 em:斜体强调标签，更强烈强调，表示内容的强调点 45、你能描述一下渐进增强和优雅降级之间的不同吗? 参考： 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的 功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器 进行兼容。 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从 一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功 能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。 “优雅降级”观点 “优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被 认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对 象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)”的浏览体验。你可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注 的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 “渐进增强”观点 “渐进增强”观点则认为应关注于内容本身。 内容是我们建立网站的诱因。有的网站展示它，有的则收集它，有的寻求，有的操作， 还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强” 成为一种更为合理的设计范例。这也是它立即被 Yahoo! 所采纳并用以构建其“分级式浏览 器支持 (Graded Browser Support)”策略的原因所在。 46、为什么利用多个域名来存储网站资源会更有效？ 参考： CDN 缓存更方便 突破浏览器并发限制 节约 cookie 带宽 节约主域名的连接数，优化页面响应速度 防止不必要的安全问题 47、简述一下 src 与 href 的区别。 参考：src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所 在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片 和 frame 等元素。 1&lt;script src =”js.js”&gt;&lt;/script&gt; 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、 执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么 将 js 脚本放在底部而不是头部。 href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点） 或当前文档（链接）之间的链接，如果我们在文档中添加 1&lt;link href=”common.css” rel=”stylesheet”/&gt; 那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处 理。这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。 48、知道的网页制作会用到的图片格式有哪些？ 参考：png-8，png-24，jpeg，gif，svg、WebpWebP 格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay 等知名网站已经开始测试并使用 WebP 格式。 在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小 40%。 49、知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？ 参考：微格式（Microformats）是一种让机器可读的语义化 XHTML 词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。 （应用范例：豆瓣，有兴趣自行 google） 50、在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？ 参考：dns 缓存，cdn 缓存，浏览器缓存，服务器缓存。 51、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的 加载，给用户更好的体验。 参考：图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩 略图，以提高用户体验。如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片 压缩，图片压缩后大小与展示一致 52、谈谈以前端角度出发做好 SEO 需要考虑什么？ 参考： 了解搜索引擎如何抓取网页和如何索引网页你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SErobot 或叫 web crawler）如何进行工作，搜索引擎如何对搜索结果进行排序等等。 Meta 标签优化主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如 Author（作者），Category（目录），Language（编码语种）等。 如何选取关键词并在网页中放置关键词搜索就得用关键词。关键词分析和选择是 SEO 最重要的工作之一。首先要给网站确定主关键词（一般在 5 个上下），然后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。 了解主要的搜索引擎虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有Google，Yahoo，Bing 等；中文的有百度，搜狗，有道等。不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。还要了解各搜索门户和搜索引擎之间的关系，比如 AOL 网页搜索用的是 Google 的搜索技术，MSN 用的是 Bing 的技术。 主要的互联网目录Open Directory 自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方式不同。目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。 按点击付费的搜索引擎搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有 Overture 和百度，当然也包括 Google 的广告项目 Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面也大有优化和排名的学问，你得学会用最少的广告投入获得最多的点击。 搜索引擎登录网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）到搜索引擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如 Yahoo 要 299 美元），但是好消息是（至少到目前为止）最大的搜索引擎 Google 目前还是免费，而且它主宰着 60％以上的搜索市场。 链接交换和链接广泛度（Link Popularity）网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也每天通过不同网站之间的链接来 Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重要的是，你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。 合理的标签使用 53、有哪项方式可以对一个 DOM 设置它的 CSS 样式？ 参考： 外部样式表，引入一个外部 css 文件内部样式表，将 css 代码放在 标签内部内联样式，将 css 样式直接定义在 HTML 元素内部 54、CSS 选择器的优先级是怎么样定义的？ 参考：基本原则：一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。 复杂的计算方法：用 1 表示派生选择器的优先级用 10 表示类选择器的优先级用 100 标示 ID 选择器的优先级 ◦div.test1 .span var 优先级 1+10 +10 +1span#xxx .songs li 优先级 1+100 + 10 + 1#xxx li 优先级 100 +1 盒模型垂直居中方法三栏布局选择器权重计算方式清除浮动的方法flex什么是 BFC、可以解决哪些问题position 属性如何实现一个自适应的正方形如何用 css 实现一个三角形 JavaScriptcall 和 apply 的区别是什么？哪个性能更好一些共同点：改变 this 指向不同点：call： 传参是一个一个apply：参数是数组的形式 三个以上参数 call 性能优于 apply 性能测试 123console.time(&quot;A&quot;);for (let i = 0; i &lt; 10000000; i++) {}console.timeEnd(&quot;A&quot;); 实现（5）.add(3).minus(2)，使其输出结果为：6 箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？ 防抖和节流深拷贝数组去重、数组乱序手写 call、apply、bind继承（ES5/ES6）sleep 函数实现 promise实现 promise.all实现 promise.retry将一个同步 callback 包装成 promise 形式写一个函数，可以控制最大并发数jsonp 的实现eventEmitter(emit,on,off,once)实现 instanceof实现 new实现数组 flat、filter 等方法lazyMan函数 currying有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化 ES6let、const、var 区别箭头函数与普通函数的区别变量的结构赋值promise、async await、Generator 的区别ES6 的继承与 ES5 相比有什么不同js 模块化（commonjs/AMD/CMD/ES6） 浏览器相关知识从输入 URL 到呈现页面过程强缓存、协商缓存、CDN 缓存HTTP2简单讲解一下 HTTP2 的多路复用 在 HTTP/1 中，每次请求都会建立一次 TCP 连接，也就是我们常说的 3 次握手 4 次挥手，这在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题： 第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输） 第二个：连接数过多。我们假设 Apache 设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6（Chrome），也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。 HTTP2 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制。HTTP2 中 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。 单个连接上可以并行交错的请求和响应，之间互不干扰 谈谈你对 TCP 三次握手和四次挥手的理解 A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态 HTTP 状态码三次握手与四次挥手跨域（JSONP/CORS）跨域时如何处理 cookie垃圾回收机制 web 安全https什么是 xss，如何预防什么是 csrf，如何预防为什么会造成 csrf 攻击 事件循环框架（Vue）watch 与 computed 的区别vue 生命周期及对应的行为vue 父子组件生命周期执行顺序组件间通讯方法如何实现一个指令vue.nextTick 实现原理diff 算法如何做到的双向绑定虚拟 dom 为什么快如何设计一个组件 框架（React）React 中 setState 什么时候是同步的，什么时候是异步的？React setState 笔试题，下面的代码输出什么？ 123456789101112131415161718192021222324252627class Example extends React.Component { constructor() { super(); this.state = { val: 0 }; } componentDidMount() { this.setState({val: this.state.val + 1}); console.log(this.state.val); // 第 1 次 log this.setState({val: this.state.val + 1}); console.log(this.state.val); // 第 2 次 log setTimeout(() =&gt; { this.setState({val: this.state.val + 1}); console.log(this.state.val); // 第 3 次 log this.setState({val: this.state.val + 1}); console.log(this.state.val); // 第 4 次 log }, 0); } render() { return null; } webpack用过哪些 loader 和 pluginloader 的执行顺序为什么是后写的先执行webpack 配置优化webpack 打包优化（happypack、dll）plugin 与 loader 的区别webpack 执行的过程如何编写一个 loader、plugintree-shaking 作用，如何才能生效 性能优化首屏加载如何优化一个网页从请求到呈现花了很长时间，如何排查 NPM介绍下 NPM 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？ 设计模式介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景聊聊 Redux 和 Vuex 的设计思想 水平垂直居中两栏布右侧自适应双飞翼布局高度塌陷flex 布局vw、em、remIE6 双边距离图片问题多行显示省略号移动端 1 像素边框问题","link":"/2019/12/29/Interview-Question3/"},{"title":"前端程序员面试宝典 摘要","text":"第 8 章 移动端在移动端，单击穿透是什么？单击穿透现象有 3 种。 单击穿透问题：单机蒙层（mask）上的“关闭”按钮，蒙层消失后，发现触发了按钮下面元素的 click 事件。页面羊击穿透问题：如果按钮下面恰好是一个有 href 属性的 a 标签，那么页面 就会发生跳转。跨页面单击穿透问题：这次没有蒙层了，直接单击页内按钮跳转至新页，然后发现新页面中对应位置元素的 click 事件被触发了。 有 4 种解决方案。（1）只用 touch。这是最简单的解决方案，完美解决单击穿透，把页面内所有 click 都换成 touch 事件（touchstart,touchend,tap）。（2）只用 click因为单击会带来 300ms 的延迟，所以网页内任何一个自定义交互都将增加 300ms 的延迟。（3）轻触（tap）后延迟 350ms 再隐藏蒙层。改动最小，缺点是隐藏蒙层变慢了，350ms 还是能感觉到慢的。（4）添加 pointer-events:none 样式这比较麻烦且有缺陷，不建议使用，蒙层隐藏后，给按钮下面的元素添上 pointer-events:none 样式，让 click 穿过去，350ms 后去掉这个样式。恢复响应的缺陷是蒙层消失后的 350ms 内，用户单击按钮下面的元素没反应，如果用户单击速度很快，一定会发现。 如何实现自适应布局？通过以下几种方式实现。（1）可以使用媒体查询做响应式页面（2）用 Boostrap 的栅格系统。（3）使用弹性盒模型 在移动端（ Android 、 iOS ）怎么做好用户体验？从以下几方面做好用户体验。（1）清晰的视觉纵线。（2）信息的分组（3）极致的减法（4）利用选择代替输入（5）标签及文字的排布方式。（6）依靠明文确认密码。（7）合理地利用键盘。 如何解决 And「oid 浏览器查看背景图片模糊的问题？这个问题是 devicePixelRatio 的不同导致的，因为手机分辨率太小，如果按照分辨率来显示网页，字会非常小，所以苹果系统当初就把 iPhone 4 的 960×640 像素的分辨率在网页里更改为 480 x 320 像素，这样 devicePixelRatio = 2 而 Android 的 devicePixe!Ratio 比较乱，值有 1.5、2 和 3。为了在手机里更为清晰地显示图片，必须使用 2 倍宽高的背景图末代替 img 标签（一般情况下都使用 2 倍）。 例如一个 div 的宽高是 100px × 100px，背景图必须是 200px × 200px，然后设置 backgroundsize:contain 样式，显示出来的图片就比较清晰了。 如何解决长时间按住页面出现闪退的问题？通过以下代码设直样式。 123element { -webkit-touch-callout: none;} 如何解决 iPhone 及 iPad 下输入框的默认内阴影问题？通过以下代码设置样式。 1234element { -moz-appearance: none; -webkit-appearance: none;} 在 iOS 和 Android 下，如何实现触摸元素时出现半透明灰色遮罩？通过以下代码设置样式 123element { -webkit-tap-highlight-color: rgba(255,255,255,0);} 在旋转屏幕时，如何解决字体大小自动调整的问题？通过以下代码设置样式 123html,body,form,fieldset,p,div,h1,h2,h3,h4,h5,h6 { -webkit-text-size-adjust: 100%;} 如何解决 Android 手机圆角失效问题？通过 background-clip: padding-box 为 失效的元素设直样式。 如何解决 iOS 中 input 键盘事件 keyup 失效问题？通过以下代码设置样式 123456&lt;input type=&quot;text&quot; id=&quot;testInput&quot; /&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&quot;testInput&quot;).addEventListener(&quot;input&quot;, function(e) { var value = e.target.value; });&lt;/script&gt; 如何解决 iOS 设置中 input 按钮样式会被默认样式覆盖的问题？设置默认样式为 none。解决方式如下。 123456input,textarea{ border: 0; -webkit-appearance: none; -moz-appearance: none; appearance: none;} 如何解决通过 transform 进行 skew 变形、rotate 旋转会出现锯齿现象 的问题？通过以下代码设置样式 第 29 章 公司常问问题1、你觉得前端工程师的价值体现在哪些方面？ 体现在以下方面。（1）为优化用户体验提供技术支持（交互部分）。（2）为浏览器之间的兼容性提供支持。（3）为提高用户浏览速度（浏览器性能）提供支持。（4）为跨平台（多端）、其他基于 webkit 或其他渲染引擎的应用（应用嵌入，如微信小程序）提供支持。（5）为展示数据提供支持（大数据可视化）。 2、你是如何认识前端界面工程师这个职位的？ 前端工程师是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。前端工作可以实现界面交互，提升用户体验。有了 Node.js ，前端可以实现服务端的一些工作。前端工程师的职责就是能让产品从 90 分提升到 100 分，甚至更好。前端工程师的岗位职责包括以下几方面。（1）参与项目开发，快速，高质量地完成实现效果图，精确到 1px。（2）与团队成员，UI 设计人员、产品经理沟通。（3）做好页面结构，页面重构，提升用户体验。（4）处理 hack、兼容性问题，写出优美的代码。（5）针对服务器的优化，拥抱最新的前端技术。 3、说说你对前端架构师的理解 前端架构师的职责如下。（1）负责前端团队的管理以及与其他团队的协调工作，提升团队成员能力和工作效率。（2）带领团队完成研发工具及平台前端部分的设计、研发和维护。（3）带领团队进行前端领域前沿技术的研究及新技术的调研，保证团队的技术领先。（4）负责前端开发规范的指定、功能的模块设计、公共组件的搭建等工作，并组织培训。 4、什么样的前端代码是好的？ 好的代码应具备高复用率、低耦合度、易维护性、易扩展性等特点。 5、平时如何管理你的项目？ 主要从以下方面进行管理。（1）前端团队必须确定好全局样式（globe.css）、编码模式（utf-8）等。（2）编写习惯必须统一（例如 JavaScript 中都采用面向对象式的写法，css 中单样式都写成一行）。（3）标注样式编写人，各模块都及时标注（标注关键样式调用的地方）。（4）标注页面（例如页面、模块的开始和结束）。（5）把 CSS、HTML（模板）和 JavaScript 代码分文件夹进行存放，命名要表达出文件模块的功能，并要统一（如 header.css）。（6）图片采用优化后的图片，并放在 images 文件夹内。 6、介绍一下最能体现你能力的项目？ 我做过一个外卖项目，这个项目是使用 Vue.js 开发的，使用 vue-cli 和 webpack 自动化构建工具构建的项目，通过组件化开发，实现对组件的高度复用。运用 VueX 管理状态，使各个组件间能够共享数据。使用 Vue.js 自带的 transition 动画组件实现过渡动画效果，在项目中运用路由对各组件按需加载，从而提高效率。自定义了很多可以复用到别的项目中的基础组件，例如 modal 提示信息组件、loading 组件、星级评分组件、滚动列表组件、使用 vue-lazyload 实现图片懒加载，使用 vue-scoller 实现下拉刷新、上拉加载更多，使用 axios 实现异步请求，加载数据等。 7、你的项目与同类项目相比有哪些亮点？ 同类项的项目是使用传统方式开发的。我们这个项目是使用 Vue.js 开发的。与传统的开发方式相比，Vue.js 开发的优势还是很明显的。因为在传统的开发方式中，DOM 节点操作比较多，对节点进行操作会导致浏览器对页面的重绘。但是 Vue.js 是数据驱动的 MVVM 框架，并且在 Vue.js2.0 中运行了虚拟 DOM 的技术，最大限度地减少了浏览器的重绘，所以运行效率很高。 Vue.js 是基于组件化开发的，代码的可维护性更高，而且在项目中我们运用 VueX 管理状态，使数据交互的实现变得更加简单。另外，在路由中，使用按需加载的方式加载组件，使组件的访问效率更高。 8、你们团队使用的后端语言是什么？如何与后端协同工作？ 后端语言是 PHP。我跟他们配合方式一般是，我这边规定各个接口的 JSON 数据结构，后端工程师提供数据接口，他们会给我一个数据接口的文档。拿到文档之后，对于各个数据接口，我首先会用 postman 测试一下，看它们是否正常工作。如果没问题，就用这些数据开发项目。 9、你们这个外卖项目是几个人开发的？是如何分工协作的？在开发过程中 遇到的问题是如何解决的？ 是两个人开发的。我主要负责开发首页和购物两个模块。首页主要就是通过接口获取数据，渲染页面。涉及的有几个主要的内容：轮播放果、 搜索功能、滚动加载更多等。 轮播图我用的是 swipper 插件，下拉加载更多使用 vue-scroller 实现，并且运用 vue-lazyload 实现了图片懒加载。搜索模块在后台提供了一个搜索接口，有一个参数是用户输入的关键字 ，通过发送这个请求接口，获取后台数据，并渲染到页面中 。购物页面有几个地方不太好设计。比如选择商品时，右侧商品列表和左侧商品类目的一个联动效果。单击左侧 ，右侧商品滚动到对应位直，右侧商品滚动，左边类目对应 进行高亮显示。我当时是使用 Better-scroll 实现的。里面有接口可以监听滚动的距离， 然后通过计算距离，从而计算出索引值，将对应索引值的类目高亮显示。还有一个难点是购物车组件。 购物车组件涉及多组件的通信，开始我是使用组件间的传参方式实现的。父子组件向子组件传递的参数通过 props 接收， 子组件向父组件传递的参 数通过 $emit 进行事件传递，父组件监听事件。 这种方式代码可读性差，不利于后期维护。 后来使用 VueX 管理状态，把需要在多个组件通用的数据放入 store 中，然后通过 muatation 进行统一管理。 10、你感觉你在项目开发中的贡献有多大？ 这个项目是我们整个公司同仁共同努力的结果。在项目上线的过程中，产品运营团队、设计团队，以及前后端开发团队都付出了巨大的努力，我只是有幸成为团队的 一员而已。在开发的过程中，我有意识地让自己承担更多工作，比如我会积极参与那些有挑战的、较为复杂的模块来做。 一方面可以为公司贡献更多价值，另一方面也更有利于自己的成长。 11、你做前端开发多长时间了？ 两年了，现在前端技术发展非常快，需要快速学习、持续学习的能力。虽然很累，但是我非常喜欢这个工作，所以在工作之余我一直坚持自学新技术，Vue、Angualr 都是我在工作后业余时间自学的，后来把它们运用到了项目中。 12、你是学什么专业的？都学习了哪些课程？ 我是计算机专业的。 主要学习过高数、线性代数、离散数学、 C 语言、数据结构、SQL Server 数据库等。大学里学的内容比较陈旧，离工作的需求有距离，所以我自学了前端知识，然后进入这个行业，一直做到现在。 13、前端是在大学里学的吗？ 是在大学期间自学的，开始看一些视频资料，后来查文档，看 GitHub 上的一些开源项目。如果在开发中遇到问题，通过 Google 或百度搜索寻找解决问题的方案等。 14、你一直在做前端开发吗？ 大学毕业后就一直做前端开发。开始使用 HTML、css 、jQuery 做 PC 端页面，做一些动画效果，现在通常用 MVVM 框架做项目。 15、说说你一天的工作内容。 每天 9 点左右到公司，领导会分配任务，然后与 PM （产品经理）确认需求，与 UI（用户界面）设计师确定一些标注不详的样式。明确了之后 ，自己选择一个分支开始开发，做完了让领导审查代码。他觉得合格了就合并，如果不合格，他会给我指出 Bug, 然后我再修改。 16、谈谈你的期望月薪 首先，我上一份工作的月薪是 1.2 万元，并且做了一年多了，这一年多我没有在团队掉队，说明我每个月的工作最起码是值 1.2 万元的。但是，在这一年中我的技术又有了很大的进步，比如学会了使用 WebPack 前端自动化构建工具，使用 Vue、VueX 等 MVVM 框架做项目。而且我的自主学习能力很强，对新技术有浓厚的兴趣，喜欢钻研新技术，这保证了我在未来的增值能力。所以我的期望月薪是 1.2 万元，因为我的学习能力保证了我的技术会持续增值，会为公司创造更大的价值。 17、你的项目用了 哪些插件？ 使用了以下插件。使用 swipper 制作轮播图。使用 better-scroll 制作滚动列表。使用 vue-scroller 实现下拉加载更多。使用 vue-lazyload 实现图片懒加载。使用 vue-router 实现路由跳转。使用 axios 请求后端数据接口。 18、工作中，你是如何与 RD （后端 ）工程师对接的？ 我们的后端工程师还是比较照顾我，基本上我需要什么样的数据接口，他就在接口中返回我需要的数据结构，所以，我会把各部分数据结构的要求告诉后端工程师。后端工程师写好接口后会给我一个接口文档，然后我会使用 postman 测一下 。如果没问题，就着手开发；如果有问题，再把问题反馈给他，让他修改。 19、你们公司的前端与后端是完全分离吗？ 是完全分离的，在不同的分支上开发。 20、你了解后端的语言吗？ 使用 express 和 MySQL 实现过注册登录功能，并且写了一个博客系统。对于基本的增、删 、 改、 查操作有一定经验。并且写过简单的数据接口，对前后端交王有新的认识 21、说说你们团队的项目开发流程。 我们公司是产品经理和运营确定需求，然后 PM （产品经理）会给出原型图 。 之后用户页面设计师会出效果图。在这个过程中经理会根据要求确定技术选型。效果图出来之后，我们开发人员介入开始开发。经理会根据每个人的能力分配工作量。我开发的时候会自己找一个分支，然后自己开发，自己模拟数据。前端页面效果做完之后，会把数据结构告诉 RD （后端）工程师 ，让他们做数据接口。 他们做好之后会给我一个接口文档，我拿到接口文档后，会先用 postman 测试一下，如果通过了，就把测试的数据都换成后台接口的真实数据。我自己测试一下功能，如果没问题，就让我们经理审核代码，审核通过了就会合并分支程序。 22、如果通过这次面试 ，我们单位录用了你，但工作一段时间后发现你根本不适合这个职位，你怎么办？ 如果一段时间后发现工作不适合我，我会有两种选择。如果我确实热爱这个职业，那我就要不断学习，虚心向领导和同事学习业务知识与处事经验，了解这个职业的精神内涵和职业要求，力争缩小差距。如果我觉得这个职业可有可无，那还是趁早换个职业，去发现适合自己并且热爱的职业，对自己的发展前途也会大，对单位和个人都有好处。 23、在完成某项工作时，你认为领导要求的方式不是最好的，自己还有更好的方法，你应该怎么做？ 原则上，我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。如果领导没有采纳我的建议，我也同样会按领导的要求认真地完成这项工作。还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。 24、如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？ 首先，我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。 如果我无能力负责，希望单位帮助解决。其次，分清责任，各负其责。如果是我的责任，我甘愿受罚；如果是我负责的一个团队中别人的失误，自己也不能幸灾乐祸，作为一个团队，需要互相提携、共同完成工作，安慰同事并且帮助同事查找原因、总结经验。最后，总结经验教训，一个人的一生不可能不犯错误，重要的是，能从自己的或者别人的错误中吸取经验教训，并在今后的工作中避免发生同类的错误。检讨自己的工作方法、 分析问题的深度和力度是否不够，导致出现了本可以避免的错误。 25、如果你做的一项工作受到上级领导的表扬，但你的主管领导说是他做的，你该怎样处理？ 我首先不会找那位上级领导说明这件事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种。如果我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。若他不知悔改，还变本加厉，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。 26、谈谈你对跳槽的看法。 正常的 “跳槽”能促进人才合理流动，应该支持。 然而，频繁的跳槽对单位和个人双方都不利，应该反对。 27、工作中如果你难以和同事、上司相处，你该怎么办？ 首先，我会服从领导的指挥，配合同事的工作。然后，我会从自身找原因，仔细分析是不是自己的工作做得不好，让领导不满意，让同事看不惯。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。其次，如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，有问题就及时改正。最后，作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信， 他们会看见我在努力，总有一天会对我微笑的。 28、假设你在某单位工作，成绩比较突出，得到领导的肯定。但同时你发现同事们越来越孤立你，你如何看待这个问题？你准备怎么办？ 成绩比较突出，得到领导的肯定是件好事情，以后我会更加努力。关于这个问题，首先，我会检讨一下自己是不是对工作的热心度超过了同事间交往的热心，以后加强同事间的交往。然后，工作中，切勿伤害别人的自尊心。 最后，不在领导前拨弄是非 。 29、最能概括你自己的 3 个词是什么？ 适应能力强，有责任心，做事有始终。 30、你通常如何面对别人的批评。 沉默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。我会等对方冷静下来再讨论。 31、怎样对待自己的失败？ 我们生来都不是十全十美的，我相信我有第二次机会改正我的错误。 32、什么会让你有成就感？ 为贵公司竭力效劳，尽我所能，出色地完成一个项目。 33、眼下你生活中最重要的是什么？ 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。 34、假如你晚上要送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？ 我觉得工作是第一位的，但朋友间的情谊也是不能偏庭的，这个问题我觉得要按照当时具体的情况来决定。如果我的朋友要搭乘晚上 ll 点钟的飞机，而我加班到 8 点钟就能够完成当天工作，那就最理想了，干完工作去机场，皆大欢喜。如果工作不是很紧急，加班仅仅是为了明天上班的时候能把报告文到办公室，那完全可以跟领导打声招呼，先去机场然后回来加班，晚点下班。如果工作很紧急，两者不可能兼顾的情况下，我觉得可以有两种选择。如果不是全单位都加班，可以找其他同事来接替自己的工作，自己去机场。如果找不到合适的人选，那只好忠义不能两全了，打电话向朋友解释一下 ，相信他会理解的。 35、你觉得压力最大的时候是什么时候？ 我觉得压力最大的时候是刚刚接受一个任务或者刚刚给自己制订了一个大目标的时候。 之所以这样，是因为我的一个习惯，任务开始的时候，我会逼着自己制订一个完美的计划，并且尽可能把各项工作都提前做好。比方说，当参加一个比赛的时候，我会在刚一确定参加比赛的那个阶段拼命准备，找资料，提前很长时间就模拟练习。这样，越到最后我反而越放松。","link":"/2020/02/13/Interview-Question4/"},{"title":"面闭 — JavaScript","text":"Ajax 请求的步骤第一步（得到 XMLHttpRequest） 第二步（打开与服务器的链接） 第三步（发送请求） xmlHttp.send(null);如果括号里不给 null 可能会造成部分浏览器无法发送； 第四步 在 xmlHttp 对象的一个事件上注册监听器： onreadstatechange 得到的 5 个状态 &gt;0状态：刚创建，还没有调用 open() 方法； &gt;1状态：请求刚开始，调用了open()方法，但是没有调用 send 方法； &gt;2状态：调用完了 send() 方法； &gt;3状态：服务器已经开始响应。但不表示响应结束； &gt;4状态：服务器响应结束！； 得到 xmlHttp 对象状态 var state = xmlHttp.redayState; // 可能是 0,1,2,3,4 得到服务器的响应状态码 var state = xmlHttp.status; // 可能是 200、404、500 得到服务器的响应内容 Ajax 的缺点(1)、ajax 不支持浏览器 back 按钮 (2)、安全问题 ajax 暴露了与服务器交互的细节。 (3)、对搜索引擎的支持比较弱 (4)、破坏了程序的异常机制 什么是 Ajax 和 JSON，它们的优缺点Ajax 全称 asynchronous JavaScript and XML，即异步 JavaScript 和 xml，用于在 web 页面中事先异步数据交互，实现页面局部刷新。 优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验。 缺点：对搜索引擎不友好，要实现 ajax 下的前后退功能成本较大，可能造成请求数量增加跨域问题限制； json 是一种轻量级的数据交换格式，ECMA 的一个子级 优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字） Ajax 请求的时候 get 和 post 方式的区别get 一般用来进行查询操作，url 地址有长度限制，请求的参数都暴露在 url 地址中，如果传递中文参数，需要自己进行编码操作，安全性低 post 请求方式主要提交数据，没有数据长度的限制，提交的数据内容存在于 http 请求体中，数据不会暴露在 url 地址中。 jsonp的原理，以及为什么不是真正的 ajaxjsonp 并不是一种数据格式，而 json 是一种数据格式，jsonp 是用来解决跨域获取数据的一种解决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上不是使用 ajax 技术。 阐述一下异步加载(1) 异步加载的方案：动态插入 script 标签 (2) 通过 ajax 去获取 js 代码，然后通过 eval 执行 (3) script 标签上添加 defer 或 async 属性 (4) 创建并插入 iframe，让它异步执行 js post 和 get 的区别，何时使用 postget：一般用于信息获取，使用 url 传递参数，对所有发送信息的数量也有限制，一般在 2000 个字符，有的浏览器 8000 个字符 post：一般用于修改服务器上的资源，对于发送的信息没有限制 在以下情况中，请使用 post 请求： (1) 无法使用缓存文件（更新服务器上的文件或数据库） (2) 向服务器发送大量数据（post 没有数据限制） (3) 发送包含未知字符的用户输入时，post 比 get 更稳定也更可靠 数组去重的方法排序方法 12345678910function distinct(arr){ var result = [] for(var i = 0;i &lt; arr.length; i++){ for(var j = i+1;j&lt;arr.length;j++){ j = ++i; } result.push(arr[i]) } return result;} 对象方法 1234567891011function unique(arr){ var res = [] var json = {} for(var i=0;i&lt;arr.length;i++){ if(!json[arr[i]]){ res.push(arr[i]) json[arr[i]] = 1; } } return res;} js 的作用域作用域说明：一般理解指一个变量的作用范围 1、全局作用域 （1）全局作用域在页面打开时被创建，页面关闭时被销毁 （2）编写在 script 标签中的变量和函数，作用域为全局，在页面的任意位置都可以访问到 （3）在全局作用域中有全局对象 window，代表一个浏览器窗口，由浏览器创建，可以直接调用 （4）全局作用域中声明的变量和函数会作为 window 对象的属性和方法保存 2、函数作用域 （1）调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁 （2）每调用一次函数就会被创建一个新的函数作用域，他们之间是相互独立的。 （3）在函数作用域中可以访问到全局作用域的变量，在函数外无法访问到函数作用域内的变量 （4）在函数作用域中访问变量、函数时，会先在自身作用域中寻找，若没有找到，则会到函数的上一级作用域中寻找，一直到全局作用域 说说你对闭包的理解说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量。 闭包的优点是可以避免全局变量的污染， 缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 闭包有三个特性： 1、函数嵌套函数 2、函数内部可以引用外部的参数和比变量 3、参数和变量不会被垃圾回收机制回收 请你谈谈 Cookie 的弊端cookie 虽然在持久保存客户数据提供了方便，分担了服务器存储的负担，但是有很多局限性。 1、每个域名下最多生成 20 个 cookie. 2、浏览器会清理 cookie ，IE、Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie. 3、cookie 最大大约为 4096 字节。 优点：极高的扩展性和可用性。 1、通过良好的编程，控制保存在 cookie 中的 session 对象的大小。 2、通过加密和安全传输技术（SSL），减少 cookie 被破解的可能性。 3、只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。 4、控制 cookie 的生命期，使之不会永远有效。盗窃者很可能拿到一个过期的 cookie。 缺点： 1、cookie 数量和长度的限制。 2、安全性问题。 3、有些状态不可能保存在客户端。 web storage和 cookie 的区别cookie 和 session 的区别1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上。 2、cookie 不是很安全，可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。 3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能。 4、单个 cookie 保存的数据不能超过 4k,一个站点最多保存20个 cookie。 使用 typeof bar === “object” 来确定 bar 是否是对象的潜在陷阱是什么？如何避免这个陷阱？123456789101112131415// 避免 null 返回 truevar bar = null;console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;)); // logs false// function 返回 turevar bar = function(){};console.log((bar !== null) &amp;&amp; ((typeof bar === &quot;object&quot;) || (typeof bar === &quot;function&quot;)));// 数组 返回 false var bar = [];console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;) &amp;&amp; (toString.call(bar) !== &quot;[object Array]&quot;));// jQconsole.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;) &amp;&amp; (! $.isArray(bar))); 下面的代码将输出什么到控制台，为什么12345678910(function(){ var a = b = 3; // b = 3;var a = b;})();console.log(&quot;a defined? &quot; + (typeof a !== 'undefined'));console.log(&quot;b defined? &quot; + (typeof b !== 'undefined'));// outputa defined? falseb defined? true 下面输出什么到控制台，为什么123456789101112131415161718192021var myObject = { foo: &quot;bar&quot;, func: function() { var self = this; console.log(&quot;outer func: this.foo = &quot; + this.foo); console.log(&quot;outer func: self.foo = &quot; + self.foo); (function() { console.log(&quot;inner func: this.foo = &quot; + this.foo); console.log(&quot;inner func: self.foo = &quot; + self.foo); }()); }};myObject.func();// 在ECMA 5之前，在内部函数中的this 将指向全局的 window 对象；/* * outer func: this.foo = bar * outer func: self.foo = bar * inner func: this.foo = undefined * inner func: self.foo = bar */ 封装JavaScript源文件的全部内容到一个函数块有什么意义及理由这是一个越来越普遍的做法，被许多流行的JavaScript库（jQuery，Node.js等）采用。这种技术创建了一个围绕文件全部内容的闭包，也许是最重要的是，创建了一个私有的命名空间，从而有助于避免不同JavaScript模块和库之间潜在的名称冲突。 这种技术的另一个特点是，允许一个易于引用的（假设更短的）别名用于全局变量。这通常用于，例如，jQuery插件中。jQuery允许你使用jQuery.noConflict()，来禁用 $ 引用到jQuery命名空间。在完成这项工作之后，你的代码仍然可以使用$ 利用这种闭包技术，如下所示： 1(function($) { /* jQuery plugin code referencing $ */ } )(jQuery); 在 JavaScript 源文件的开头包含 use strict 意义和好处 use strict 是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。 严格模式的一些主要优点包括： 使调试更加容易。 防止意外的全局变量。 消除 this 强制 不允许重复的属性名称或参数值。 使eval() 更安全。 在 delete使用无效时抛出错误。 考虑以下两个函数。它们会返回相同的东西吗？ 为什么相同或为什么不相同12345678910111213141516171819202122function foo1(){ return { bar: &quot;hello&quot; };}function foo2(){ return { bar: &quot;hello&quot; };}console.log(foo1());console.log(foo2());// output// Object {bar: &quot;hello&quot;};// undefined// 代码行上没有其他任何代码，分号会立即自动插入到返回语句之后。 NaN 是什么？它的类型是什么？你如何可靠地测试一个值是否等于 NaNNaN 属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字（例如， “abc” / 4），要么是因为运算的结果非数字（例如，除数为零）。 NaN 是 Number; 检测isNaNNumber.isNaN() 下列代码将输出什么？并解释原因console.log(0.1 + 0.2);console.log(0.1 + 0.2 == 0.3); JavaScript中的数字和浮点精度的处理相同，因此，可能不会总是产生预期的结果。 9.讨论写函数 isInteger(x) 的可能方法，用于确定x是否是整数 在ECMAScript规格说明中，整数只概念上存在：即，数字值总是存储为浮点值。 function isInteger(x) { return (x^0) === x; }function isInteger(x) { return Math.round(x) === x; }function isInteger(x) { return (typeof x === ‘number’) &amp;&amp; (x % 1 === 0);function isInteger(x) { return parseInt(x, 10) === x; } // 目变得足够大，为指数形式（例如， 1e+21） Math.ceil() 和 Math.floor() 在上面的实现中等同于 Math.round()。 下列代码行1-4如何排序，使之能够在执行代码时输出到控制台？ 为什么(function() { console.log(1); setTimeout(function(){console.log(2)}, 1000); setTimeout(function(){console.log(3)}, 0); console.log(4);})(); output1432 浏览器有一个事件循环，会检查事件队列和处理未完成的事件。例如，如果时间发生在后台（例如，脚本的 onload 事件）时，浏览器正忙（例如，处理一个 onclick），那么事件会添加到队列中。当onclick处理程序完成后，检查队列，然后处理该事件（例如，执行 onload 脚本）。同样的， setTimeout() 也会把其引用的函数的执行放到事件队列中，如果浏览器正忙的话。当setTimeout()的第二个参数为0的时候，它的意思是“尽快”执行指定的函数。具体而言，函数的执行会放置在事件队列的下一个计时器开始。但是请注意，这不是立即执行：函数不会被执行除非下一个计时器开始。这就是为什么在上述的例子中，调用 console.log(4) 发生在调用 console.log(3) 之前（因为调用 console.log(3) 是通过setTimeout被调用的，因此会稍微延迟）。 写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构function isPalindrome(str) { str = str.replace(/W/g, ‘’).toLowerCase(); return (str == str.split(‘’).reverse().join(‘’));} console.log(isPalindrome(“level”)); // logs ‘true’console.log(isPalindrome(“levels”)); // logs ‘false’console.log(isPalindrome(“A car, a man, a maraca”)); // logs ‘true’ 写一个 sum方法，在使用下面任一语法调用时，都可以正常工作console.log(sum(2,3)); // Outputs 5console.log(sum(2)(3)); // Outputs 5 柯里化 1234567function sum(x) { if (arguments.length == 2) { return arguments[0] + arguments[1]; } else { return function(y) { return x + y; }; }} 1234567function sum(x, y) { if (y !== undefined) { return x + y; } else { return function(y) { return x + y; }; }} 下面console的输出结果是。 12345678var name = “one”;var User =function ( ) { this.name = “two”;}var obj =User( );console.log(name); 答案：two 阅读如下代码，请问两处console的输出结果。 12345678910var Product = { count: 1, getCount: function( ) { return this.count++; }};console.log(Product.getCount( ));var func = Product.getCount;console.log(func( )); 答案： 1 NaN Array.prototype.slice.call(arr，2)方法的作用是：答案：以arr为基础，并调用其slice方法，截取从索引为2到末尾位置 http请求中GET和POST方法的区别是()。答案：get是从服务器上获取数据，post是向服务器传送数据。get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTPpost机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。（这里有看到其他文章介绍get和post的传送数据大小跟各个浏览器、操作系统以及服务器的限制有关）get安全性非常低，post安全性较高。 简述浏览器发起一个网络请求（HTTP请求事务）后，都经历了哪些步骤：输入网址：输入url地址域名解析：浏览器按照顺序解析，自身的dns缓存——客户端自身的dns缓存——本地host文件——路由器缓存建立连接：浏览器获得域名对应的ip地址后，发起tcp三次握手，将客户端与服务端建立连接（http基于tcp协议，tcp为传输层协议）返回数据：服务端接收请求并将数据返回给浏览器处理数据：浏览器拿到返回资源后进行客户端渲染，将完整页面呈现给用户。 请为所有数组对象添加一个通用的 remove 方法，参数是数组元素的索引值，实现删除指定数组元素的索引的功能。（可以写伪代码）。例如：var arr=[1,2,3,4,5,6]; arr.remove(3); 修改后的arr为［1，2，3，5，6］。12345678910// 答案：思想就是找到要删除的元素，后面的元素依次前移Array.prototype.remove= function(i){ if(isNaN(i) || i &lt; 0 || i &gt;=this.length){ return this; } for(var j=i; j&lt;this.length-1; j++){ this[j] = this[j+1]; } this.length-=1;}; 手写实现一个 new 操作符 new 操作符做了这些事： 它创建了一个全新的对象 它会被执行 [[Prototype]] （也就是 __proto__）链接 它使 this 指定新创建的对象 通过 new 创建的每个对象将最终被 [[Prototype]] 链接到这个函数的 prototype 对象上 如果函数没有返回对象类型 Object （包含 Function,Array,Date,RegExg,Error），那么 new 表达式中的函数调用将返回该对象引用 123456789101112131415function New(func) { var res = {}; if(func.prototype !== null){ res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments,1)); if((typeof ret === 'object' || typeof ret === 'function') &amp;&amp; ret !== null){ return ret; } return res;}var obj = New(A,1,2);// equals tovar obj = new A(1,2); 实现一个 JSON.stringify JSON.stringify(value [,replacer[,space]]) Boolean | Number | String 类型会自动转换成对应的原始值 undefined、任意函数以及 symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null （出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。 123456789101112131415161718192021222324252627function jsonStringify(obj){ let type = typeof obj; if(type !== 'object'){ if(/string|undefined|function/.test(type)){ obj = '&quot;&quot;' + obj + '&quot;&quot;' } return String(obj); }else{ let json = []; let arr = Array.isArray(obj); for(let k in obj){ let v = obj[k]; let type = typeof v; if(/string|undefined|function/.test(type)){ v = '&quot;&quot;' + v + '&quot;&quot;'; }else if(type === &quot;object&quot;){ v = jsonStringify(v); } json.push((arr ? &quot;&quot; : '&quot;' + k + '&quot;:') + String(v)); return (arr ? &quot;[&quot;:&quot;{&quot;) + String(json) + (arr ? &quot;]&quot; : &quot;}&quot;) } }}jsonStringify({ x : 5}) // &quot;{&quot;x&quot;:5}&quot;jsonStringify([ 1, &quot;false&quot; , false]) // &quot;[1,&quot;false&quot;,false]&quot;jsonStringify({ b : undefined}) // &quot;{&quot;b&quot;:&quot;undefined&quot;}&quot; 实现一个 JSON.parse JSON.parse(text[,reviver]) eval1234567891011121314function jsonParse(json){ var rx_one = /^[\\],:{}\\s]*$/; var rx_two = /\\\\(?:[&quot;\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/; var rx_three = /&quot;[^&quot;\\\\\\n\\r]*&quot;|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g; var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g; if( rx_one.test(json.replace(rx_two,&quot;@&quot;).replace(rx_three,&quot;]&quot;).replace(rx_four,&quot;&quot;)) ){ return eval(&quot;(&quot;+json+&quot;)&quot;); }}jsonParse(JSON.stringify({ x : 5})); // Object { x: 5}jsonParse(JSON.stringify([ 1,'false',false])) // [1, &quot;false&quot; ,false]jsonParse(JSON.stringify({ b : undefined})) // Object { b : &quot;undefined&quot;} Function12var jsonStr = '{ &quot;age&quot;: &quot;20&quot;, &quot;name&quot;: &quot;jack&quot;}'var json = (new Function('return' + jsonStr ))(); 实现一个 call 或 applyFunction.callcall 核心： 将函数设为对象的属性 执行&amp;删除这个函数 指定 this 到函数并传入给定参数执行函数 如果不传入参数，默认指向为 window 12345678910111213141516171819202122232425262728// 简单版var foo = { value: 1, bar: function(){ console.log(this.value) }}foo.bar() //1// 完善版Function.prototype.call2 = function(content = window){ content.fn = this; let args = [...arguments].slice(1); let result = content.fn(...args); delete content.fn; return result;}let foo = { value: 1;}function bar(name , age){ console.log(name); console.log(age); console.log(this.value);}bar.call2(foo,'black' , '18'); // back 18 1 Function.apply 的模拟实现 123456789101112Function.prototype.apply2 = function (context = window){ context.fn = this let result; // 判断是否有第二个参数 if(arguments[1]){ result = context.fn(...arguments[1]) }else{ result = context.fn() } delete content.fn; return result;} 实现一个 Function.bind()1234567891011121314151617Function.prototype.bind2 = function( content ){ if(typeof this != 'function'){ throw Error(&quot;not a function&quot;) } let fn = this; let args = [...arguments].slice(1); let resFn = function(){ return fn.apply(this instanceof resFn ? this : content,args.concat(...arguments)) } function tmp() {} tmp.prototype = this.prototype; resFn.prototype = new tmp(); return resFn;} 实现一个继承核心实现是：用一个 F 空的构造函数取代执行了 Parent 这个构造函数 1234567891011121314151617181920212223242526272829function Parent(name) { this.name = name;}Parent.prototype.sayName = function(){ console.log('parent name', this.name);}function Child(name,parentName){ Parent.call(this,parentName); this.name = name;}function create(proto) { function F(){} F.prototype = proto; return new F();}Child.prototype = create(Parent.prototype);Child.prototype = sayName = function(){ console.log('child name' , this.name);}Child.prototype.constructor = Child;var parent = new Parent('father');parent.sayName();var child = new Child('son','father'); 实现一个JS函数柯里化函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。 通用版1234567891011121314151617181920212223function curry(fn , args) { var length = fn.length; var args = args || []; return function(){ newArgs = args.concat(Array.prototype.slice.call(arguments)); if(newArgs.length &lt; length){ return curry.call(this,fn,newArgs); }else{ return fn.apply(this,newArgs); } }}function multiFn(a, b, c){ return a * b * c;}var multi = curry(multiFn);multi(2)(3)(4);multi(2,3,4);multi(2)(3,4);multi(2,3)(4); ES612345678const curry = (fn,arr = []) =&gt; (...args) =&gt; ( arg =&gt; arg.length === fn.length ? fn(...arg) : curry(fn,arg))([...arr,...args])let curryTest = curry((a,b,c,d) =&gt; a + b + c + d)curryTest(1,2,3)(4)curryTest(1,2)(4)(3)curryTest(1,2)(3,4) 手写一个Promise(中高级必考)Promise/A+ 规范： 三种状态 pending|fulfilled(resolved)|rejected 当处于 pending 状态的时候，可以转移到 fulfilled(resolved) 或者 rejected 状态 当处于 fulfilled( resolved ) 状态或者 rejected 状态的时候，就不可变 必须有一个 then 异步执行方法， then 接受两个参数且必须返回一个 promise 面试够用版123456789101112131415161718192021222324252627282930313233343536373839404142function myPromise(constructor){ let self = this; self.status = &quot;pending&quot; // 定义状态改变前的初始状态 self.value = undefined; // 定义状态为 resolved 的时候的状态 self.reason = undefined; // 定义状态为 rejected 的时候的状态 function resolve(value){ // 两个 === pending 保证了状态的改变是不可逆的 if(self.status === 'pending'){ self.value = value; self.status = 'resolved'; } } function reject(reason){ // 两个 === pending，保证了状态的改变是不可逆的 if(self.status === 'pending'){ self.reason = reason; self.status = &quot;rejected&quot;; } } // 捕获构造异步 try{ constructor(resolve,reject); }catch(e){ reject(e) }}myPromise.prototype.then = function(onFullfilled,onRejected){ let self = this; switch(self.status){ case &quot;resolved&quot;: onFullfilled(self.value); break; case &quot;rejected&quot;: onRejected(self.reason) break; default: }} 大厂专供版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const PENDING = 'pending';const FULFILLED = 'fulfilled';const REJECTED = 'rejected';function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected 状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储 fulfilled 状态对应的 onFulfilled 函数 that.onRejectedCallbacks = []; // 存储 rejected 状态对应的 onRejected 函数 function resolve(value){ // value 成功态时接收的终值 if(value instanceof Promise){ return value.then(resolve,reject) } // 确保 onFulfilled 和 onRejected 方法异步执行,且应该在 then 方法被调用事件轮询循环之后新执行栈中。 setTimeout(()=&gt;{ // 调用 resolve 回调对应 onFulfilled 函数 if(that.status === PENDING){ // 只能由 pendding 状态 =&gt; fuifilled 状态（避免调用多次 resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb = &gt; cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() =&gt; { // 调用 reject 回调对应 onRejected 函数 if(that.status === PENDING ){ that.status = REJECTED that.reason = reason; that.onRejectedCallbacks.forEach(cb = &gt; cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 try{ excutor(resolve,reject); }catch(e){ reject(e); }}Promise.prototype.then = function(onFulfilled,onRejected){ const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; { throw reason;} if(that.status === FULFILLED){ // 成功态 return newPromise = new Promise((resolve,reject) =&gt; { setTimeout(()=&gt;{ try{ let x = onFulfilled(that.value); resolvePromise(newPromise,x,resolve,reject) }catch(e){ reject(e); } }) }) }}if(that.status === REJECTED){ return newPromise = new Promise((resolve,reject) =&gt;{ setTimeout(() =&gt; { try{ let x = onFulfilled(that.value); resolvePromise(newPromise,x,resolve,reject) }catch{ reject(e); } }) })}if(that.status === PENDING){ // 等待态 return newPromise = new Promise((resolve,reject) =&gt; { that.onFulfilledCallback.push((value) =&gt; { try{ let x = onFulfilled(that.value); resolvePromise(newPromise,x,resolve,reject) }catch{ reject(e); } }) that.onRejectedCallbacks.push((reason) =&gt; { try{ let x = onFulfilled(that.value); resolvePromise(newPromise,x,resolve,reject) }catch{ reject(e); } }) })} 手写防抖(Debouncing)和节流(Throttling)12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 防抖动函数function debounce(fn,wait=50,immediate){ let timer; return function(){ if(immediate){ fn.apply(this,arguments); } if(timer) clearTimeout(timer); timer = setTimeout(()=&gt;{ fn.apply(this,arguments) },wait) }}// 简单的节流函数:function throttle(fn,wait){ let prev = new Date(); return function(){ const args = arguments; const now = new Date(); if(now - pre &gt; wait){ fn.apply(this,args); prev = new Date(); } }}// 通过第三个参数切换模式const throttle = function(fn, delay, isDebounce){ let timer let lastCall = 0 return function (...args){ if( isDebounce ){ if( timer ) clearTimeout(timer) timer = setTimeout (() =&gt;{ fn (...args) }, delay) }else{ const now = new Date().getTime() if(now - lastCall &lt; delay) return lastCall = now fn(...args) } }} 手写一个JS深拷贝1234567891011121314151617// 极简版var newObj = JSON.parse( JSON.stringify(someObj));// 面试够用版function deepCopy(obj){ // 判断是否是简单数据类型 if(typeof obj == &quot;object&quot;){ var result = obj.constructor == Array ? [] : {}; for ( let i in obj ){ result [i] = typeof obj [i] == &quot;object&quot; ? deepCopy (obj [i]) :obj [i];} }else{ // 简单数据类型 直接 == 赋值 var result = obj; } return result;} 实现一个instanceOf123456789function 实现一个instanceOf(left,right){ let proto = left.__proto__; let prototype = right.prototype while(true){ if(proto === null) return false if(proto === prototype) return true proto = proto.__proto__; }} 相关资料 高频前端开发面试问题√ 「中高级前端面试」JavaScript手写代码无敌秘籍√25 个最基本的 JavaScript 面试问题及答案（上）√ 前端面试高频手写代码题25 个最基本的 JavaScript 面试问题及答案（下）58道Vue常见面试题集锦，涵盖入门到精通，自测 Vue 掌握程度由浅入深，66条JavaScript面试知识点和答案解析2 年前端面试心路历程（字节跳动、YY、虎牙、BIGO）蚂蚁、字节、滴滴面试经历总结(都已过)45道JS能力测评经典题总结 07—47道基础的VueJS面试题(附答案)","link":"/2020/07/30/Interview-Question7/"},{"title":"Vue.js 项目实战","text":"Vue 开发入门Vue 是一个专注于构建 Web 用户界面的 JavaScript 库。 1.1 为什么需要另外一个前端框架Vue 易用、灵活、速度快、还提供了许多功能和可选工具，这使得开发者能够快速地构建一个现代 web 应用。Vue 的作者尤雨溪将其称为渐进式框架。 Vue 遵循渐进增量的设计原则，其核心库专注于用户界面，使得现有的项目可以方便地集成使用 Vue。 Vue 既可以构建出很小的原型，又可以构建出复杂的大型 web 应用。 Vue 非常容易上手 —— 初学者能轻松掌握 vue，而已经熟悉 Vue 的开发者则可以在实际项目中快速发挥出它的作用。 Vue 整体上遵循 MVVM（Model-View-ViewModel，模型 - 视图 -视图模型）架构，也就是说 View（用户界面或视图）和 Model（数据）是独立的，ViewModel（Vue）是 View 和 Model 交互的桥梁。Vue 对 View 和 Model 之间的更新操作做了自动化处理，并且已经为开发者进行了优化。 Vue 还吸收了其他类似框架（ 如 React、Angular、Polymer）的精华。 Vue 核心功能概述 一个响应式的数据系统，能通过轻量级的虚拟 DOM 引擎和最少的优化工作来自动更新用户界面。 灵活的视图声明，包括优雅友好的 HTML 模板、JSX（在 JavaScript 中编写 HTML 的技术）以及 hyperscript 渲染函数（完全使用 JavaScript ）。 由可维护、可复用组件组成的组件化用户界面。 官方的组件库提供了路由、状态管理、脚手架以及更多高级功能，使 Vue 成为了一个灵活且功能完善的前端框架。 Weex、NativeScript 1.1.2 兼容性需求Vue 不支持 Internet Explorer 8 以下版本，因为 Vue 使用了 JavaScript 中相对较新的特性，比如 Object.defineProperty，而它们在老版本的浏览器中是无法 polyfill 的。 编译器 Babel ,它编译过的代码可以很好地运行在老版本浏览器中。 1.3 创建一个应用整个库都是基于 Vue 实例的，而实例是 View 和 Model（数据）交互的桥梁。因此需要创建一个新的 Vue 实例来启动应用。 1234567891011// 创建 Vue 实例var app = new Vue({ // 根 DOM 元素的 CSS 选择器 el: '#root', // 一些数据 data(){ return { message: 'Hello Vue.js' } }}) 使用关键字 new 调用 Vue 构造器创建了一个新的实例。Vue 构造器有一个参数 —— option 对象。该参数可以携带多个属性（称为选项）。 通过 el 选项，我们使用 CSS 选择器告知 Vue 将实例添加（挂载）到 Web 页面的哪个 DOM 元素中。也可以 Vue 实例的 $mount 的方法代替el选项：app.$mount(‘#root’)。 123456789var app = new Vue({ data(){ return { message: 'Hello Vue.js' } }})// 添加 Vue 实例到页面中app.$mount(&quot;#root&quot;); Vue 实例的大多数特殊方法和属性都是以美元符号（$）开头的。 在单个 Web 页面中，开发者可以添加任意多个 Vue 应用。只需要为每个应用创建出新的 Vue 实例并挂载到不同的 DOM 元素即可。当想要将 Vue 集成到已有的项目中时，这非常方便。 Vue 开发者工具 Vue 有一个官方调试工具，在 Chrome 中以扩展的方式呈现，名为 Vue.js devtools。通过该工具可以看到应用的运行情况，这有助于调试代码。可以在 Chrome 网上应用商品下载；如果使用 Firefox，则可以到 Firefox 附加组件 下载。使用 Chrome 版本的话，还需要进行额外的设置。在扩展设置中，启用 Allow access to file URLs 选项。这样调试工具就能在从本地磁盘打开的 Web 页面上检测 Vue 了。 可以将 devtools 选项卡拖放到喜欢的位置。建议将其放在靠前的位置，因为当 Vue 不处于开发模式或没有运行时，该选项卡在页面中是隐藏起来的 可以通过 name 选项修改 Vue 实例的名字： 1234var app = new Vue({ name : 'MyApp', // ...}) 当一个页面中有多个 Vue 实例时，这有助于直观地在开发者工具中找到具体的某个实例。 1.4 借助模板实现 DOM 的动态性模板是描述 View 最简单的方法，只需要少量额外的语法就能轻松实现 DOM 的动态更新。 1.4.1 文本显示文本插值用于在 Web 页面中显示动态的文本。文本插值的语法是在双花括号内包含单个任意类型的 JavaScript 表达式。当 Vue 处理模板时，该 JavaScript 表达式的结果将会替换掉双花括号标签。 123&lt;div id=&quot;root&quot;&gt; {{ message }}&lt;/div&gt; DOM 和 数据连通了 1app.message = 'Awesome!' 数据绑定，每当数据有改变时， Vue 都能够自动更新 DOM，Vue 框架中包含一个非常强大且高效的响应系统，能对所有的数据进行跟踪，并且能在数据发生改变时按需自动更新 View。 1.4.2 利用指令添加基本的交互Vue 中所有的指令命名都是带 V- 前缀的，并遵循短横线分隔式（kebab-case）语法。这个意味着要用短横线将单词分开。HTML 属性是不区分大小写的。 12345&lt;div id=&quot;root&quot;&gt; &lt;p&gt;{{message}}}&lt;/p&gt; &lt;!-- 添加一个文本输入框 --&gt; &lt;input v-model = &quot;message&quot;&gt;&lt;/div&gt; 双向数据绑定 v-model 项目 1：Markdown 笔记v-model 指令不限于文本输入使用。它同样可以用于其他元素，例如勾选框、单选按钮，甚至自定义组件。 2.1.3 预览面板计算属性 通过它可以定义一个新的属性，而该属性可以结合任意多个属性，并做相关转换操作。 计算属性的值基于它的依赖进行缓存，因此如果没有必要是不会重新运行函数的，从而有效防止无用计算； 当函数中用到的某个属性发生了改变，计算属性的值也会根据需要自动更新； 计算属性可以如其他普通属性一起使用（可以在其他计算属性中使用计算属性）； 计算属性只有真正用于应用中时，才会进行计算操作。 在应用内，不建议使用 v-html 指令对用户提供的内容做 HTML 插值。这是因为用户可能会在标签中编写不怀好意、会被执行的 JavaScript 代码。当然对普通文本做插值是安全的，因为 HTML 不会被执行。 元素中的任意内容将被 v-html 指令的值替代。可以利用这一点来放置占位符内容。 对于文本插值，v-text 是一个与 v-html 等效的指令。它的行为与 v-html 类似，只不过会对 HTML 标签做转译处理，形同典型的文本插值。 2.1.4 保存笔记localStorage 保存笔记 侦听改变 监听器 watch 选项是一个字典，把被侦听属性的名字作为键，把侦听选项对象作为值。这个对象必须要一个 handler 属性，该属性可以是一个函数，也可以是一个方法的名字。这个处理函数将接收两个参数：被侦听属性的新值和旧值。 12345678910new Vue({ // 侦听 content 数据属性 watch: { content: { handler(val,oldVal){ console.log('new note:', val , 'old note' , oldVal) } } }}) 还有另外两个选项可以和 handler 一起使用。 deep 是一个布尔类型，告诉 Vue 以递归的方式侦听嵌套内部值的变化。 immediate 也是一个布尔类型，会立即触发调用处理函数，而不用等到属性第一次变化时才调用。 这两个选项的默认值都是 false,所以不需要使用的时候，可以完全忽略它们。 当不需要其他选项（例如 deep 或 immediate）时，这是侦听器中最常用的语法。 1234watch: { content(val,oldVal){ }} 保存笔记 1localStorage.setItem('content',val) 复用方法良好的编程准则之一：不要重复自己（DRY）,也称为一次仅且一次。开发者应该遵守这个准则。因此可以把一些逻辑写在可复用的函数里面：methods。 123456789101112new Vue({ watch:{ content: 'saveNote' }, methods:{ saveNote(val){ console.log('saving note:',this.content); localStorage.setItem('content',thie.content) } }}) 访问 Vue 实例 在 methods 内部，可以通过 this 关键字访问 Vue 实例，还可以访问 Vue 实例的其他属性或特殊函数。 基本上可以在任意函数（方法、处理函数或其他钩子）其中使用 this 关键字访问 Vue 实例。 生命周期钩子 生命周期钩子 每个 Vue 实例都严格遵守一个生命周期，包括多个环节：创建、挂载到页面、更新，最终被销毁。例如，在创建实例阶段，Vue 会将实例数据变成响应式数据。 钩子是一组特殊的函数，会在某个时间点被自动调用。这就允许我们自定义框架的逻辑。例如在创建 Vue 实例时调用一个方法。 在每个环节之中或之前，有很多钩子可以用于执行逻辑。 beforeCreate：在 Vue 实例被创建时（例如使用 new Vue（{ }））、完成其他事项之前调用。 created：在实例准备就绪之后调用。注意，此时实例还没有挂载到 DOM 中。 beforeMount：在挂载（添加）实例到 web 页面之前调用。 mounted：在实例被挂载到页面并且 DOM 可见时调用。 beforeUpdate：当实例需要更新时（一般来说，是当某个数据或计算属性发生改变时）调用。 updated：在把数据变化应用到模板之后调用。注意此时 DOM 可能还没有更新。 beforeDestroy：在实例销毁之前调用。 destroyed：在实例完全销毁之后调用。 在 JavaScript 中，如果值为 false、0、空字符传、null、undefined 或 NaN（不是一个数）,则它就是假值。在浏览器的本地存储数据中，如果对应的键不存在， localStorage.getItem() 方法会返回 null。 在数据中直接初始化 1234567new Vue({ data(){ return{ content:localStorage.getItem('content') || 'You can write in **markdown**' } }}) 2.2 多条笔记2.2.1 笔记列表添加新建笔记的方法每一条笔记都是具体如下数据的对象。 id ：笔记的唯一标识符。 title ：笔记的标题，用来显示在笔记列表中。 content ： 笔记的 Markdown 格式内容。 created ： 笔记创建的日期。 favorite ： 这是一个布尔型，用于表示是否收藏了笔记，已收藏的笔记显示在笔记列表的顶部。 选择当前时间（也就是从 1970 年 1 月 1 日 00:00:00 UTC 开始经过的毫秒数）作为区分笔记的唯一标识符，这是一种不错的方式。 用 v-on 实现按钮的单击事件 1&lt;button v-on:click=&quot;addNote&quot;&gt;&lt;/button&gt; 绑定事件 v-on: 简写 @ 1&lt;button @:click=&quot;addNote&quot;&gt;&lt;/button&gt; 用 v-bind 绑定属性 1&lt;button v-bind:title=&quot;notes.length + ' note(s) already'&quot;&gt; 属性绑定 v-bind: 简写 : 1&lt;button :title=&quot;notes.length + ' note(s) already'&quot;&gt; 当需要更新属性值的时候，用 v-bind 指令绑定的 JavaScript 表达式会自动重新运算。 用 v-for 显示列表 123&lt;div class=&quot;notes&quot;&gt; &lt;div class=&quot;note&quot; v-for=&quot;note of notes&quot;&gt;{{note.title}}&lt;/div&gt;&lt;/div&gt; 2.2.2 选择一条笔记动态 CSS 类 1&lt;div :class= &quot;{ one: note === selectedNote }&quot;&gt;&lt;/div&gt; 可以把静态与动态的 class 属性结合起来。建议将非动态的类放到静态的属性中，Vue 会对静态值做优化处理。 条件指令 v-ifv-else-ifv-else 标签不会出现在 DOM 中。用于对实际的元素进行重新组合。 侦听器默认值侦听目标对象的直接变化：赋值、数组添加、删除、移动。例如： 123456789// 赋值this.selectedId = 'abcd'// 在数组中添加或删除某项this.selectedId.push({...})this.selectedId.splice(index,1);// 数组排序this.notes.sore(...) 操作不会触发侦听器 123456// 给某个属性或者嵌套对象赋值this.myObject.someAttribute = 'abcd';this.myObject.nestedObject.otherAttribute = 42// 修改数组中某项的内容this.notes[0].content = 'new content' 这种情况下，需要在侦听器上添加 deep 选项 1234567watch: { notes: { handle : 'saveNotes', // 需要使用这个选项来监听数组中每个笔记属性的变化 deep: true }} 按照收藏、时间排序 1234567computed: { sortedNotes(){ return this.notes.slice() .sort((a,b) =&gt; a.created - b.created) .sort((a,b) =&gt; (a.favorite === b.favorite) ? 0 : a.favorite ? -1 : 1) }} 由于 sort 方法会直接修改源数组，这里使用 slice 方法创建新的副本。这样可以防止 notes 监听器。 创建日期过滤器 (1)引入 momentjs 1&lt;script src=&quot;https://unpkg.com/moment&quot;&gt;&lt;/script&gt; (2) 使用 Vue.filter 全局方法（不在 Vue 实例的创建代码中，比如位于文件开头）注册过滤器 1Vue.filter('date',time=&gt; mement(time).format('DD/MM/YY, HH:mm')) 1&lt;span class=&quot;value&quot;&gt;{{ selectedNote.created | date }}&lt;/span&gt; 文本统计 123456789101112// 计算换行符的格式 str.split(/\\r\\.|\\r|\\n/).length// 将换行符转换为空格str.replace(/\\n/g, '');// 排除开头和结尾的空格str.replace(/(^\\s*)|(\\s*$)/gi, '')// 将多个重复空格转换为一个str.replace(/\\s\\s+/gi, ' ');// 返回空格数量str.split(' ').length;// 字符数量str.split('').length 项目 2：城堡决斗游戏在 Vue 实例构造器之后，添加一个事件监听器到 window 对象中，监听浏览器窗口大小的变化。 1234// 窗口大小变化的处理window.addEventListener('resize', () =&gt; { state.wordRatio = getWorldRatio();} 3.3.3 万能的组件组件是构建应用的基础模块，是 Vue 应用的核心概念。组件是视图的一个个小部分，因此相对来说应用比较小、可复用，并且尽可能地自给自足。采用组件构建应用有助于应用的维护和升级，特别是当应用规模变大之后。实际上，这已经成为了高效、可控地开发大型 Web 应用的标准方法。 可以使用全局函数 Vue.component() 来注册组件。该函数接受两个参数：一个是注册组件的名称，另一个则是组件的定义对象本身，它与 Vue 实例使用相同的选项。 123Vue.component('top-bar',{ template:`&lt;div class='top-bar'&gt;Top bar&lt;/div&gt;`}) 使用 prop 进行父组件到子组件的通信 利用 props 选型可以将 prop 添加到组件中。 12345678Vue.component('top-bar',{ props: ['players','currentPlayerIndex','turn'], created(){ console.log(this.players); }})&lt;top-bar :turn=&quot;turn&quot; :current-play-index=&quot;currentPlayIndex&quot; :players=&quot;players&quot;&gt; 注意：由于 HTML 是不区分大小写的，建议对 prop 的名字使用短航线命名方法（kebab-case），而在 JavaScript 代码中使用驼峰式命名方法（camel-case）。 模板中的 prop 通过 players prop 显示玩家姓名。 123456template:`&lt;div class=&quot;top-bar&quot;&gt; &lt;div class=&quot;player p0&quot;&gt;{{ players[0].name}}&lt;/div&gt; &lt;div class=&quot;player p1&quot;&gt;{{ players[1].name}}&lt;/div&gt;&lt;/div&gt;` 在组件上监听原生事件为监听到组件的 click 事件，需要对 v-on 指令使用 .native 修饰符。 1&lt;card :def=&quot;testCard&quot; @click.navtive=&quot;handlePlay&quot;&gt; 使用自定义事件进行子组件到父组件的通信在组件内部，使用 $emit 这个特殊方法触发的事件可以被父组件捕获到。该方法接收一个固定的参数，即事件类型： 1this.$emit('play','orange',42) 可以使用名为 $on 的特殊方法监听自定义事件： 1234567891011this.$on('play', () =&gt; { console.log('Caught a play event!');})&lt;card v-on:play=&quot;handlePlay&quot;/&gt;&gt;// 简写：&lt;card @play=&quot;handlePlay&quot;/&gt;handlePlay(color,number){ console.log('handle play event','color = ' , color ,'number=',number)} Vue 的自定义事件与浏览器事件系统是完全分开的。方法 $on 和 $emit 并不是 addEventListener 和 dispatchEvent 的别名。这也解释了为什么在组建中需要使用 .native 修饰符来监听浏览器事件（如 click）。 大多数情况下，最好使用自定义事件完成组件之间的通信。 hand 组件的动画过度效果 动画效果：CSS 过渡结合 &lt;transition&gt; 组件。当添加或移除元素时，使用 v-if 或 v-show 指令来帮助实现 CSS 过渡。 12345// 应用状态集合var state = { // 用户界面 activeOverlay: null} 123&lt;transition&gt; &lt;hand v-if=&quot;!activeOverlay&quot;/&gt;&lt;/transition&gt; &lt;transition&gt; 特殊组件不会显示在 DOM 中。 当元素被添加到 DOM 时（进入阶段），&lt;transition&gt; 组件会自动将下列 CSS 类应用到元素中。 v-enter-active: 当进入过渡状态被激活时，会应用该类。在元素插入 DOM 之前，添加该类到元素中，并在动画结束时移除它。应该在这类中添加一些 transition CSS 属性并定义其过渡时长。 v-enter: 元素进入过渡的开始状态。在元素插入 DOM 之前，添加该类到元素中，并在元素被插入的下一帧移除。例如，你可以在这个类中设置透明为 0。 v-enter-to: 元素进入过渡的结束状态。在元素插入 DOM 后的下一帧添加，同时 v-enter 被移除。当动画完成后，v-enter-to 会被移除。 当元素从 DOM 中移除时（离开阶段），&lt;transition&gt; 组件会自动将下列 CSS 类应用到元素中。 v-leave-active:当离开过渡状态被激活时，会应用该类。当离开过渡触发时，添加该类到元素中，并在从 DOM 中移除元素时移除它。应该在这个类中添加一些 transition CSS 属性并定义其过渡时长。 v-leave：元素被移除时的开始状态。当离开过渡触发时，添加该类到元素中，并在下一帧移除。 v-leave-to：元素离开过渡的结束状态。在离开过渡触发后的下一帧添加，同时 v-leave 被移除。当从 DOM 中移除元素时，该类也会被移除。 在离开阶段，并不会立即从 DOM 中移除元素。当过渡结束后，才会将其移除，这样用户可以看到动画效果。 进入 v-enter-activev-enter v-enter-to透明度0 -&gt; 透明度1 离开 v-leave-activev-leave v-leave-to透明度1 -&gt; 透明度0 &lt;transition&gt; 组件会自动检测应用在元素上的 CSS 过渡效果的持续时间。 复用动画 123&lt;transition name=&quot;fade&quot;&gt; &lt;hand v-if=&quot;!activeOverlay&quot; :cards=&quot;testHand&quot;&gt;&lt;/transition&gt; 12345678910/* transition.css */.fade-enter-active,.fade-leave-acteve { transition: opacity 1s;}.fade-enter,.fade-leave-to { opacity: 0;} 现在只需要通过 &lt;transition name=&quot;fade&quot;&gt;标签就可以在任意元素上复用这个动画了。 贝塞尔曲线缓动函数，可以使得动画更加平滑。 12345678910.hand-enter-active .wrapper,.hand-leave-active .wrapper { transition: transform .8s cubic-bezier(.08,.74,.34,1); transform-origin: bottom center;}.hand-enter .wrapper,.hand-leave-to .wrapper { transition: rotate(90deg);} 为元素列表添加动画效果，需要使用另外一个特殊的组件 &lt;transition-group&gt;。当元素被添加、移除和移动时，该组件将对它的子元素做出动画效果。 跟 &lt;transition&gt; 元素不同的是，&lt;transition-group&gt;默认情况下会作为&lt;span&gt; 元素出现在 DOM 中。可以使用 tap prop 修改这个 HTML 元素。 123&lt;transition-group tag=&quot;ul&quot;&gt; &lt;li v-for=&quot;item of items&quot; /&gt;&lt;/transition-group&gt; &lt;transition-group&gt; 的子元素必须由唯一的 key 做标识。 1234// 指定过渡效果名称为 card &lt;transition-group name=&quot;card&quot; tag=&quot;div&quot; class=&quot;cards&quot;&gt; &lt;card v-for=&quot;card of cards&quot;&gt;&lt;/transition-grou 特殊的 key 属性当 Vue 更新存在于 v-for 循环中的 DOM 元素列表时，会尽量最小化应用于 DOM 的操作，例如添加和移除元素。大多数情况下，这是更新 DOM 的一种非常高效的方法，并且对性能的提升也有帮助。为了做到这一点，Vue 会尽可能地复用元素，并仅对 DOM 中需修改的地方进行最小范围的修改，以达到理想的结果。这意味着重复的元素会被打包到一起，不会在添加或移除列表中的项时移动它们。不过，这也意味着对其应用过渡不会有动画效果。 key 属性为元素指定唯一标识符。 使用插槽分发内容 12345&lt;div class=&quot;overlay&quot; @click=&quot;handleClick&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;slot /&gt; &lt;/dvi&gt;&lt;/div&gt; 123&lt;overlay&gt; Hello world!&lt;/overlay&gt; Vue 提供了一个特殊的组件可以把其转换为任意的组件：component 组件。只需要将它的 is prop 设置为一个组件名或组件定义对象，甚至是一个 HTML 标签，component 组件就会变为响应的内容： 动态修改组件 123&lt;overlay v-if=&quot;activeOverlay&quot;&gt; &lt;component :is=&quot;'overlay-content-'+activeOverlay&quot; :player=&quot;currentPlayer&quot; &gt;&lt;/overlay&gt; 当 targetHeight 属性发生改变时，就开始播放动画 123456789101112watch:{ targetHeight(newValue,oldValue){ const vm = this; new TWEEN.Tween({value:oldValue}) .easing(TWEEN.Easing.Cubi.InOut) .to({value: newValue},500) .onUpdata(function(){ vm.height = this.value.toFixed(0) }) .start() }} 高级项目设置4.1 设置开发环境安装 Node.js 和 npm 4.1.1 安装官方命令行工具 vue-cli安装 vue-cli 并将其作为一个全局的包： 12345npm install -g vue-cli// 打印 vue-cli 打印版本vue -Vvue --version 项目脚手架推荐的官方模板是 webpack 模板，具有使用 Vue 创建整个 SPA（单页面应用）所需的全部功能。使用 webpack-simple 并逐步引入功能。 渲染函数 Vue 使用一个虚拟 DOM 的实现，用树状结构的 JavaScript 对象来构建虚拟 DOM。然后 Vue 将虚拟 DOM 应用到真实浏览器的 DOM 上，所用方法是计算两者之间的差距。这尽可能地避免了 DOM 操作，因为 DOM 操作通常是主要的性能瓶颈。 按照惯例，h 是 createElement 的别名，这是编写 JSX 时非常常见和必须的。它得名于使用 JavaScript 描述 HTML 的技术 - Hyperscript。 createElement（或称 h）方法最多需要 3 个参数，（1）第一个参数是元素类型。它可以是一个 HTML 标签名称（比如 div），在应用中注册过得组件名称，或者直接就是一个组件定义对象。（2）第二个参数是可选的。它是一个定义了属性、prop、事件监听器等的数据对象。（3）第三个参数也是可选的。它可以是简单的纯文本，也可以是一个用 h 创建的其他元素的数据。 示例： 1234567891011render(h){ return h('ul',{'class':'movies'},[ h('li',{'class': 'movie'},'Start Wars'), h('li',{'class':'movie'},'Blade Runner'), ])}&lt;ul class='movies'&gt; &lt;li class='movie'&gt;Star Wars&lt;/li&gt; &lt;li class='movie'&gt;Blade Runner&lt;/li&gt;&lt;/ul&gt; 4.2.4 配置 BabelBabel 是一个 JavaScript 代码编辑工具，以便我们在旧版和最新版的浏览器中使用新特性（如 JSX 或箭头函数）。建议在所有正式的 JavaScript 项目中使用 Babel。 polyfill 是用于检查特性在浏览器中是否可用的代码；如果不可用，它将实现这个特性，使其可以像原生的一样工作。 1.Babel Vue 预览 安装并使用 babel-preset-vue 1npm i -D babel-preset-vue 主要的 Babel 配置是在项目根目录下已存在的 .babelrc JSON 文件中完成的。 打开这个 .babelrc 文件并将 vue 预览添加到相应的列表中： 1234567{ &quot;presets&quot;: { [&quot;env&quot;,{&quot;modules&quot;: false}], &quot;stage-3&quot;, &quot;vue&quot; }} polyfill 添加 Babel polyfill，以便在旧浏览器中使用新的 JavaScript 特性。 在开发依赖中安装 babel-polyfill 包。 1npm i -D babel-polyfill 在 src/main.js 文件的开头将其导入 import ‘babel-polyfill’ 这将为浏览器启用所有必要的 polyfill。 4.2.5 更新依赖1、手动更新 1234// 要检查项目中使用的包是否有新的版本，可以在根文件夹中运行以下命令:npm outdatednpm install 不要忘记阅读你所更新包的更改日志！可能会有你希望了解的破坏性改变或改善。 2.自动更新 1npm update 该命令只会更新与 package.json 文件中所指定版本兼容的版本。如果你想将包更新为其他版本，则需要手动执行。 3.更新 Vue 更新包含核心库的 Vue 包时，你也应该更新 vue-template-compiler 包。它是使用 webpack （或其他构件工具）时编译所有组件模板的包。 这两个包必须始终处于相同的版本。例如，如果你使用 vue 2.5.3 ，那么 vue-template-complier 也应该是版本 2.5.3. 4.2.6 为生产而构建1npm run build 默认情况下，使用 webpack-simple 模板时，它会将 JavaScript 文件输出到项目的 /dist 文件夹中。 4.3 单文件组件Vue 具有自己的格式，名为单文件组件（SFC）。该格式由 Vue 团队创建，文件扩展名为 .vue。允许每个文件编写一个组件，将模板以及该组件的逻辑和样式集中在一个位置，这里的主要优势在于，每个组件都明显独立，更易于维护，易于共享。 单文件组件使用类似 HTML 的语法描述 Vue 组件。它可以包含 3 种类型的根块 123&lt;template&gt;，使用我们已经用过的模板语法描述组件的模板；&lt;script&gt;，其中包含组件的 JavaScript 代码；&lt;style&gt;， 其中包含组件使用的样式。 示例： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;p&gt;{{ message }}&lt;/p&gt; &lt;input v-model=&quot;message&quot; /&gt;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { message: &quot;Hello world&quot; }; }};&lt;/script&gt;&lt;style&gt;p { color: grey;}&lt;/style&gt; 编辑 main.js 文件，并使用 import 关键字导入单文件组件; 1import Test from './Test.vue' 移除 render 选项，使用对象展开运算符复制 Test 组件的定义： 1234new Vue({ el: '#app', ...Test}) 组件添加到应用程序的方法：使用 JavaScript 展开运算符，因此 ...App表达式将属性复制到应用定义对象。它的主要优点是，在开发工具中不再用无用的顶层组件；它会成为我们的根组件。 4.3.1 模板 标签包含组件的模板。带有 Vue 特殊语法的 HTML。 如果没有在单文件组件中放置一个 标签，则要编写一个渲染函数，否则你的组件将无效。 使用 Pug Pug 是一种编译到 HTML 的语言。可以在 lang 属性设置为 ‘pug’ 的 标签内使用它： 12345&lt;tempate lang=&quot;pug&quot;&gt;ul.movies li.movie Star Wars li.movie Blade Runner&lt;/tempate&gt; 为了能够编译单文件组件中的 Pug 代码，需要安装这些包： 1npm install --save-dev pug pug-loader 开发所需的包称为开发依赖，应该使用 --save-dev 标志进行安装。应用运行需要的直接依赖应该使用 --save 标签进行安装。 JSX JSX 是在 JavaScript 代码中用来表示 HTML 标记的特殊符号。它使负责描述视图的代码在更接近纯 HTML 语法的同时，仍具有 JavaScript 的全部功能。 示例： 123456789101112131415161718&lt;script&gt;export default{ data(){ return{ movies: [ {title: 'Star Wars'}, {title: 'Blade Runner'}, ], } } render (h){ const itemClass = 'movie' return &lt;ul class='movies'&gt; {this.movies.map(movie =&gt; &lt;li class={itemClass}&gt;{movie.title}&lt;/li&gt;)} &lt;/ul&gt; },}&lt;/script&gt; 4.3.3 样式有作用域的样式 可以使用 style 标签的 scoped 属性将标签内的 CSS 作用域限定在当前组件中。这个 CSS 只会应用于这个组件模板里的元素。 示例： 1234567&lt;style scoped&gt;.movie:not(:last-child){ padding-bottom: 6px; margin-bottom: 6px; border-bottom: 1px solid rgba(0,0,0,0.1);}&lt;/style&gt; 这要归功于 PostCSS 应用到模板和 CSS 的一个特殊属性。 示例： 12345678&lt;template&gt; &lt;h1 class=&quot;title&quot;&gt; Hello &lt;/h1&gt;&lt;/template&gt;&lt;style scoped&gt;.title{ color: blue;}&lt;/style&gt; 等价 12345678&lt;template&gt; &lt;h1 class=&quot;title&quot; data-v-02ad4e58&gt; Hello &lt;/h1&gt;&lt;/template&gt;&lt;style&gt;.title[data-v-02ad4e58]{ color: blue;}&lt;/style&gt; 有了有作用域的样式并不意味不再需要类。由于浏览器渲染 CSS 的方式，选择带有属性的元素时可能会出现性能损失。例如，当样式作用域限定到组件时， li { color: blue; } 会比 .movie { color: blue; } 慢许多倍。 添加预处理器 Sass要在组件中启用 Sass，请安装以下包： 1npm install --save-dev node-sass sass-loader 示例： 12345&lt;style lang=&quot;sass&quot; scoped&gt;.article .title border-bottom: 3px solid rgba(red,.2)&lt;/style&gt; 如果你想使用 Sass 的 SCSS 语法变体，需要使用 lang = 'scss'。 Less 使用 Less，需要安装以下包： 1npm install --save-dev less less-loader 示例： 12345&lt;style lang=&quot;less&quot; scoped&gt;.article .title border-bottom: 3px solid rgba(red,20%)&lt;/style&gt; Stylus 使用 Stylus ，需要安装这些包： 1npm install --save-dev stylus stylus-loader 示例： 12345&lt;style lang=&quot;stylus&quot; scoped&gt;.article .title border-bottom: 3px solid rgba(red,0.2)&lt;/style&gt; 4.3.4 组件内的组件要在另一个组件中使用组件，我们需要导入它并将它暴露在模板中。 示例：Movie.vue 组件 12345678910111213141516171819&lt;template&gt; &lt;li class='movie'&gt; {{movie.title}} &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default{ props:['movie'],}&lt;/script&gt;&lt;style scoped&gt;.movie:not(:last-child){ padding-bottom: 6px; margin-bottm: 6px; border-bottom: 1px solid rgba(0,0,0,.1);}&lt;/style&gt; Movies.vue 组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;ul&gt; &lt;Movie v-for=&quot;movie of movies&quot; :key=&quot;movie.id&quot; :movie= 'movie' &gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;import Movie from './Movie.vue';export default{ components:{ // 相当于 &quot;Movie: Movie,&quot; Movie, } data(){ return{ movies:[ {id: 0, title: 'Star Wars'}, {id: 1, title: 'Blade Runner'}, ] } }}&lt;/script&gt; 如果使用 JSX，则不需要 components 选项。这是因为如果以大写字母开头，则可以直接使用组件定义： 12345678import Movies from './Movies.vue'export default{ render (h){ return &lt;Movies/&gt; // 无须通过 components 选项注册 Movies }} 项目 3： 支持中心5.1 通用应用结构5.1.1 项目设置（1）用命令生成一个 Vue 项目。 1234vue init webpack-simple support-centercd support-centernpm installnpm install --save babel-polyfill （2）安装编译 stylus 代码所需的包 1npm install --save-dev stylus stylus-loader 使用 --save-dev 标志将开发工具保存在 package.json 文件的开发依赖中。 （3）移除 src 文件夹中的内容，将在其中放置应用的所有源代码。（4）然后创建一个 main.js 文件，包含创建 Vue 应用所需的代码： 1234567import 'babel-polyfill';import Vue from 'vue'new Vue({ el: '#app', render: h =&gt; h('div', 'Support center'),}) 可以尝试使用 npm run dev 命令运行应用了。 5.1.2 路由和页面主要页面： 主页公共 FAQ 页面登陆页面工单页面发送新工单的页面显示工单详情和对话的页面 路由是表示应用 state 的路径，通常以页面的形式显示。每个路由都与一个 URL 模式相关联，后者在地址匹配时触发路由。然后，相应的页面将呈现给用户。 Vue 插件 （1）下载 vue-router 包： 1npm install --save vue-router （2）创建 router.js 文件，并从相应的包中导入 Vue 库 和 VueRouter 插件： 12import Vue from 'vue';import VueRouter from 'vue-router' （3）将该插件安装到 Vue 中： 1Vue.use(VueRouter); 使用 vue-router 创建第一个路由 使用 router-view 进行布局在添加路由之前，我们需要为应用设置一个布局。这是将要渲染路由组件的地方。 （1）在 src 目录中新建一个 components 文件夹，并在文件夹中创建一个名为 AppLayout.vue 的组件。 （2）编写组件的模板（3）添加 stylus 文件 12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;app-layout&quot;&gt; &lt;header class=&quot;header&quot;&gt; &lt;div&gt; &lt;img class=&quot;img&quot; src=&quot;../assets/logo.png&quot; alt=&quot;&quot; /&gt; &lt;/div&gt; &lt;/header&gt; &lt;router-view /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;stylus&quot;&gt;@import '../style/main';&lt;/style&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;.header{ .img{ width: 64px; height: 64px; }}&lt;/style&gt; 为了提高性能，建议在范围样式中使用 class。 导入并渲染在 Vue 根实例上： 12345678import router from './router'import AppLayout from './components/AppLayout.vue'new Vue({ el: '#app' render: h =&gt; h(AppLayout), router,}) 创建路由创建一个 Home.vue 组件 123456789&lt;template&gt; &lt;main class=&quot;home&quot;&gt; &lt;h1&gt;Welcome to our support center&lt;/h1&gt; &lt;p&gt; We are here to help! Please read the &lt;a&gt;F.A.Q&lt;/a&gt; first, and if you don't find the answer to your question, &lt;a&gt;send us a ticket!&lt;/a&gt; &lt;/p&gt; &lt;/main&gt;&lt;/template&gt; 创建一个 FAQ.vue 组件 12345&lt;template&gt; &lt;main class=&quot;faq&quot;&gt; &lt;h1&gt;Frenquently Asked Questions&lt;/h1&gt; &lt;/main&gt;&lt;/template&gt; 在 router.js 文件中，导入两个组件 1234567891011121314151617181920212223import Home from '../components/Home.vue'import FAQ from &quot;../components/FAQ.vue&quot;const routes = [ { path: '/', name: 'home', component: Home }, { path: '/faq', name: 'faq', component: FAQ }]const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes})export default router 路由名称是可选的，但我强烈建议使用它。它允许你指定路由的名称而不是路径，以便在移动和更换路由时不会导致链接失效。 安装的这个插件也是路由器的构造函数，所以我们使用相同的 VueRouter 变量。 不要忘记 URL 中的 # 字符。在不改变真实网页的情况下伪造路由更改时，它是必须的。这是默认的路由器模式，称为 hash。该模式可以与任何浏览器和服务器一起使用。 路由模式 可以在构造器选项中使用 mode 参数更改路由器模式，可以是 hash（默认）、history 或 abstract。 hash 模式是默认模式。这是“最安全”的选择，因为它与任何浏览器和服务器都兼容。它使用 URL 的 hash 部分（指 # 符号后面的 部分），并对其进行更改或响应其变化。最大的好处是，改变 hash 部分不会改变应用运行的真实网页（改变真实网页是非常不好的）。显而易见的缺点则是，它迫使我们不那么优雅的 # 符号将 URL 分成两部分。 感谢 HTML5 的 history.pushState API，我们可以摆脱这个 # 符号，并为应用获得一个真实的 URL!我们需要在构造函数中将模式更改为history： 1234const router = new VueRouter({ mode: 'history', routes}) 两个问题：浏览器需要支持这个 HTML5 API，这意味着它不能在 Internet Explorer 9 或更低版本上工作（所有其他主流浏览器都已经支持它一段时间了）。服务器必须配置为当访问诸如 /faq 之类的路由时发送主页而不是抛出 404 错误，因为它并不真实存在（没有名为 faq.html 文件）。这意味着我们不得不自己实现 404 页面。 abstract,可以在任何 JavaScript 环境中使用（包括 Node.js）。如果没有可用的浏览器 API，路由器将被迫使用此模式。 3.创建导航菜单 新建 NavMenu.vue 文件： 12345678910111213141516&lt;template&gt; &lt;nav class=&quot;menu&quot;&gt; &lt;router-link :to=&quot;{ name: 'home' }&quot;&gt;Home&lt;/router-link&gt; &lt;router-link :to=&quot;{ name: 'faq' }&quot;&gt;FAQ&lt;/router-link&gt; &lt;/nav&gt;&lt;/template&gt;&lt;script&gt;export default {};&lt;/script&gt;&lt;style lang=&quot;stylus&quot; scoped&gt;@import '../style/imports';.router-link-active { border-bottom-color : $primary-color;}&lt;/style&gt; 添加到布局中。在 AppLayout 中导入新组建： 12345678910111213141516171819&lt;template&gt;&lt;header class=&quot;header&quot;&gt; &lt;div&gt; &lt;img class=&quot;img&quot; src=&quot;../assets/logo.png&quot; alt=&quot;&quot; /&gt; &lt;div&gt;My shirt shop&lt;/div&gt; &lt;/div&gt; &lt;/header&gt; &lt;NavMenu /&gt; &lt;/header&gt;&lt;/tempate&gt;&lt;script&gt;import NavMenu from &quot;./NavMenu&quot;;export default { components: { NavMenu }};&lt;/script&gt; 路由器链接 vue-router 插件为我们提供了特殊组件 router-link。当这个组件被点击时，就会变为指定路由，这要归功于它的 to prop。默认情况下，它将是一个 HTML a 元素， 但可以使用 tag prop 来自定义。 示例： 1234&lt;router-link to=&quot;/faq&quot;&gt;FAQ&lt;/router-link&gt;to prop 也可以使用包含 name 属性的对象而不是路径：&lt;router-link :to=&quot;{ name: 'faq' }&quot;&gt;FAQ&lt;/router-link&gt; 这将动态地为路由生成正确的路径。我建议使用第二种方法，而不是只指定路径 —— 这样，这样，如果更改路由的路径，导航链接仍然可以工作。 当使用对象记法时，不要忘记用 v-bind 或者 : 简写来绑定 to prop，否则 router-link 组件会得到一个字符串，并不会理解它是一个对象。 active class路由器链接在与其关联的路由当前处于激活状态时获取 active class。默认情况下，组件使用 router-link-active CSS 类。 默认情况下，active class 匹配行为是包容的！这意味着如果路径为 /fag 或以 /fag/开头，router-link to = ‘/faq’ 都将获得 active class 。为了防止发生这种情况，有一个 exact prop，它是布尔值。如果设置其为 true，则仅在当前路径完全匹配时，链接才能获得 active class。 示例： 1&lt;router-link :to=&quot;{ name: 'home' }&quot; exact&gt;Home&lt;/router-link&gt; 5.2.2 使用 fetchfetch API 是基于 Promise 的，使用起来非常简单。以下是 fetch 用法的示例： 1234567891011121314fetch(url).then(response =&gt; { if(response.ok){ // 返回一个新的 Promise return response.json() }else{ return Promise.reject('error');}).then(result =&gt;{ // 成功 console.log('JSON',result);}).catch(e =&gt;{ // 失败 console.error(e);}) 加载动画 创建全局组件新建 Loading.vue 文件： 12345&lt;template&gt; &lt;div class=&quot;loading&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 新建 global-components.js。使用 Vue.component() 方法全局地注册 Loading 组件； 1234import Vue from 'vue'import Loading from './components/Loading.vue'Vue.component('Loading', Loading); 在 main.js 文件中导入 global-components.js 模块： 1import './global-components' 回到 FAQ.vue 组件，使用动画 123&lt;template&gt; &lt;Loading v-if='loading' /&gt;&lt;/tempalte&gt; 5.2.3 用自己的插件扩展 Vue1.创建一个插件 要创建插件，只有一个规则 —— 插件应该是一个带有 install 方法的对象，该方法接收 Vue 构造函数作为第一个参数以及一个可选的 options 参数。该方法将通过修改构造函数为框架添加新特性。 （1）在 src 文件夹中新建 plugins 文件夹。（2）在 plugins 文件夹中新建 fetch.js 文件。（3）导入一个带 install 对象的方法，尝试创建插件： 12345export default { install (Vue) { console.log('Installed!') }} （4） 导入插件 12import VueFetch from './plugins/fetch'Vue.use(VueFetch) 2.插件选项 （1）编辑 install 方法 12345export default { install (Vue,options) { console.log('Installed!',options) }} （2）添加 baseUrl 属性到配置中： 123Vue.use(VueFetch,{ baseUrl: 'http://localhost:3000/'}) （3）将 baseUrl 存储到一个变量中 123456789let baseUrl;export default{ install (Vue,options){ console.log('Installed',options) baseUrl = options.baseUrl }} 3.$fetch 方法（1）使用 fetch 实现 $fetch 方法： 1234567891011export async function $fetch(url){ const response = await fetch(`${baseUrl}${url}`) if(response.ok){ const data = await response.json() return data }else{ const error = new Error('error') throw error; }} (2) 为了所有组件中可用，只需要将其添加到 Vue 的原型（这是用于创建组件的构造函数）中即可： 123456export default{ install (Vue, options){ baseUrl = options.baseUrl Vue.prototype.$fetch = $fetch }} （3）重构 FAQ 组件 12this.loading = true; try{ this.questions = await this.$fetch('questions'); }catch(e){ this.error = e } this.loading = false 使用 mixin 复用代码mixin 是可应用于其他定义对象（包括其他 mixin）的组件定义对象。 （1）导出一个具有数据属性的定义 1234567export default{ data (){ return { remoteDataLoading: 0, } }} remoteDataLoading 属性将用于计算当前正在加载请求的数量，以帮助我们显示加载动画。 （2）使用 mixin 1234567import RemoteData from '../mixins/RemoteData'export default{ mixins: [ RemoteData, ]} mixin 被应用合并到了 FAQ.vue 组件定义中。意味着 data 钩子被调用两次：首先在 mixin 中调用，然后在 FAQ 定义中添加了一个新属性！ Vue 会自动合并标准选项，如钩子、数据、计算属性、方法和侦听器，如果有一个方法的属性具有相同名称，最后应用的那个将覆盖之前的那些。 data、created、mounted 等钩子都按它们应用于最终定义的顺序逐一调用。 这意味着最后的组件定义钩子将被最后调用。 1.获取远程数据 （1）使用一个带有 resources 参数的函数封装的对象： 123456789export default function (resources){ return { data (){ return { remoteDataLoading: 0, } } }} （2）改变在 FAQ.vue 组件中使用 mixin 的方式 1mixins:[ RemoteData({ questionList: 'questions' }) ] （3）数据属性初始化，以便 Vue 设置响应式属性： 12345678910data(){ let initData = { remoteDataLoading:0 } // 初始化数据属性 for (const key in resources){ initData[key] = null } return initData} （4）创建新的 fetchResource 方法获取资源并更新数据 12methods: { async fetchResource (key,url){ try{ this.$data[key] = awaitthis.$fetch(url) }catch(e){ console.error(e); } } } （5）在 created 钩子中自动调用它 12created(){ for(const key in resources){ let url = resources[key]this.fetchResource(key,url) } } （6）更改模板 1&lt;article v-for=&quot;question of questionList&quot;&gt; 2.加载管理 （1）增加两个语句，分别递增和递减计数器： 1234567891011async fetchResource(key, url) { this.$data.remoteDataLoading++; this.$data.remoteErrors[key] = null; try { this.$data[key] = await this.$fetch(url); } catch (e) { console.error(e); this.$data.remoteErrors[key] = e; } this.$data.remoteDataLoading--; } （2）添加计算属性 1234567891011computed: { remoteDataBusy() { return this.$data.remoteDataLoading !== 0; }, hasRemoteErrors() { return Object.keys(this.$data.remoteErrors).some( key =&gt; this.$data.remoteErrors[key] ); }} （3）改变 Loading 组件 1&lt;Loading v-if=&quot;remoteDataBusy&quot; /&gt;&gt; 3.错误管理（1）错误存储 123456// 初始化数据属性initData.remoteErrors = {}for (const key in resources){ initData[key] = null initData.remoteErrors[key] = null} （2）fetchResource 方法 12345678910111213async fetchResource(key, url) { this.$data.remoteDataLoading++; // 重置错误 this.$data.remoteErrors[key] = null; try { this.$data[key] = await this.$fetch(url); } catch (e) { console.error(e); // 放置错误 this.$data.remoteErrors[key] = e; } this.$data.remoteDataLoading--;} （3）检查 1234567computed: { hasRemoteErrors() { return Object.keys(this.$data.remoteErrors).some( key =&gt; this.$data.remoteErrors[key] ); }} （4）替换 error 属性 1&lt;div class=&quot;error&quot; v-if=&quot;hasRemoteErrors&quot;&gt; 5.3 支持工单5.3.1 用户认证1.将用户存储在一个集中式 state 里 （1）新建 state.js 文件，用于导出 state 对象 123export default { user: null} （2）导入 state：（3）根实例的数据，以便 Vue 使其成为响应式的： 12345678import state from './state'new Vue({ el: &quot;#app&quot;, data: state, router, render: h =&gt; h(AppLayout),}) 另一个插件 （1）在 plugins 文件夹中，创建新插件 state.js 文件： 1234567export default { isntall(Vue, state) { Object.defineProperty(Vue.prototype, &quot;$state&quot;, { get: () =&gt; state }); }}; 使用 JavaScript Object.defineProperty（）方法在 Vue 原型上设置一个 getter，每个组件都会继承它！ （2）在 main.js 文件中，导入新的插件：（3）使用 state 对象作为选项参数进行安装： 12import VueState from &quot;./plugins/state&quot;;Vue.use(VueState, state); 2.登录表单 （1）在 components 文件夹中创建一个新的 SmartForm.vue 组件： 1234567891011121314151617&lt;template&gt; &lt;form @submit.prevent=&quot;submit&quot;&gt; &lt;section class=&quot;content&quot;&gt; &lt;h2&gt;{{ title }}&lt;/h2&gt; &lt;slot /&gt; &lt;div class=&quot;actions&quot;&gt; &lt;slot name=&quot;actions&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;error&quot; v-if=&quot;error&quot;&gt; {{ error }} &lt;/div&gt; &lt;/section&gt; &lt;template name=&quot;fade&quot;&gt; &lt;Loading v-if=&quot;busy&quot; class=&quot;overlay&quot; /&gt; &lt;/template&gt; &lt;/form&gt;&lt;/template&gt; 在 form 元素上，submit 事件上设置了一个事件监听器。它使用 prevent 修饰符阻止浏览器的默认行为（重新加载页面）。 SmartForm 组件有 3 个属性 title：显示在 h2 元素中。operation：提交表单时调用的异步函数，它应该返回一个 Promise。valid：布尔值，以防止表单在无效时调用操作。 123456789101112131415161718&lt;script&gt;export default { props: { title: { type: String, required: true }, operation: { type: Function, required: true }, valid: { type: Boolean, required: true } }};&lt;/script&gt; 声明 prop —— 通过使用对象，可以指定 prop 的更多细节。Vue 检查的类型。 busy：布尔值，用于切换加载动画的显示。error：错误消息，没有则为 null。 （3）添加到 data 钩子里： 1data() { return { error: null, busy: false }; } （4）编写提交表单 123methods: { async submit() { if (this.valid &amp;&amp; !this.busy) { this.error = null;this.busy = true; try { await this.operation(); } catch (e) { this.error =e.message; } this.busy = false; } } } （5）注册 12import SmartForm from './components/SmartForm.vue'Vue.component('SmartForm',SmartForm) 不要忘记 name 属性 ，它将允许浏览器自动补全字段。 1234567&lt;style lang='stylus' scoped&gt;.formm{ &gt;&gt;&gt; .content{ max-width: 400px; }}&lt;/style&gt; 连结符允许将模板中使用的组件内的元素作为目标，同时限定 CSS 选择器其余部分的作用域。 生成的示例： 123.form[data-v-0e596401] .content{ max-width: 400px;} 不使用连结符，则会 123.form .content[data-v-0e596401] { max-width: 400px;} 如果使用 SASS , 则需要使用 /deep/ 选择器。 带导航守卫的私有路由路由元属性 1{path: '/tickets' , /* ... */ , meta: { private: true }} 路由器导航守卫 beforeEachto 是当前的目标路由；from 是以前的路由；next 是为了完成解析不得不在某个时刻调用的函数。 （1）在导出路由器实例之前，添加 beforeEach 导航守卫 12345router.beforeEach((to,from,next)=&gt;{ //TODO console.log('to',to.name); next()}) （2）现在需要确定目标路由是否为私有路由：导航到期望的路由 12345678910if(to.meta.private &amp;&amp; !state.user){ // TODO 重定向到登录 next({ name : 'login', params: { wantedRoute: to.fullPath, } }) return} router.replace() 方法与 router.push()方法相似，区别在于前者浏览器历史记录中的当前条目替换为新路由，而不是添加新条目。 项目 5：在线商店以及扩展高级开发流程 123456vue init webpack-simple e-shopcd e-shopnpm installnpm install -S babel-polyfillnpm i -D stylus stylus-loadernpm i -S axios vue-router vuex vuex-router-sync 本地 API 1npm i -D json-server 添加脚本启动 JSON 服务器 1&quot;db&quot;: &quot;json-server --watch db.json&quot; 使用 PostCSS 自动添加前缀vue-loader 已经包含了 PostCSS 1npm i D autoprefixer 在项目根目录添加 postcss.config.js 配置文件。 12345module.exports = { plugins: [ require('autoprefixer'), ],} 通过 browserslist 指定浏览器 123&gt; 1%last 2 versionsFirefox ESR 通过 ESLint 提升代码质量和风格使用 StandardJS 预设规则以及 eslint-plugin-vue 12345npm i -D eslint eslint-config-standara eslint-plugin-vue@beta// 安装 eslint-config-standard 的平级依赖npm i -D eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-standard// 为了使 ESLint 解析文件时支持使用 Babel 的 JavaScript 代码npm i -D babel-eslint 配置 ESLint 12345678910111213141516171819202122232425262728293031// .eslintrc.js module.exports = {// Use only this configuration root: true, // File parser parser: 'vue-eslint-parser', parserOptions: { // Use babel-eslint for JavaScript 'parser': 'babel-eslint', 'ecmaVersion': 2017, // With import/export syntax 'sourceType': 'module' }, // Environment global objects env: { browser: true, es6: true, jest: true, }, extends: [ // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style 'standard', // https://github.com/vuejs/eslint-plugin-vue#bulb-rules 'plugin:vue/recommended', ], rules: { // https://github.com/babel/babel-eslint/issues/517 'no-use-before-define': 'off', 'comma-dangle': ['error', 'always-multiline'], },} Webpack 中使用 ESLint 1npm i -D eslint-loader friendly-errors-webpack-plugin 123456789module: { rules: [ { test: /\\.(jsx?|vue)$/, loader: 'eslint-loader', enforce: 'pre', }, ]} Jest 单元测试1npm i -D jest vue-test-utils vue-jest jest-serializer-vue vue-server-renderer babel-jest babel-plugin-dynamic-import-node 配置 Jest在项目根目录中创建 jest.config.js 配置 Jest; 12345678910module.exports = { transform: { '.+\\\\.jsx?$': '&lt;rootDir&gt;/node_modules/babel-jest', '.+\\\\.vue$': '&lt;rootDir&gt;/node_modules/vue-jest', }, snapshotSerializers: [ '&lt;rootDir&gt;/node_modules/jest-serializer-vue', ], mapCoverage: true,} 12345678910111213141516171819202122232425262728293031323334353637383940414243// BaseButton.spec.jsimport BaseButton from './BaseButton.vue'import { shallow } from 'vue-test-utils'import { createRenderer } from 'vue-server-renderer'describe('BaseButton', () =&gt; { test('click event', () =&gt; { const wrapper = shallow(BaseButton) wrapper.trigger('click') expect(wrapper.emitted().click).toBeTruthy() }) test('icon prop', () =&gt; { const wrapper = shallow(BaseButton, { propsData: { icon: 'add', }, }) expect(wrapper.contains('.icon')).toBe(true) const icon = wrapper.find('.icon') expect(icon.text()).toBe('add') }) test('snapshot', () =&gt; { const renderer = createRenderer() const wrapper = shallow(BaseButton, { // Props values propsData: { icon: 'add', disabled: true, badge: '3', }, // Slots content slots: { default: '&lt;span&gt;Add Item&lt;/span&gt;', }, }) renderer.renderToString(wrapper.vm, (err, str) =&gt; { if (err) throw new Error(err) expect(str).toMatchSnapshot() }) })}) 在 package.json 添加运行脚本 12&quot;jest&quot;: &quot;jest&quot;&quot;jest:update&quot;: &quot;jest --updateSnapshot&quot; vue-i18n国际化 1npm -i -S vue-i18n 1234567// src/plugins.jsimport Vue from 'vue'import Http from './utils/http'import VueI18n from 'vue-i18n'Vue.use(Http)Vue.use(VueI18n) 项目 6：使用 Meteor 开发实时仪表盘安装 Meteor 并设置项目MeteorMeteor 是一个用于构建 Web 应用的全栈 JavaScript 框架。 Meteor 栈主要由以下元素构成： Web 客户端（可以使用任意前端库，如 React 或 Vue），包含一个名为 minimongo 的客户端数据库； 基于 Node.js 的服务器，支持现代的 ES2015+ 特性，包括 import / export 语法； 服务器使用 MongoDB 实时数据库； 客户端和服务器的通信是抽象的，客户端和服务端数据库能方便地实时同步； 可选的混合移动应用（Android 和 IOS），能用一条命令构建； 完整的开发者工具，如功能强大的命令行实用程序和易用的构建工具； Meteor 专用包（也可以实用 npm 包）。 Meteor 没有实用 Webpack。 安装 Meteor我有单独 Meteor 文章可以那里有安装详细 12// 查看当前 Meteor 版本meteor --version 创建项目12meteor create --bare &lt;folder&gt;cd &lt;folder&gt; –bare 参数告诉 Meteor 创建一个空的项目。 123456// 添加 编译 vue 组件，编译 stylus 专用包meteor add akryum:vue-component akryum:vue-stylus// 安装 vue 和 vue-router 包meteor npm i -S vue vue-router// 启动应用meteor meteor 会启动一个 HTTP 代理，一个 MonoDB 和 Node.js 服务器。 1234567891011// main.jsimport { Meteor } from 'meteor/meteor'import Vue from 'vue'import App from './components/App.vue'Meteor.startup(() =&gt; { new Vue({ el: '#app', router, ...App, })}) 在 Meteor 应用中，建议在 Meteor.startup 钩子内创建你的 Vue 应用，这样可以保证整个 Meteor 系统在启动前端之前准备完毕。 使用 Meteor 方法将数据保存到 Meteor 集合（collection） 中将 Meteor 集合集成到应用中，用于应用的自动更新。 1meteor npm i -S vue-meteor-tracker 12345678910111213141516171819202122// main.jsimport { Meteor } from 'meteor/meteor'import Vue from 'vue'import App from './components/App.vue'import VueMeteorTracker from 'vue-meteor-tracker'import router from './router'import 'vue-progress-path/dist/vue-progress-path.css'import VueProgress from 'vue-progress-path'Vue.use(VueMeteorTracker)Vue.use(VueProgress, { defaultShape: 'semicircle',})Meteor.startup(() =&gt; { new Vue({ el: '#app', router, ...App, })}) 设置 Meteor 集合，用于存储测量记录数据。 1234// collections.js// 声明 Meteor 集合import { Mongo } from 'meteor/mongo'export const Measures = new Mongo.Collection('measures') 12345678910111213141516// methods.js// 添加 Meteor 方法 客户端和服务端都会调用import { Meteor } from 'meteor/meteor'import { Measures } from './collections'Meteor.methods({ 'measure.add' (measure) { Measures.insert({ ...measure, date: new Date(), }) },})// 通过 Meteor.call 函数调用这个方法Meteor.call('measure.add', measure); Measures 集合发布 1234567// server/publications.jsimport { Meteor } from 'meteor/meteor'import { Measures } from '../lib/collections'Meteor.publish('measures', function () { return Measures.find({})}) 相关资料关于vuex-router-sync的作用，或者可以解决什么问题√browserslistjestVue 组件单元测试指南","link":"/2020/02/15/Book7/"},{"title":"30个哈佛学霸高效学习法，打造超强学习力！","text":"目标代办事项目标法目标具体化、可执行可衡量、可追踪、便于调整 X - Y 轴布阵法 目标激励法 专注力物理隔绝法潜意识整理发心里暗示书桌整齐 狡兔三窟法仪式感思维定势 固定休息法 记忆力强迫运用法英语造句英语编故事强迫交流法实际运用 情绪刺激法联想法 女团记忆法找到共同点，先组合，再分辨 蜘蛛织网法找关联、找线索、关联知识点 预习文科预习影响听课状态，学习深度。先通读课文，对学习内容有一个感性认识。做标记。不懂的地方、不认识的单词、有疑问的做记号。查阅作者生平，了解文章写作背景。找关联，自己做知识拓展。碎片化时间、短时间 理科做预习题看看自己的思路卡在哪一步，那一步通常就是本小节的知识点。培养对知识的敏锐，带做题思路去听课。 复习犹太式辅导法角色转换。成为老师，讲述知识点。化身出题者，提出考点。 自制力Small（小的） 把事情看成很小的事、平常心 Start （开始、启动） 三分钟启动法，完成感 SeIf -Section（自主时间段） 测试注意力时长 找到合适的时段长度 创作以任务为单位 Surrounding（环境，周围的人） 促使周围的人来督促、监督你 Sugar（糖、甜头） 适当给自己奖励 建立正向反馈 如何快速有效阅读一本书 求知、明理、审美 求知：倒叙，先读衍生品，找到线索和思路读书更容易理解。 明理：联想、结果导向 审美：不讲究方法 工具 保温杯（红枣、黄芪、枸杞） 开启新的一天 任务本 记录每天的工作进度以及日程 Macbook 便签 微信聊天记录 处理每天工作的任务 暗笔记 背书神器 打印器和活页本 打印器打印简易的知识表格 错题本 电脑、阅读支架 Sleep cycle 睡觉工具","link":"/2020/08/20/Journal-12/"},{"title":"一周健身计划","text":"前言我最早健身意识的建立是在初中，到初中之前我的运动和健身几乎为0，平时上下学都是坐公交和走路，关于运动和健身类的活动我很少参与，直到初中的一次因作业没写而收到惩罚，我开始意识到自己的身体不太…………。初中升高中会有体育测验，初中开始了关于运动和健身方面的种子。初中接触到的运动项目就那么几个，跳远、跳高、跑步、仰卧起坐、俯卧撑、广播体操、篮球……。而我各自不高，也缺乏运动所以我开始选择了跑步，跑步最简单。这一跑，跑步几乎成为了我这么多年，关于运动的唯一坚持的运动，原因大概也是因为他简单易行。看我的博客就会发现我很混乱，是的，我做很多事情都是想起来就要去做，要不然过一会真的会忘，做事情几乎没有计划，想到就去做。但是这样很难成功。所以我打算指定我的健身计划，其次我还是个收藏家，很多东西收藏了不用就很…………爽，越攒越多就很焦虑……。 预备目前我有的健身器材：哑铃、拉力器、沙袋、腹肌轮、俯卧撑架子（找不到了）。目前我摄取健身食材：鸡蛋、鸡胸肉。目前我的身体状况 ：5公里平均6分钟、一次15个俯卧撑、一次深蹲20个、一次倒立撑1分多……。目前我的体脂称数据：目标脂肪率维持在14%-16%、体重70公斤-75公斤 计划一周4天运动： 至少3公里，至少有1次5公里 俯卧撑至少20个/次 深蹲至少20个/次 仰卧起坐20个/次 倒立1分钟/次 腹肌轮20个/次 《囚徒健身》《肌肉完全训练计划》","link":"/2020/06/22/Journal-13/"},{"title":"100 本书计划","text":"读完的书 （30本）《小狗钱钱》、《半小时漫画经济学：金融危机合集》、《细节中的成败》、《卡耐基成功之道》《沟通礼仪全书》、《练习一个人当我开始爱自己》、《将来的你，一定会感谢现在拼命的自己》、《你的孤独虽败犹荣》、《静下来一切都会好》、《读心术》、《运气生猛》、《戒了吧！拖延症》、《对自己狠一点离成功近一点》、《狼图腾》、《青柠时代》、《哈佛凌晨四点半》、《假如给我三天光明》、《追风筝的人》、《莎士比亚悲剧集》、《我的大学》、《三体Ⅰ地球往事》、《三体Ⅱ黑暗森林》、《悲惨世界（上）》、《悲惨世界（下）》、《双城记》、《名人传》、《爱的教育》、《童年》、《钢铁是怎样炼成的》、《超有料漫画中国史3》、《半小时漫画科学史》 书架上未读完的书 （6本）《肌肉完全训练计划》、《囚徒健身》、《三体Ⅲ死神永生》、《红楼梦》、《人一生要读的经典》、《有些事现在不做，一辈子都不会做了》 读书工具十点读书（听书）《微信读书》《京东读书》","link":"/2020/04/05/Journal-2/"},{"title":"高效学习工作的环境","text":"大多数人学习工作中无法避免地受到环境的影响，在很难短期改变自己的情况下，选择好的环境是最快捷最有效的方式之一。 在家工作的好处及困扰 推荐高效的学习工作环境 在家工作的好处及困扰好处 成本低 自由的时间规划 环境舒适 困扰 精力和注意力很容易被分散 工作、学习、生活混杂 容易受到环境干扰 容易懈怠 长期在家学习不是一个很好的选择。 推荐高效的学习工作环境 咖啡店 图书馆 众创空间 父母家 永远自我感觉是个孩子 没有经济压力、工作学习动力小 容易受到环境干扰 精神压力大（像是在啃老） 工作、学习、生活混杂 出租屋 独立、建立责任感 缺乏社交 工作、学习、生活混杂 很容易陷入负面情绪 容易受到环境干扰 精力分散 图书馆 免费、好的学习工作氛围 工作设备多的职业不方便 咖啡店 适合短期调剂 不适合长期工作学习 众创空间（共享空间/联合办公）租工位、注册工作室、享受国家对中小企业的税收优惠政策 固定的工作点、可以放工作设备 配套的服务 孵化器、产业园共享空间 &gt; 图书馆 &gt; 咖啡店 &gt; 家 以上是我对下列视频及文章的归纳和总结。不要长期宅在家里学习！","link":"/2019/12/17/Journal-3/"},{"title":"创业公司组建团队","text":"后端 java 6 人前端 H5 2 人ios 1 人安卓 1 人产品 1 人运维 1 人leader 项目领导销售投资方UI 设计测试 以上是我对该视频的归纳和总结。","link":"/2020/01/15/Journal-4/"},{"title":"大学毕业做什么工作？ —— 职业生涯测评来帮忙","text":"职业生涯测评职业生涯测评会给一个比较详细的分析报告里面包含自己的性格特点自己的兴趣爱好自己的知识技能掌握情况 根据报告可以作为你选择专业或选择工作的参考 测评网站推荐才储网霍兰德职业兴趣测试新精英生涯测试一苇网 以上是我对下列视频及文章的归纳和总结。大学生选工作神器","link":"/2020/03/21/Journal-8/"},{"title":"程序员快速成长","text":"打字练习打字练习打字 工具熟悉工具，快捷键，减少鼠标操作，提升效率 基础篇如何快速学习一门语言或框架 看书、看视频、看技术博客、看文档 敲例子、示例 =&gt;最好是 todolist（练习：增删改查） 扩展 查看官网文档 写博客记录学习过程 工程实践（区别于实战项目：代码管理、版本持续集成、测试用例、代码审查）在工作中 进阶篇 阅读 github 上的优秀开源项目的代码（从最早的版本开始阅读，弄明白每次版本迭代的动机） 重构应用 写组件 写框架 推荐书籍《javaScript 框架设计》 设计模式 了解基本概念 识别设计模式 刻意练习使用设计模式 尝试在日常工作中使用设计模式 重构代码并使用设计模式 推荐书籍《设计模式》《重构与模式》 时间管理技术博客推荐： 阮一峰博客 廖雪峰博客 技术胖的博客和教学视频 以上是我对下列视频及文章的归纳和总结。大胖逼逼叨 11-程序员快速成神三部曲-基础篇大胖逼逼叨 12-程序员快速成神三部曲-进阶篇大胖逼逼叨 13-程序员成神三部曲时间管理","link":"/2020/01/26/Journal-5/"},{"title":"程序员跨过de坑","text":"软件工程代码管理 长时间不提交代码（至少每天提交一次） 单分支开发，代码发布之后生产环境不打 tag（多分支开发，正式上线打 tag） Git 权限分配 持续集成 本地构建没有集成环境 无法跟踪开发进度 服务器配置低，分批次构建 权限管理 文档管理 程序设计文档(程序员) 数据结构文档（后端程序员或 DBA） 使用说明文档（产品经理或客服） 文档和程序更新不同步 以上是我对下列视频及文章的归纳和总结。大胖逼逼叨 14-程序员跨过这些坑少走 3 年弯路","link":"/2020/01/26/Journal-6/"},{"title":"本土化清单","text":"OceanBase蚂蚁金服企业级分布式数据库 超越 Oracle 看后面的应用和普及吧 TPG腾讯自研图片格式 比 webp 更好，只是 webp 目前浏览器兼容，需要对特定的浏览器传输 webp 格式。tpg 格式普及兼容还尚早。","link":"/2020/10/11/Localization-List/"},{"title":"长投学堂——小白理财训练营","text":"课前读物-小狗钱钱写 3 个愿望 - 确立明确的目标准备梦想相册准备梦想储蓄罐 - 为目标长期投资 增加自信的方法：写成功日记赚钱的两个方法：别人需要什么，我能做什么。 遇到困难的时候，要坚持自己的想法。每天坚持做对未来有意义的事情。21 天理论72 小时 永远不要杀死你的鹅。负债的人应该扔掉所有信用卡。尽可能少的偿还贷款。对于消费贷款，应该把不用于生活的钱存起来一半,另一半用来还债。分清必要，需要，想要，控制消费。 穷人思维富人思维 投资、风险、收益、安全、简单 都说钱不值钱了，我该怎么办通货膨胀就是物价持续的上升，钱不值钱了，钱的购买力下降了。通货膨胀对三类人很不友好：把钱放家里的人把钱存银行的人靠固定收入过日子的人 投资可以帮助我们跑赢通货膨胀，而且可以增加我们的收入。 不懂的千万不要碰，先学习再投资。 最有价值的投资是投资自己，让自我增值。 钱难赚，保险别乱买五险一金中的“五险”就是我们常说的社保，其中包括：养老保险、医疗保险、工伤保险、生育保险和失业险。社保只是最基本的保障，除此之外，我们还需要给自己配置一部分商业保险。商业保险分两大险种：人身保险(意外险，重疾险，医疗险，寿险)和财产保险。保险不能降低风险，但可以转移风险，降低意外发生后带来的经济损失。保险配置应该优先考虑家庭经济支柱。买保险，要优先考虑需求，看自己需要哪些保障，再来挑选合适的产品。买保险，财务分析不能少，按实际说出自己的财务状况，专业人士才能给你精准的保险配置建议。 股票乱投资是找死，不投资是等死。在通货膨胀面前，不投资不仅不安全，而且是最大的不安全因素。股票的本质，公司拿出部分的所有权换取资金，用于后续的经营发展。股票赚钱有两种方式，一种是公司分红，另一种是低买高卖。 投资品中间商代表：银行、P2P、信托赚钱原理：汇集了很多人的钱，然后再把钱借给需要钱的人，以赚取中间差额。需要关注：中间人的信用。看他们把钱都借给了谁，那些借钱的人能不能还得了欠款和利息。 无中间商代表：债券；（国债、地方债、企业债）赚钱原理：把钱借给国家、地方政府或者企业，赚取利息。需要关注：借款人的信用资质，看他们还钱的几率有多大。 拥有部分资产代表：股票赚钱原理：人们用自己的钱买公司的部分资产，与公司共同承担风险，亏盈共享。你需要找到赚钱的公司，并出钱投资它。需要关注：你出钱投资的这家公司赚不赚钱。 成为资产所有人代表：黄金、期货、艺术品收藏、房地产赚钱原理：靠着外部信息，通过预测未来的涨跌赚钱，与自身的价值无关。需要关注：哪些因素会影响价格，然后综合判断。 混合型投资品代表：银行理财、基金赚钱原理：它投资的不是单一的东西，里面既有股票也有债券。需要关注：高低风险投资品的成分占比。 开源开源，就是先开源赚取主动收入，然后把这笔钱作为投资的本金，从而把这笔钱作为投资的本金，从而可以赚取被动输入。开源共分为三个等级，第一级，开源小白，一份时间售卖一次；第二级，开源达人，一份时间售卖多次；第三级，开源大神，购买他人的时间，低买高出。 如何将一份时间售卖多次？有个门槛低、效率高的方法，那就是将自己的知识、经验或者技能，以文字、音频、视频或者直播的形式放到网上，吸引流量。 买基金基金，就是基金公司收集投资者的钱，按照证监会规定的规则，进行各种各样的投资的一种投资品。根据投资理念的不同，基金可以分为主动型基金和被动型基金。主动型基金的两个缺点是，过于依赖基金经理，交易成本偏高。基金定投的好处是，投资门槛很低；操作非常简单；摊薄投资成本；强制储蓄资金。 资产和负债资产和负债的定义，资产，就是能把钱放进你口袋里的东西；负债，就是把钱从你的口袋里取走的东西。分清楚“必要”“需要”和“想要”“必要”是维持基本生活所需的东西，是你不花会死的。“需要”是可以在必要基础上进一步改善生活质量的。“想要”是我们欲望的写照。买东西之前扪心自问：这个不买会死吗？以后买会死吗？买个便宜的会死吗？ 国债国债逆回购：就是金融机构把国债抵押给你，找你借钱。企业以及机构在经营过程中，有时会缺少流动资金，就会把国债抵押用来周转资金。企业以国债为抵押物借钱，我们借钱给他们，就算到期还不上钱，手里也有国债，所以，把国债逆回购说成稳赚不赔，一点也不过分。一般星期四、月末、季度末、年末市场资金全面紧张时，利息通常会变得很高。国债逆回购操作：开通账户跨过门槛卖出份额 人生三大投资，你投对了几个每个人的一生都应该做到三大投资：投资金钱、投资时间、投资自己。 财务自由：通过被动收入判断，当一个人的被动收入可以满足他日常生活的所有支出，不用花费主动收入的时候，他就实现了财务自由。投资金钱：投资基金、投资股票。投资时间：提升时间的价值。投资自己：学习技能等。 方法比努力更重要,坚持。理财，长期坚持投入，增加持续收入的方式。 两种思维方式决定了你只能当穷人穷人思维陷阱：理财是一定要建立在有可观的存款基础之上的。因为工资低所以常年负债，因为时常负债所以无从理财。 合理的规划财务，看清负债和盈利，减少不必要的支出，开源增加收入。 关于行动力思想决定出路，选择重于等待。选择大于努力。理财越早越好。遇到机遇，应该采取行动，无论结果怎样，失败了总结教训，成功了分析原因。 关于 p2p,和小狗钱钱感悟点评所有的 P2P（除旁氏骗局类的）产品本质上都是债权，也就是一个人（或公司）问另一个人（或公司）借钱，只是债权也有优质债权和垃圾债权之分。P2P 的债权只是比垃圾债还要再垃圾 10000 点罢了。优质的债哪里买？债券市场上大把大把的都是，可以用证券账户购买上市公司的债权，有上市公司的业绩和抵押做保障，并且保证优先偿还债主而不是股东。投资第一条保证安全。投资：价值投资法，低估买入，高估卖出，长期持有。开源：特长、爱好、兴趣、工作。把目标放在显眼的地方时刻督促自己提醒自己。基本的原则：不要用借来的钱投资 什么是理财？什么是投资？投入产出比：投入资源，产出效果，效果除以资源。大部分情况下，投入产出比越高越好，也就意味着在产出固定的情况下，投入越小越好，在投入固定的情况下，产出越大越好。 资产就是能把钱放进你口袋里的东西，它能给你不断带来收入，而负债则是把钱从你口袋里取走的东西 富人的三个秘密成为富人的第一个秘密：在一生中不断地买入资产！资产品种丰富，给自己带来非常多的被动收入，不用单一依靠工资！富人乐意接受新鲜的事物，并在不断增长见识的过程中，提升自己辨别事物的能力，同时结交更多的朋友，拓展自己的圈子，遇到更多的贵人，进而良性循环！观念的转变，比收入的转变，要难很多，而你的思维，决定了你在什么阶级。第一要分清必要花费和不必要花费。第二就是要开源，好好提高主动收入。富人的收入一般是多样化的，而且有多种资产，进入一种良性循环。富人也有支出，但是一般光靠被动收入完全能够覆盖掉支出。财务自由度的概念：计算公式为：被动收入（投资性收入）/目前的年支出。一般公式结果等于 1 是最基本的自由度，数字越大，代表自由度越高。因为支出是弹性比较大的，所以说财务自由其实并不算大忽悠哈。你可以通过投资自己，提升自己的技能，把自己的单位时间卖得更贵。你可以将你的一份时间卖出很多份，比如公号文啊，出书啊，都是这种模式。让你的资产增值，资产增值是不依赖于你的工作时间的。生意要满足需求，有需求的地方就有生意。 1.增加工作收入，升职加薪，培养工作技能。 2.发展副业，爱好也可以为你带来收入的 3.增加被动收入，缓解生活压力。 4.现在就开始培养与锻炼自己的赚钱能力。1、先储蓄，再消费，先从储蓄 10%的月收入开始，生活质量不会下降很明显，同时比较容易坚持；2、投资自己，提升个人技能，自我增值才是最好的投资；3、对于零基础同学来说，可以先培养投资和理财的理念，再了解各种投资品，然后再进一步学习，之后再去完善好家庭的资产配置。4、在后面的课程中，有一课专门讲基金，买基金，首先得挑个好的，再配合一点小策略，就可以达到理想的收益。5、还有一课专门讲股票，股票没有大家想的那么可怕，在你的认知不足之前，你所有的判断可能都只是凭感觉，世间万事皆有可循之处，了解过后，我们才不至于妄下定论。外汇、期货都是专业性特别强的投资品，风险也特别高。外汇里面有一部分是诈骗平台(不合法不合规)，通常会让你放到一个海外账户里头，最后血本无归。期货也是很多私盘。","link":"/2020/02/08/Journal-9/"},{"title":"影视集","text":"《狗十三》《天注定》《楚门的世界》《流浪猫鲍勃》 《亲爱的》《推拿》《被嫌弃的松子的一生》《剩者为王》 《人民的名义》《当幸福来敲门》《切尔诺贝利》《何以为家》 《驴得水》《摔跤吧！爸爸》《天才摔跤手》《艺伎回忆录》 《男人四十》《千与千寻》《搜索》《蜜桃成熟时》《阳光灿烂的日子》 《黑处有什么》《心迷宫》《叫我第一名》《狩猎》《沉默的真相》 《霸王别姬》《变脸》《寄生虫》《大象席地而坐》 《西游记》《武状元苏乞儿》《神话》《超兽武装之勇者无惧》 《超兽武装之仁者无敌》《康熙王朝》《百变机兽之洛洛历险记》《海绵宝宝》 《铁齿铜牙纪晓岚》《仙剑奇侠传三》 《大话西游之大圣娶亲》 《这个杀手不太冷》《美国队长 2》《火影忍者》 《大内密探零零发》《喜剧之王》《果宝特攻》《天下无贼》《让子弹飞》《成为简·奥斯汀》 《一步之遥 》编辑部的故事、炊事班的故事、闲人马大姐、武林外传和家有儿女、我爱我家 《天狗》《紫日》《花宵道中》《日本之耻》 《82 年生的金智英》《东邪西毒》《留夏》《钢琴家》《宵禁》《蚯蚓》《塔利》《盼归》《闻香识女人》《我们天上见》《青蛇》《海上钢琴师》《小丑》《四个春天》《驭风男孩》《星际穿越》《海边的曼彻斯特》《边缘日记》《毒液》《燃烧》《风雨哈佛路》《全能囧爸》《孙子从美国来》《骡子》《小鞋子》《率性而活》《横空出世》《风雨同路》《逃学威龙之龙过鸡年》《望夫成龙》《荒城纪》","link":"/2019/12/18/Movie-collection/"},{"title":"音乐集","text":"封面图片出处Pexels 上的 Vlad Bagacian 拍摄的照片 《花火が瞬く夜に》 《疯人院》 - 华晨宇 《烟火里的尘埃》 - 华晨宇《aLIEz》 - 泽野弘之 《偏爱》《你瞒我瞒》《青鸟》 - 生物股长 《心墙》《如果我变成回忆》 《Unravel》 - TK from 凛として时雨 《此生不换》《王妃》《你一定要幸福》《爱情买卖》《红色高跟鞋》《说谎》《要嫁就嫁灰太狼》《我爱他》《说散就散》《心痛 2009》《庐州月》《pretty boy》《笨小孩》《星语星愿》《修炼爱情》《很爱很爱你》《我可以抱你吗》《输了你赢了世界又如何》《记事本》《精忠报国》《有多少爱可以重来》《你的答案》《Dream It Possible》《不为谁而作的歌》《Hall of Fame》《不要认输》 - 坂井泉水《那个人》《My All》 - 滨崎步 《曾经我也想过一了百了》 - 中岛美嘉《假装》《Numb》《Silver Scrapes》《忽然之间》《Hybrid Worlds》《Warriors》《月亮惹的祸》《Worlds Collide》《lgnite》《原来你什么都不要》《Legends Never Die》《RISE》《海阔天空》《涅槃》《我会好好的》《没有如果》《世界第一等》《如果这都不算爱》《犯错》 《某科学的超电磁炮》 - 南条爱乃 《极乐净土》 - GARNiDELiA《恋爱循环》 - 花泽香菜 《够爱》 《关不上的窗》《我知道》《我的好兄弟》《像我这样的人》《卷珠帘》《你就不要想起我》 后续删改","link":"/2019/12/18/Music-collection/"},{"title":"置顶内容","text":"重基础、看源码、开源自己的项目。重基础、看源码、开源自己的项目。重基础、看源码、开源自己的项目。 很烦，装了个 nvm node管理工具，然后 hexo 需要升级……。然后重新建立个 hexo 博客，装了主题，把文章挪过来了，其他东西也懒得弄了。博客中的图片可能会有缺失，回头我在传到我自己搭建的 图床上。 [我的学习仓库][https://github.com/Fallen-down/little] 10分钟快速搭建属于自己的文档网站","link":"/2026/10/12/Sticky-content/"},{"title":"接口","text":"获取省市县省：https://datavmap-public.oss-cn-hangzhou.aliyuncs.com/areas/csv/100000_province.json市：https://datavmap-public.oss-cn-hangzhou.aliyuncs.com/areas/csv/510000_city.json县：https://datavmap-public.oss-cn-hangzhou.aliyuncs.com/areas/csv/341700_district.json 手机号码归属地查询接口淘宝网（精确到省份）：http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=18331623695百付宝（精确到省份）：https://www.baifubao.com/callback?cmd=1059&amp;callback=phone&amp;phone=15850781443 相关资料阿里云的省市区经纬度接口√手机号码归属地查询api接口√","link":"/2020/05/29/Utils-10/"},{"title":"假数据","text":"JSONPlaceholder虚假的在线REST API，用于测试和原型制作JSON Server mork生成随机数据，拦截 Ajax 请求 Easy Mock在线伪造数据 faker.js在Node.js和浏览器中生成大量逼真的假数据 相关资料faker.js 登 GitHub 趋势榜标星 27.1k，可大批量生成假数据！","link":"/2020/06/07/Utils-11/"},{"title":"前端测试工具","text":"跨浏览器测试工具BrowserShots 支持多种浏览器 生成屏幕截图展示不同浏览器渲染表现 在线工具 Browser Sandbox 可运行在桌面和平板上的应用程序 支持多种浏览器 MultiBrowser 桌面应用程序 测试网站的桌面版本和移动版本 可以进行手动测试或自动化测试 支持多种浏览器 LambdaTest 在线服务 进行不同平台的跨浏览器测试 提供集成调试工具 Experitest Cross Browser Testing 测试网站在不同环境下的兼容性和性能 可以与其他服务集成起来(比如 Github、Gitlab、Jenkins、TravisCI 和 CircleCI 等) 网站的部署流程流水线化 BrowserStack 跨浏览器测试 被一些大型开源项目采用 browserling浏览器兼容测试网址 移动端测试vConsole 移动端调试工具 Fundebug 专业的应用 BUG 监控平台 相关资料17款最好用的跨浏览器测试工具移动端调试痛点？——送你五款前端开发利器√微信小程序bug免费监控√","link":"/2020/06/07/Utils-13/"},{"title":"24个数据分析网站","text":"公众号 大数据导航 清博大数据指数 爱微帮 新榜 微小宝 浏览器的数据报告 百度指数 360 趋势 做研究的机构 数读 企鹅智库 腾讯研究院 淘宝后台的数据分析 淘数据 生意参谋 视频平台的分析 抖音快手网tbd 九九抖商 火烧云 影视综艺电视节目 骨朵数据 猫眼票房分析 艾瑞数据 App的数据 七麦数据 国家统计局 以上是我对下列视频及文章的归纳和总结。市场调查2：做数据研究不得不知道的23个数据分析网站","link":"/2020/04/14/Utils-14/"},{"title":"工具","text":"封面图片出处Pexels 上的 Matheus Viana 拍摄的照片 办公类软件 Listary、Everything快速搜索本地文集，快速定位文集，快速打开搜索引擎搜索内容 Dittowindows 剪切板管理工具，支持批量复制，一次性黏贴 Winsnap截图工具，自动把图片旁边加上阴影，美观，可以使用全屏、应用程序、窗口、对象等捕捉模式 Cmder命令行工具，支持大部分 Linux 命令，支持 ssh 连接 Linux,还可以在它的窗口中新建 cmd 和 powershell记得安装完在配置 Setting-Startup-Environment 里面加上 setLANG=zh_CN.UTF8,否则输出的一些中文会乱码 TyporaMarkdown 编辑器，Typora 将编辑和预览合并到一起，还支持 Latex、【TOC】动态目录、拖拽图片自动生成本地预览链接，自定义主题等方便的功能。 Quick LookMicrosoft Store 里面可下载的一个速览工具，选中目标文件，按空格就可以快速预览，支持图片、视频、音频、压缩包、PDF、文本文件、Markdown、HTML 等格式。无法在 windows 10 S 系统上运行。 GifCam 和 Screen ToGif免费 Gif 屏幕录制工具 Free Download Manage免费的下载工具 Sourcetree一款跨平台的免费的 Git 客户端管理工具，不用手打各种 Git 操作命令 闪电下载是一款支持磁力、BT、度盘的下载神器，支持边下边播。 Internet Download Manager收费的下载工具 蓝奏云免费注册、上传文件、分享链接 日常工具软件 PotPlayer视频播放器 Myper SplashMicrosoft Store 里面可下载的一个高质量壁纸库，所有壁纸来源 Unsplash 网站，均无版权可以免费使用 WGestures 全局鼠标手机一个更简短，更现代的鼠标手势。免费&amp;开源 格式工厂视频、音频等格式转换 nvdia experience 和 obs直播、视频录制N 卡推荐 nvdia experience 视频素材网站 mixkit.co视频和插画，免费下载可商用 Pexels.com综合的素材网站，图片、视频，可以免费并且商用不能二次售卖 pixabay.com不需要注明出处，免费可商用。 videezy.com视频、注明出处、付费、免费 音频素材： freesound.org免费且商用网站素材必须署名并附上链接 Youtube：https://www.youtube.com/audiolibrary/soundeffects?nv=1在 Youtube 不会有版权问题 https://audionautix.com/免费且商用网站素材必须备注好出处 https://offers.adobe.com/en/na/audition/offers/audition_dlc/AdobeAuditionDLCSFX.html?cq_ck免费且商用网站素材 不可二次售卖 网站类聚合导航 www.egouz.com工具类聚合导航 www.jingzhunyun.com大数据导航 hao.199it.com电子书搜索 www.zqbook.top格式转换工具网站 www.alltoall.net（10M 内）文库下载类网站 www.lingfengyun.com多媒体集合网站 www.apowersoft.cnpdf 工具集合网站 tools.pdf24.org软件下载网站 www.fosshub.com教程类学习网站 www.oeasy.org免费广告拦截器 Adblock Plus（免除“澳门赌场，美女荷官”有助于“学 ♂ 习”） 意林杂志网编程学习网站微信读书网页版博客内容转换成小视频vue 30 天密码管理工具文档分享网渣男语录五合一收款码生成网站设计网站主题有声读物国外名著的有声网站欧洲有声书网站百度文库下载微信文章搜索引擎集合导航网 解压软件 bandizip可以对文件快速预览 dimmy 俱乐部（设计类）imgbot（工具类；在线图片编辑）virscan（工具类；多引擎病毒在线扫描）猫耳 FM（第一家弹幕音图站，中国声优基地） GitHub 项目推荐（仅供学习交流、不可商用）：音乐搜索器源码MK 在线音乐播放器 洛奇 town（分享类；鱼声音乐精选,每日推荐、论文检索） 北大清华交大中科大浙大 音乐平台Audio LibraryEpidemic SoundAudiojunglePond5PremiumBeatMusicbed 装系统四大名著阅读网站地图网站像素动画收藏工具 编程游戏Windows10 激活工具简历制作工具英语进阶指南截图、处理、上传、录屏软件工具集合图片智能放大密码管理工具PPT 生成 H5迅雷账号分享网站每日一文渣男：说话的艺术在线工具箱论文期刊的存取网站营养分析网站 语音转文字iSlide PPT 工具 VideoFK在线视频抓取下载工具 RRYSJ人工智能字幕听译工具 全历史历史内容聚合网站 设计师专属字体下载 +字体识别工具 +字体商用查询字由字体商用查询UzerMe 云端办公工具SoBooks 强大的电子书资源网站最强大的全品类素材下载网站一键式设计工具+智能抠图虫部落 重度网络资源藏家社区全网音乐免费下载工具 以 PNG 格式提供素材的网站，非常适合一些设计师使用矢量图标插图日本扁平图标网页版 ps 阿里巴巴矢量图标库寻图标 图标摄图网综合素材付费千图网付费每日灵感免费花瓣网免费字体之家免费Coolors 免费中国色彩大辞典免费在线思维导图工具 音乐网站https://www.pond5.com/https://musicvine.com/https://audiojungle.net/https://www.epidemicsound.com/https://www.musicbed.com/ 在线抠图PDF 在线转换知轩藏书MSDN（我告诉你）PPT 模板免费下载http://www.ypppt.com/无损音乐下载秘塔写字猫无需编程爬虫工具集合 自学编程网站B 站慕课网GitHub菜鸟教程w3cschoolw3schoolCodecademyCourSeseraedxUdemyaGupieWareMDN力扣C 语言网洛谷FreeCodeCamp程序员文档 录屏软件 bandicammarkdown 编辑器资源搜索神器手机音乐 APP Office 安装、激活、文档格式转换 看球软件：看个球加密工具：快贴动漫图片出处搜索压缩软件 eZip 装系统 设计类网站导航网站-小黄狗设计导航网站-设计导航软件下载网站-麦氪派软件下载网站-奇迹秀素材管理工具-Eagle素材参考下载-模板王UI 素材网站-UI8网页模板参考-怪兽模版全能资源网站-envato 云盘:6 盘动态桌面：火萤、upupoo、wallpaper engine 备忘录软件：to dowin10 提升游戏体验的 7 大秘传技 学习办公截图工具：SnipastePDF 编辑器：福昕编辑器XMind 思维导图OneNote 笔记软件新手剪辑Potplayer 视频播放软件Mediacoder 视频格式转换工具、不损耗画质硕鼠 视频下载工具Arctime 字幕软件小丸工具箱 压缩视频、视频格式转换idm 视频下载工具油猴插件 视频下载工具整合订阅网站微软网站注册 12355 青小聊公益机构 Win10 自带超强功能 连接远程桌面 TeamViewerUltraviewerAnyDesk 腾讯为村 后续会进行分类，整合整理 相关资料免费远程桌面连接控制工具、在线智能改写平台、隐藏各种格式文件数据 │ 今天有什么？ 干货推荐！程序员必备的13个 免费技术电子书网站","link":"/2019/12/23/Utils-1/"},{"title":"程序员常去得网站","text":"GitHub掘金(这个我常用)CSDNCSDN开源中国简书(看看文章还想看技术类我感觉质量不高)思否知乎(不做过多评价，本人菜鸡一个)V2EX51CTOITPUB 技术论坛博客园威锋网ChinaUnixstackoverflow51 开发者社区落伍者蓝色理想IT 写作社区博客堂W3SchoolITEye开发者头条GitChat51CTO 博客Ruby ChinaPHP 中文社区Node.js 专业中文社区(之前用过一段时间，我觉得很好用)苹果开发中文站PHPHubw3ctechphp100InfoQcss-tricksMDNNPM脚本之家前端里廖雪峰WEB 开发者web 资源网站汇总牛客网力扣https://www.quoraconsulting.com/http://reddit.com/https://www.infoq.cn/https://toutiao.io/http://www.cocoachina.com/https://www.tuicool.com/https://www.jiuzhang.com/我要自学网极客学院网易云课堂腾讯课堂 工具HeadJS 提速网站在线浏览器在线 SQL 等.htaccess 以上资源均来自网络，如有侵权等行为，请联系我，我会立即标明出处等。相关资料交公粮了：十一在家我都逛哪些技术网站？深夜里，程序员最喜欢去的网站竟然是 …","link":"/2020/01/03/Utils-15/"},{"title":"工具——科学上网","text":"Lantern 蓝灯baacloud","link":"/2020/04/21/Utils-2/"},{"title":"关于前端的工具","text":"Mahdhi Rezvi 原作，翻译转载自 New Frontend 。 1、EnjoyCSSEnjoyCSS 提供了一个简单的交互界面，帮助我设计元素，然后自动输出相应的 CSS 代码。适用于开发简单页面时使用。 2、Prettier PlaygroundPrettier 是一个代码格式化工具，支持格式化 JavaScript 代码（包括 ES2017、JSX、Angular、Vue、Flow、TypeScript 等）。 3、Postman测试后端 API 接口。 4、StackBlitz可以在线尝试一些样例代码或者库。 5、Bit.dev分享可重用的组件和片段，降低开发量，加速开发进程。 6、CanIUse可以方便地查看各大浏览器对某个特性的支持程度。 作者：凉皮 来源：转载于麻瓜编程公众号 7、CSS Battle在线比拼 CSS 8、Learn CSS layout在线CSS布局学习 9、Flexbox Froggy学习 Flex 布局的小游戏 10、CSS-TricksCSS 技巧 11、Neumorphism实现新拟态效果 12、uiGradients分享渐变色 13、JavaScript 秘密花园JavaScript 的语法文档，如何去避免一些常见的错误，以及找到很难发现的 bug ，比较深入 JavaScript 的语言特性。 14、JS Tips 每天一个 Javascript 小知识。 15、JSweekly专门讲解 Javascript 的技术周刊。 16、CDNJSJavaScript 资料库 17、Beautiful Open 开源 JS 库集合 18、JavaScript Fun一个集合当下最流行的 JavaScript 代码库，显示流行排行，开发者可以轻松的找到想要最新的代码插件、工具和博客。 19、Stack Overflow全球IT界最受欢迎的技术问答网站之一，一个解决 bug 的社区，称为“ 编程界的十万个为什么 ”。 20、掘金掘金技术社区是质量很高的技术分享社区，技术大牛和极客们共同编辑筛选的优质干货，这些技术文章包括Android、iOS、前端、后端资源。 21、Codrops发表技术文章和网页教程，提供经验，少踩坑，资源丰富很丰富，很多优秀的技术都是从这里来的。 22、CodePen一个网站前端设计开发平台，针对网站前端代码的一个工具，上面有各种效果的案例特效（炫技），可以在他们的 demo 基础上开发自己的前端设计。 23、CodeSandBoxCodeSandBox 网站提供一个在线开发环境的“沙盒”，主流的框架如 React、Vue、Angular 等，都可即开即用、实时编译预览，非常方便。 24、JS Bin轻量级在线编辑器网站 25、ICONSVG在线自定义设计SVG图标素材 26、OpenMoji免费表情符号库 27、Share Icon免费矢量素材图库 28、tableconvert在线表格编辑器 29、Feathericons极简 ICON 图标集 30、HTML5 + CSS 3 免费模版提供大量的HTML5模版，用户可以自己分享和修改模版。 31、Cool Backgrounds炫酷背景生成器 32、Alteredqualia网页端 3D 效果合集 相关资料推荐|六个好用的前端开发在线工具不可错过的实用前端工具4 个程序员拯救设计的网站，太惊艳了！","link":"/2020/04/25/Utils-3/"},{"title":"常用命令","text":"1、ping 命令 命令格式 ping 主机名 ping 域名 ping IP 地址 2、ipconfig 命令 ipconfig ipconfig /all ipconfig /release 和 ipconfig /renew 3、arp 命令 arp –a arp -a IP arp -s IP 物理地址 arp -d IP 4、traceroute 命令 以上是我对下列视频及文章的归纳和总结。程序员必备 9 大命令，实用！","link":"/2020/04/26/Utils-4/"},{"title":"免费图床","text":"亲测成功，PicGo域名设置中一定要注意是 https://cdn.jsdelivr.net/gh/[username]/[仓库名] 我之前尝试的时候少了.net，死活出不来。 以上是我对下列视频及文章的归纳和总结。五分钟学会搭建带有CDN加速的免费图床 相关资料图床工具的使用—PicGo免费CDN：jsDelivr+Github 使用方法PicGo + GitHub 搭建个人图床工具 相关工具PicGojsdelivr","link":"/2020/05/03/Utils-5/"},{"title":"免费网站托管站点","text":"英文 | https://www.geeksforgeeks.org/7-best-sites-for-free-web-hosting/?ref=leftbar-rightbar翻译 | web前端开发（ID：web_qdkf） WordPress 储存容量高达3GB WordPress.com子域 各种免费模板 自动备份和更新 WIX 储存容量高达500MB Wix.com子域 拖放工具以及各种免费模板 高级安全监控 自动设定 weebly 储存容量高达500MB Weebly.com子域 免费的SSL安全性 各种免费模板 免费SEO AwardSpace 储存容量高达1GB 一个免费域（带有dx.am扩展名）和3个免费子域 一键式CMS安装程序（WordPress或Joomla） 完全无广告 基于Web的文件管理器 000webhost 300 MB磁盘空间 无广告托管 完整的PHP和MySQL数据库支持 一键式安装过程 各种免费模板 InfinityFree 无限的磁盘空间和带宽 免费SSL 400个MySQL数据库 无广告托管 免费DNS服务 FreeHostia 储存容量高达250MB 5个托管域 各种免费模板 高安全性 包括站点管理工具 以上是我对下列视频及文章的归纳和总结。7个实用的免费网站托管站点","link":"/2020/05/03/Utils-6/"},{"title":"前端常用工具、插件、类库","text":"封面图片出处Pexels 上的 Matheus Viana 拍摄的照片 抓包代理工具Fiddler Charles Whistle 以上是我对下列视频及文章的归纳和总结。一文搞定前端代理骚操作！再也不怕线上bug啦","link":"/2020/05/13/Utils-8/"},{"title":"关于前端学习的网址","text":"收藏夹爆满~~~溢出来一些内容 互联网公司 github阿里巴巴阿里妈妈腾讯 vConsole移动端调试工具之前用过，不错 腾讯 AlloyTeam AlloyLever没用过感觉不错 AlloyImage图像处理库 百度 EFE team百度 FEX team奇虎 360网易搜狐美团点评饿了么饿了么前端豆瓣豌豆荚bilibili小米伯乐在线蘑菇街有赞滴滴组织极光开发者个人PanJiaChenxd-tayde编码面试大学 技术整合美团技术团队饿了么前端 - 知乎百度 FEX百度 EFE奇舞团博客 以上是我对下列视频及文章的归纳和总结。国内互联网公司 github 网址","link":"/2020/05/27/Utils-9/"},{"title":"imgcook 设计稿一键智能生成代码","text":"imgcook 精准还原,所见所得 生成代码,可维护强 机器智能,识别理解 DSL / Plugin，可自定义 视频中使用的是 sketch 插件，我是 windows 系统……，下载完 sketch 一查 只能在 Mac 上使用。下载了 Photoshop 插件，安装了，我在 Photoshop 上找不到插件，我看了看 imgcook 文档可以直接上传图片然后生成相关代码。我平时不常用 Photoshop ，直接把 Photoshop 插件 清除了。上传图片生成代码的链接我放在相关资料里了。 以上是我对下列视频及文章的归纳和总结。imgcook 神器 相关资料imgcook 文档文件生成代码","link":"/2020/05/05/Utils-7/"},{"title":"JavaScript 从入门到实践开发","text":"JavaScript 简介JavaScript 使用方式通过 &lt;script&gt;&lt;/script&gt; 中直接编写 通过 &lt;script src='目标文件的url'&gt;&lt;/script&gt; 链接外部的 js 文件 作为某个元素的事件属性或者是超链接的 href 属性值 代码屏蔽12345&lt;script&gt; &lt;!-- js 代码 //--&gt;&lt;/script&gt; 如果浏览器不支持 js ，可以使用 &lt;noscript&gt;&lt;/noscript&gt; 标签，显示 noscript 中的内容 JavaScript 的基本语法JavaScript 的执行顺序 ：按照在 HTML 文件中出现的顺序依次执行 大小写敏感：JavaScript 严格区分大小写 忽略空白符和换行符 语句分隔符使用 ; 结束语句 可以把多个语句写在一行 最后一个语句的分号可以省略，但尽量不要省略 可以使用 {} 括成一个语句组，形成一个块 block 通过 \\ 对代码进行折行操作：123document.write('hello\\world') 注释单行注释 // 多行注释 /* 注释内容 */ JavaScript 的保留字通过 document.write() 向文档书写内容 通过 console.log() 向控制台写入内容 JavaScript 中的错误语法错误：通过控制台进行调试 逻辑错误：通过 alert() 进行调试 JavaScript 的变量变量声明变量通过 var 关键字声明变量 可以声明变量的同时给变量赋值 可以一次声明一个变量也可以一次声明多个变量 如果只声明变量未对其赋值，默认值为 undefined 如果变量重名会覆盖 变量命名变量名称严格区分大小写 变量名称最好含义明确，以字母或者下划线开始，跟上数字、字母、下划线，最好遵循驼峰标记法或下划线法。 变量在内存中的存储与释放收集方式收集内容回收算法数据类型与变量原始数据类型数值型JavaScript中数值包含整数和浮点数，所有数值都以双精度浮点型来表示。 双精度浮点数可以表示 -2 的 53 次方到 2 的 53次方的整数，也可以表示为正负1.7976 的 10 的 308 次方的最大值和正负 2.2250 乘以 10 的 -308 次方的浮点数。 十进制数：12、1.2、-23、.222e33、-1.3e3、3.E-2、12e+20 十六进制：0x0、0XABCDEF、0x1a2b3c4d 八进制：00、0123、0241234 特殊值：Infinity 无穷大(1.79e309~-1.79e309) NaN(0/0、通过 isNaN() 来检测是否是 NaN 值) 字符串型定界符 “|“ 转义符 12345\\n -&gt; 回车换行\\r -&gt; 换行\\t -&gt; 水平制表符\\' -&gt;'\\\\ -&gt; \\ 布尔类型true|false 复合数据类型对象(object)数组(array)函数(function)特殊数据类型无定义数据类型 undefined（用来表示不存在的值或者未赋值的变量。对一个变量只声明不赋值或者赋予一个不存在的属性值，都会使这个变量的值为 undefined） 空值 null（表示什么都没有，相当于一个占位符。null 和 undefined 的区别是 undefined 表示变量未被赋值，而 null 表示变量被赋予一个空值） 类型转换隐式转换转换成布尔类型12345undefined -&gt; falsenull -&gt; false数值 0 或者 0.0 或者 NaN -&gt; false字符串长度为 0 -&gt; false其他对象 -&gt; true 转换成数值型12345undefined -&gt; NaNnull -&gt; 0true -&gt; 1 | false -&gt; 0内容为数字 -&gt; 数字，否则转换成 NaN其他对象 -&gt; NaN 转换成字符串型12345undefined -&gt; 'undefined'null -&gt; nulltrue -&gt; &quot;true&quot; false -&gt; &quot;false&quot;数值型 -&gt; NaN、0 或者与数值对应的字符串其它对象 -&gt; 如果存在这个对象则转换为 toString() 方法的值，否则转换 Undefined 显示转换转换成布尔类型123456通过 Boolean 函数强制转换成布尔值0、-0 -&gt; falseNaN -&gt; false空字符串 -&gt; falseundefined -&gt; falsenull -&gt; false 转换成数值型123456通过 String 函数强制转换成字符串数值 -&gt; 数值本身字符串 -&gt; 字符串本身true -&gt; &quot;true&quot;,false -&gt; &quot;false&quot;undefined -&gt; &quot;undefined&quot; null -&gt; &quot;null&quot; 转换成字符串型1234567891011121314151617通过 Number 函数强制转换成数值数值 -&gt; 转换成原来的值字符串 -&gt; 如果可以解析为数值，则转换成数值；否则转换成 NaN 或者 0true -&gt; 1，false -&gt; 0undefined -&gt; NaNnull -&gt; 0通过 parseInt(string,radix) 返回转换成整数的值如果 string 以 0X 开头，parseInt()会把 string 的其余部分解析为十六进制的整数如果 string 以 1~9 的数字开头，parseInt()将把它解析为十进制的整数字符串如果以合法字符开始，截取合法字符开头和结尾的空格是允许的如果字符串的第一个字符不能被转换成数字，parseInt()会返回 NaN在字符串以 “0” 为开始时旧的浏览器默认使用八进制基数。ECMAScript 5,默认的是十进制的基数通过 parseFloat() 返回转换成浮点型的值该函数指定字符串中的首个字符是否为数字，如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。 编程思想面向过程 面向对象 面向过程面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。 面向对象面向对象是把事务分解成一个个对象，然后由对象之间分工与合作。面向对象是以对象功能来划分问题，而不是步骤。 在面向对象程序开发思想中，每个对象都是功能中心，具有明确分工。 面向对象编程具有灵活、代码可复用、容易维护，更适合多人合作的大型软件项目。 面向对象的特性： 封装性 继承性 多态性 面向过程 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就是采用的面向过程编程。 缺点：没有面向对象易维护、易复用、易扩展 面向对象 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特点，可以设计出低耦合的系统，使系统更加灵活，更加易于维护 缺点：性能比面向过程低 面向对象更贴近我们的实际生活，可以使用面向对象描述现实事物，但是事物分为具体的事物和抽象的事物 面向对象的思维特点： 1、抽取（抽象）对象共用的属性和行为组织（封装）成一个类（模板） 2、对类进行实例化，获取类的对象 类抽象了对象的公共部分，它泛指某一大类（class） 对象特指某一个，通过类实例化一个具体的对象 1234567891011121314151617181920212223242526// 1、创建类 class 创建一个 “明星”类class Star { constructor(uname){ this.uname = uname } say() { console.log('我叫' + this.uname) } sing(song){ console.log(this.uname + song) }}// 2、利用类创建对象 new var ldh = new Star('刘德华');var zxy = new Star('张学友');console.log(ldh.uname); // 刘德华console.log(zxy.uname); // 张学友/* * (1) 通过 class 关键字创建类，类名习惯性定义首字母大写 * (2) 类里面有个 constructor 函数，可以接受传递过来的参数，同时返回实例对象 * (3) constructor 函数 只要 new 生成实例时，就会自动调用这个函数，不写这个函数，类也会自动生成这个函数 * (4) 生成实例 new 不能省略 * (5) 最后注意语法规范，创建类，类名后面不要加小括号，生成实例 类名后面加小括号，构造函数不需要加 function */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1. 类的继承class Father { constructor(x,y){ this.x = x; this.y = y; } money(){ console.log(100) } sum(){ console.log(this.x + this.y) // this 指向的是这个方法的调用者 } say(){ return '我是爸爸'; }}class Son extends Father { constructor(x,y){ // constructor 里面的 this 指向的是 创建的实例对象 super(x,y); // 调用父类的 constructor 调用普通函数 this.x = x; this.y = y } say(){ console.log('我是儿子'); console.log(super.say() + '的儿子'); // super.say() 调用父类的普通函数 }}var son = new Son(1,2)son.money()son.sum()/* * 1. 继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的 * 2. 继承中，如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原则） */son.say()/* * 1. 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 * 2. 类里面的共有的属性和方法一定要加 this 使用。 * 3. constructor 里面的 this 指向实例对象，方法里面的 this 指向这个方法的调用者 */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 例子 实现 tab 增删改查var that;class Tab { constructor(id){ that = this; this.main = document.querySelector(id); this.add = this.main.querySelector('.tabadd'); this.ul = this.main.querySelector('.fisrstnav ul:first-child'); this.init(); } updataNode(){ this.lis = this.main.querySelectorAll('li'); this.sections = this.main.querySelectorAll('section'); this.remove = this.main.querySelectorAll('.icon-guanbi'); this.spans = this.main.querySelectorAll('.fisrstnav li span:first-child'); } init() { this.updataNode() this.add.onclick = this.addTab; for(var i = 0; i &lt; this.lis.length; i++){ this.lis[i].index = i; this.lis[i].onclick = this.toggleTab; this.remove[i].onclick = this.removeTab; this.spans[i].ondblclick = this.editTab; } } clearClass() { for(var i = 0;i &lt; this.lis.length; i++){ this.lis[i].className = ''; this.sections[i].className = ''; } } toggleTab() { that.clearClass(); this.className = 'liactive' that.sections[this.index].className = 'conactive' } addTab() { // 以前的做法：动态创建元素 createElement ，但是元素里面内容较多，需要 innerHtml 赋值，在 appendChild 追加到父元素里面 // 现在高级做法：利用 insertAdjacentHTML() 可以直接把字符串格式元素添加到父元素中 // appendChild 不支持追加字符串的子元素， insertAdjacentHTML 支持追加字符串元素 var li = '&lt;li class = &quot;liactive&quot;&gt;&lt;span&gt;测试1&lt;/span&gt;&lt;span class= &quot;iconfont icon-gu&quot;&gt;&lt;/span&gt;&lt;/li&gt;' that.ul.insertAdjacentHTML('beforeend',li); that.init() } removeTab(e) { e.stopPropagation(); // 阻止冒泡 var index = this.parentNode.index; // 获取父元素的 index that.lis[index].remove(); // remove() 方法可以直接删除指定的元素 that.sections[index].remove(); that.init(); // 当我们删除的不是选中状态的 li 的时候，原来的选中状态 li 保持不变 if(document.querySelector('.liactive')) return; // 当我们删除了选中状态的 li 的时候，让它的前一个 li 处于选定状态 index--; that.lis[index] &amp;&amp; that.lis[index].click() // 手动调用点击事件 } editTab(){ var str = this.innerHTML; // 双击禁止选定文字 window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty() this.innerHTML = '&lt;input type=&quot;text&quot;&gt;'; var input = this.children[0]; input.value = str; input.select(); // 文本框里面的文字处于选定状态 input.onblur = function(){ this.parentNode.innerHTML = this.value; } input.onkeyup = function(e){ if(e.keyCode === 13){ // 手动调用表单失去焦点事件 this.blur() } } }}new Tab(&quot;#tab&quot;) 构造函数和原型 创建对象可以通过以下三种方式： 1、对象字面量 2、new Object() 3、自定义构造函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var obj1 = new Object();var obj2 = {}/* * 构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量初始化赋值，它总与 new 一起使用。 * 我们可以吧对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 * * 在 js 中，使用构造函数时要注意以下两点： * 1. 构造函数用于创建某一类对象，其首字母要大写 * 2. 构造函数要 new 一起使用 才有意义 * * new 在执行时会做四件事情 * 在内存中创建一个新的空对象。 * 让 this 指向这个新的对象 * 执行构造函数里面的代码，给这个新对象添加属性和方法。 * 返回这个新对象 * * 实例成员就是构造函数内部通过 this 添加成员 uname age sing 就是实例成员 * 实例成员只能通过实例化的对象来访问 */function Star(uname,age){ this.uname = uname; this.age = age; this.sing = function (){ // 这样写会造成内存浪费 构造函数通过原型分配的函数时所有对象所共性的。 console.log('我会唱歌') }}/* * 构造函数通过原型分配的函数时所有对象所共享的。 * JavaScript规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。 * 注意这个 prototype 就是一个对象，这个对象的所有属性和方法。都会被构造函数所拥有。 * 把一些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 */Star.prototype.sing = function(){ console.log('我会唱歌');}var ldh = new Star('刘德华',18);ldh.sing();/* * 不能通过构造函数来访问实例成员 * 静态成员 在构造函数本身上添加的成员 */ Star.sex = '男' // 静态成员只能通过构造函数来访问 console.log(Star.sex) 对象原型 __proto__ 对象都会有一个属性 __proto__ 指向构造函数的原型对象 prototype，之所以我们对象可以使用构造函数 prototype 原型对象的属性 和方法，就是因为对象 __proto__ 原型的存在。 __proto__ 对象原型和原型对象 prototype 是等价的。 constructor 构造函数 对象原型（__proto__）和构造函数（prototype） 原型对象 里面都有一个属性 constructor 属性，constructor 称为构造函数 它指回构造函数本身。 constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。 12345678910Star.prototype = { constructor: Star, sing: function(){ console.log('我会唱歌') }, movie: function(){ console.log('我会演电影') }} 原型链 Star 原型对象 prototype.__proto__ 指向 object 原型对象 prototype object 原型对象 prototype.__proto__ 指向 null 查找机制 原型链查找 就近原则 this 指向问题 在构造函数中，里面的 this 指向的是对象实例 原型对象函数里 this 指向的是 调用者 扩展内置对象 1234567891011console.log(Array.prototype)Array.prototype.sum = function(){ var sum = 0; for(var i = 0; i &lt; this.length; i++){ sum += this[i]; } return sum;} var arr = [1,2,3]console.log(arr.sum()) 继承 call 改变 this 指向 1234567891011121314function fn(x,y){ console.log('我想喝手磨咖啡'); console.log(this) console.log(x + y)}var o = { name : 'andy'}/* * call() 可以调用函数 * call() 可以改变这个函数的 this 执行 */fn.call(o,1,2) 1234567891011121314151617function Father(uname,age){ this.uname = uname; this.age = age;}Father.prototype.money = function(){ console.log(10000);}// 继承 构造函数内的属性function Son(uname,age){ Father.call(this,uname,age);}Son.prototype = new Father()Son.prototype.constructor = Son;Son.prototype.exam = function(){ console.log('孩子考试')} 类的本质 class 还是函数 1234567ES6 之前通过，构造函数 + 原型实现面向对象 编程1. 构造函数有原型对象 prototype2. 构造函数原型对象 prototype 里面有 constructor 指向构造函数本身3. 构造函数可以通过原型对象添加方法4. 构造函数创建的实例对象又 __proto__ 原型指向 构造函数的原型对象ES6 的类其实是语法糖 数组方法 123456迭代（遍历）方法： forEach()、map()、filter()、some()、every()forEach(callback(element[, index[, array]])) return 不会终止遍历filter(callback(element[, index[, array]])) 注意它直接返回一个新数组 return 不会终止遍历some(callback(element[, index[, array]])) 注意它返回值是布尔值，如果查找到这个元素，就返回 true，如果查找不到就返回 false唯一的时候 some 更合适 return true 终止遍历 迭代效率更高 字符串方法 1trim() 方法去除字符串两侧空格 对象方法 123456789Object。defineProperty(obj, prop, descriptor) 定义对象中新属性或修改原有的属性。var o = {}；Object.defineProperty(o, &quot;a&quot;, { value : 37, writable : true, // 允许被赋值运算符改变 enumerable : true, // 允许属性出现在对象的枚举属性中 configurable : true // 允许 该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。}); 函数进阶 12345678910111213141516171819/* * 函数的定义方式 * 1. 自定义函数（命名函数） * 2. 函数表达式（匿名函数） * 3. 利用 new Function('参数1'，'参数2'，'函数体') * 所有函数都是 Function 的实例（对象） * 函数属于对象 万物皆对象 */ function fn() { // 自定义函数 } var fun = function() { // 函数表达式 （匿名函数） } var f = new Function('a','b','console.log(a+b)') // 利用 new Function f(1,2) console.log(f instanceof Object) 函数调用方式 12345678910111213141516171819202122232425262728291. 普通函数function fn(){ console.log('人生的巅峰'); }fn(); fn.call();2. 对象的方法var o = { sayHi: function(){ console.log('人生的巅峰'); }}o.sayHi();3. 构造函数function Star(){ }new Star()4. 绑定事件函数btn.onclick = function () {} // 点击按钮可调用这个函数5. 定时器函数setInterval(function(){},1000) // 这个函数是定时器自动调用6. 立即执行函数(function(){})() this 指向 当调用函数的时候确定的，调用方式不同决定了 this 的指向不同，一般指向我们的调用者 调用方式 this 指向 普通函数调用 window 构造函数调用 实例对象 原型对象里的方法也指向实例对象 对象方法调用 该方法所属对象 事件绑定方法 绑定事件对象 定时器函数 window 立即执行函数 window 改变函数内部 this 指向 bind()、call()、apply() call 方法 1234567891011121314151617181920212223var o = { name: 'andy'}function fn (a,b){ console.log(this.name) console.log(a + b)}fn.call(o,1,2)// call 主要作用可以实现继承function Father(uname,age,sex){ this.uname = uname; this.age = age; this.sex = sex;}function Son(uanme,age,sex){ Father.call(this,uname,age,sex);}var son = new Son('刘德华',18,'男');console.log(son); apply 方法 12345678910111213141516171819fun.apply(thisArg,[argsArray])var o = { name: 'andy'}function fn (arr1,arr2){ console.log(this.name) console.log(arr1) // 1 console.log(arr2) // 2}fn.apply(o,[1,2])求最大值、最小值同理var arr = [1,66,3,99,4];// Math.max(value1[,value2, ...]) var max = Math.max.apply(Math,arr);console.log(max) bind 方法 不会调用原来的函数 可以改变原来函数内部的 this 指向 返回由指定的 this 值的初始化参数改造的原函数拷贝 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103fun.apply(thisArg,arg1,arg2,...) var o = { name: 'andy'}function fn (a,b){ console.log(this.name) console.log(a + b)}var f = fn.bind(o,1,2);f();应用-按钮禁用后开启btn.onclick = function(){ this.disabled = true setTimeout(function(){ this.disabled = false }.bind(this),3000)}// 例子 实现 tab 增删改查class Tab { constructor(id){ this.main = document.querySelector(id); this.add = this.main.querySelector('.tabadd'); this.ul = this.main.querySelector('.fisrstnav ul:first-child'); this.init(); } updataNode(){ this.lis = this.main.querySelectorAll('li'); this.sections = this.main.querySelectorAll('section'); this.remove = this.main.querySelectorAll('.icon-guanbi'); this.spans = this.main.querySelectorAll('.fisrstnav li span:first-child'); } init() { this.updataNode() this.add.onclick = this.addTab.bind(this.add,this); for(var i = 0; i &lt; this.lis.length; i++){ this.lis[i].index = i; this.lis[i].onclick = this.toggleTab.bind(this.list[i],this); this.remove[i].onclick = this.removeTab.bind(this.remove[i],this); this.spans[i].ondblclick = this.editTab; } } clearClass() { for(var i = 0;i &lt; this.lis.length; i++){ this.lis[i].className = ''; this.sections[i].className = ''; } } toggleTab(that) { that.clearClass(); this.className = 'liactive' that.sections[this.index].className = 'conactive' } addTab(that) { // 以前的做法：动态创建元素 createElement ，但是元素里面内容较多，需要 innerHtml 赋值，在 appendChild 追加到父元素里面 // 现在高级做法：利用 insertAdjacentHTML() 可以直接把字符串格式元素添加到父元素中 // appendChild 不支持追加字符串的子元素， insertAdjacentHTML 支持追加字符串元素 var li = '&lt;li class = &quot;liactive&quot;&gt;&lt;span&gt;测试1&lt;/span&gt;&lt;span class= &quot;iconfont icon-gu&quot;&gt;&lt;/span&gt;&lt;/li&gt;' that.ul.insertAdjacentHTML('beforeend',li); that.init() } removeTab(e,that) { e.stopPropagation(); // 阻止冒泡 var index = this.parentNode.index; // 获取父元素的 index that.lis[index].remove(); // remove() 方法可以直接删除指定的元素 that.sections[index].remove(); that.init(); // 当我们删除的不是选中状态的 li 的时候，原来的选中状态 li 保持不变 if(document.querySelector('.liactive')) return; // 当我们删除了选中状态的 li 的时候，让它的前一个 li 处于选定状态 index--; that.lis[index] &amp;&amp; that.lis[index].click() // 手动调用点击事件 } editTab(){ var str = this.innerHTML; // 双击禁止选定文字 window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty() this.innerHTML = '&lt;input type=&quot;text&quot;&gt;'; var input = this.children[0]; input.value = str; input.select(); // 文本框里面的文字处于选定状态 input.onblur = function(){ this.parentNode.innerHTML = this.value; } input.onkeyup = function(e){ if(e.keyCode === 13){ // 手动调用表单失去焦点事件 this.blur() } } }}new Tab(&quot;#tab&quot;) call、apply、bind 总结 相同点： 都可以改变函数呢你不的 this 指向。 区别点： call 和 apply 会调用函数，并且改变函数内部 this 指向。 call 和 apply 传递的参数不一样，call 传递参数 aru1,aru2 … 形式，apply 必须数组形式 [arg] bind 不会调用函数，可以改变函数内部 this 指向。 主要应用场景 call 经常做继承 apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值 bind 不调用函数，但是还想改变 this 指向，比如改变定时器内部的 this 指向 严格模式 严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会忽略。 严格模式对正常的 JavaScript 语义做了一些更改： 消除了 JavaScript 语法的一些不安全之处，保证代码运行的安全。 消除代码运行的一些不安全之处，保证代码运行的安全 提高编译器效率，增加运行速度。 禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 JavaScript 做好铺垫。比如一些保留字如：class，enum,export,extends,import,super 不能做变量名 1.变量 变量必须先声明，然后再使用。 严禁删除已经声明变量，例如 delete x; 语法是错误的。 2.this 指向 全局作用域中函数中的 this 是 undefined。 如果构造函数不加 new 调用，this 会报错。 定时器 this 还是指向 window。 3.函数 函数不能有重名的参数。 不允许在非函数的代码内声明函数。 严格模式可以应用到整个脚本或个别函数中。 1.为脚本开启 12345'use strict'(function(){ 'use strict'})() 2.为函数开启严格模式 123function fn(){ 'use strict'} 高阶函数 高阶函数是对其他函数进行操作的函数，它接受函数作为参数或将函数作为返回值输出。 123456789function fn(callback){ callback &amp;&amp; callback();}fn(function()(alert('h1')));function fn(){ return function}fn() 闭包 闭包指有权访问另一个函数作用域中变量的函数。 闭包的主要作用：延伸了变量的作用范围 12345678910111213141516171819function fn(){ var num = 10; return function (){ console.log(num) }}var f = fn()f()闭包应用 - 点击 li 输出索引号var lis = document.querySelector('.nav').querySelectorAll('li');for(var i = 0; i &lt; lis.length; i++){ (function(i){ lis[i].onclick = function(){ console.log(i); } })(i)} 递归 如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function fn(){ console.log('我要打印') if(num == 6){ return; } num++ fn();} 阶乘function fn(n) { if (n == 1){ return 1; } return n * fn( n - 1);}斐波那契数列function fb(n){ if(n === 1 || n === 2){ return 1; } return fb(n - 1) + fn(n - 2);}function getId(json,id){ json.forEach(funcion(item){ if(item.id == id){ console.log(item) }else if (item.goods &amp;&amp; item.goods.length &gt; 0){ getID(item.goods , id); } })}// 浅克隆var o = {}for (var k in obj){ o[k] = obj[k]}Object.assign({},obj);// 深克隆function deepCopy(newobj,oldobj){ for(var k in oldobj){ var item = oldobj[k]; if(item instanceof Array){ newobj[k] = [] deepCopy(newobj[k],item) }else if(item instanceof Object){ newobj[k] = {} deepCopy(newobj[k],item) }else{ newobj[k] = item } }} 正则表达式 正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象。 1234567891011121314151617181920212223242526272829303132// 1. 利用 RegExp 对象来创建 正则表达式var regexp = new RegExp(/123/);// 2. 利用字面量创建 正则表达var rg = /123/// 3. test 方法用来检测字符串是否符合正则表达式要求的规范 返回布尔类型// 边界符 ^ 开头 $ 结尾 [] 字符类 - 范围 [^] 取反// 量词符 * 相当于 &gt;=0 可以出现 0 次或者很多次// 量词符 + 相当于 &gt;=1 可以出现 1 次或者很多次// 量词符 ? 相当于 1 || 0// {3} 重复 3 次 {3,} 大于等于 3 {3,16} 大于3等于小于等于 16 位// 预定义类 \\d 相当于 [0-9] \\D 相当于 [^0-9] \\w 任意字母、数字、下划线 \\W \\s 匹配空格 \\S/^123$/ // 精准匹配 123[123] // 只要包含其中一个就是 true/^[123]$/ // 1 2 3 皆为true/a-z//a-zA-Z0-9_-/[^a-zA-Z0-9_-]/a*//a+//a?//a{3}//^[^a-zA-Z0-9_-]{6,16}/;/(abc){3}/ abc 重复3次座机号/^\\d{3}-\\d{8}|\\d{4}-\\d{7}$//^\\d{3,4}-\\d{7,8}$/替换 replacevar str = 'andy'var newStr = str.replace(/andy/g,'body'); // g 全局 i 忽略大小写 ES6letlet 声明的变量只在所处于的块级有效。 不存在变量提升 暂时性死区 const具有块级作用域 声明常量时必须赋值。 常量赋值后，值不能修改。 解构赋值1234let [a,b,c] = [1,2,3]// undefindlet {name,age} = { name:'张三',age:'20'}let {name: myName, age: myage} = { name:'张三',age:'20'} 箭头函数箭头函数不绑定 this 关键字，箭头函数中的 this，指向的是函数定义位置的上下文 this。 12345678( ) =&gt; { }var tor = { name: '李华' say: function(){ console.log(this.name) // this 指向 window 对象 {} 不形成作用域 }} 剩余参数1234sum(...args){ args.forEach(item =&gt; item}let [a,...b] = [1,2,3,4,5] 扩展运算符12345678let ary = ['a','b','c']console.log(...ary)// 数组合并let ary1 = [1,2,3,...ary ]console.log(ary1)// 数组合并ary1.push(...ary)// 伪数组转成数组 Array.from()123456789// 伪数组转成真正的数组let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3}let arr2 = Array.from(arrayLike);let arr3 = Array.from(arrayLike,item =&gt; item * 2); 实例方法：find()用于找出第一个符合数组成员，如果没有找到返回 undefined 123456789101112let ary = [ { id: 1, name: '张三' }, { id: 2, name: '李四' }]let target = ary.find(item =&gt; item.id === 2)console.log(target) 实例方法：findIndex()用于找出第一个符合条件的数组成员的位置，如果没有找到返回 -1 123let ary = [1,5,10,15]let index = ary.findIndex((value,index) =&gt; value &gt;9)console.log(index) // 2 实例方法：includes()表示某个数组是否包含给定的值，返回布尔值。 1[1,2,3].includes(2) // true 模板字符串12`12345 ${name}``12345 ${say()}` 实例方法：startsWith() 和 endsWith()startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值 endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值 123let str = 'Hello world!';str.startsWith('Hello'); // truestr.endWith('!') // true 实例方法：repeat()repeat 方法表示将原字符串重复 n 次，返回一个新字符串。 12'x'.repeat(3) // xxx'hello'.repeat(2) // 'hellohello' Set 数据结构ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。 add(value)：添加某个值，返回 Set 结构本身 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 has(value)：返回一个布尔值，表示该值是否为 Set 的成员 clear()：清除所有成员，没有返回值 forEach() 遍历 1234567const s = new Set()const s = new Set([1,2,3,4,4,5])console.log(s.size);s.add('a')s.delete('c')s.has('a')s.clear() 传统网站中存在的问题 网速慢的情况下，页面加载时间长，用户只能等待 表单提交后，如果内容不合格，需要重新填写所有表单内容 页面跳转，重新加载页面，造成资源浪费，增加用户等待时间 Ajax 概述它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验。 应用场景 页面上拉加载更多数据 列表数据无刷新分页 表单填写数据校验 搜索框提示文字下拉列表 运行环境 Ajax 技术需要运行在网站环境中才能生效。 Ajax 的实现步骤 12345678910111213141516171819202122232425// 1、 创建 Ajax 对象var xhr = new XMLHttpRequest();// 2、 请求地址以及请求方式var params = 'username='+ nameValue + '&amp;age=' + ageValue // get 请求方式xhr.open('get','http://www.example.com/get?' + params);// 3、 发送请求xhr.send();// 4、 获取服务器端响应数据xhr.onload = function () { console.log(xhr.responseText);}// postxhr.open('post','http://www.example.com/post');// post 必须 设置请求格式xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')// post 发送请求参数xhr.send(params)// JSON 形式xhr.setRequestHeader('Content-Type','application/json');xhr.send(JSON.stringify({name: 'lisi',age: 50})) ArrayArray.prototype.slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）。原始数组不会被改变。 1234// JavaScript Democonst animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];console.log(animals.slice(2, 4));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;] 描述 如果该元素是个对象引用 （不是实际的对象），slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 如果向两个数组任一中添加了新元素，则另一个不会受到影响。 slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。你只需将该方法绑定到这个对象上。 Object描述 **Object.keys()** 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。 12345var arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2']var obj = { 0: 'a', 1: 'b', 2: 'c' };console.log(Object.keys(obj)); // console: ['0', '1', '2'] assign 相关资料Array.prototype.slice() [视频]2019全新javaScript进阶面向对象ES6√","link":"/2020/12/08/Blog-about-learning-160/"},{"title":"常用工具使用","text":"curl 在命令行或脚本中用于传输数据。postman 基本使用 相关资料curl网站开发指南√curl 的用法指南√ postman raw模拟各种http post请求√","link":"/2020/12/10/Blog-about-learning-161/"},{"title":"Linux 从入门到实践开发","text":"pwd 显示当前目录 显示文件详细信息ll 创建目录 mkdir 目录名称 显示所有文件 ls -a 显示文件内容 cat 文件名 ifconfig ip addr vi /etc/sysconfig/network-script/ifcfg-xx yum install net-tools 相关资料 国内镜像站使用指南 欢迎访问网易开源镜像站","link":"/2020/12/30/Blog-about-learning-162/"},{"title":"","text":"高薪之路—前端面试精选集JavaScript函数定义与调用this 指向1234function printThis(){ return this;}console.log(printThis() === window) 面试注意事项及心态管理","link":"/2021/02/14/Blog-about-learning-163/"},{"title":"计算机网络","text":"相关资料","link":"/2021/03/08/Blog-about-learning-164/"},{"title":"面闭 —— css","text":"display:none 和 visibility:hidden 的区别 display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它周边的元素会靠拢，当它不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 css 中 link 和 @import 的区别是？1、link 属于 html 标签，而 @import 是 css 提供的。 2、页面被加载的时，link 会同时被加载，而 @import 引用的 css 会等到页面被加载完再加载。 3、import 只在 IE5 以上才能识别，而 link 是 html 标签，无兼容问题。 4、link 方式的样式的权重 高于 @import 的 权重 position:absolute 和 float 属性的异同共同点：对内联元素设置 float 和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 不同点：float仍会占据位置，position会覆盖文档流中的其他元素。 介绍下 box-sizing 属性box-sizing 属性主要用来控制元素的盒模型的解析模式。默认值是 content-box。 content-box：让元素维持 W3C 的标准盒模型。元素的宽度/高度由 border + padding + content 的宽度/高度决定，设置 width/height 属性指的是 content 部分的宽/高 border-box：让元素维持 IE 传统盒模型（IE6 以下版本和 IE6~7的怪异模式）。设置 width/hegith 属性指的是 border + padding content css 选择器有哪些？哪些属性可以继承？优先级算法如何计算？css3 新增伪类有哪些？ 1、id 选择器（#） 1、类选择器（.） 1、标签选择器（div） 1、id 选择器 1、id 选择器 1、id 选择器 1、id 选择器 1、id 选择器 相关资料 高频前端开发面试问题√","link":"/2021/03/22/Interview-Question10/"},{"title":"面试官经验总结","text":"如何判断程序员的真实水平 代码能力 工程能力做了什么？为什么要这样做？还有没有更好的办法？来判断项目经历 项目中扮演的什么角色，负责的模块，碰到的问题，解决的思路，达成的效果，以及最后的总结与沉淀。 假的项目 真的实力了解背景、了解方案，深挖方案，模拟场景 项目经历 1、项目概述 2、个人职责 3、项目难点 4、工作成果 有参与过系统的IT 培训学习吗？多长时间？什么机构？通过学习你掌握了什么？ HTML 1、HTML 和 XHTML 有什么区别？HTML是一种基于 Web 页面的设计语言，XHTML 是一种基于 XML、语法严禁、标准的设计语言。两者主要的不同是 XHTML 元素必须正确地嵌套、元素必须关闭，标签必须小写，必须由根元素；HTML没有这些限制。2、严格模式和混杂模式如何区分？如何触发这两种模式？严格模式就是浏览器根据 Web 标准去解析页面的方法，是一种要求严格的 DTD 不允许使用任何表现层的语法；混杂模式是一种向后兼容的解析方式。触发严格模式或者标准模式很简单，就是在HTML 标签前声明正确的 DTD。触发混杂模式可以在 HTML 文档开始时不声明 DTD,或者在 DOCTYPE 前加入 XML 声明。 CSS1、CSS自适应的单位都有哪些？em、rem、vh、vw。2、rgba()和opacity 的透明效果有什么不同？ 回流、重绘 JS1、说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量，闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当容器造成内存泄露。特性：函数嵌套函数在函数内部可以引用外部的参数和变量参数和变量不会以垃圾回收机制回收。 2、函数声明与函数表达式的区别？在 JavaScript 中，在向执行环境中加载数据时，解析器对函数声明和函数表达式并非是一视同仁。解析器会首先读取函数声明。并使他在执行任何代码之前可用。至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正解析和执行它。 3、什么是事件委托 4、防抖和节流 vue1、ref 属性有什么作用？获取实例 2、v-if和v-show 的区别 3、如何解决数据更新但是视图未更新？ 4、vue声明周期 面向对象 面向对象的特性有哪些？抽象封装继承多态 你对ES6了解多少？版本管理工具？webpack 的使用常用 loader 有哪些？使用 gulp 实现了哪些功能？ 1、在移动端，单击穿透是什么？什么情况下会出现单击穿透？怎么解决单击穿透？2、如何解决移动端 click 时间有 300 ms 的延迟问题？ 项目权限验证？路由条件跳转？app 应用是？混编还是原生app ？怎么实现的？ cavnas、HTML语义化、CSS 盒模型、JSX、 promise all 循序执行 数字 MVC 1.vueAPP适配是怎么写的，用的什么单位？2.get和post有什么区别？3.计算属性和监听器有什么区别？4.v-for渲染列表是key是用来做什么的？5.数据请求在生命周期哪一个阶段？6.水平居中有哪几种方法？7.flex弹性盒模型？8.父盒子中子盒子浮动有什么后果？9.清除浮动有哪些方法？10.定位有哪些属性？相对定位是相对什么定位？11.行没元素和行内块元素有什么区别？行内块元素在同一行显示时有默认空隙，如何解决？12.给DOM元素绑定事件有哪些方法？13.数组里面有哪些遍历方法？es6 ##CSS###1.一个盒子垂直水平居中有哪些方法？（2~3种方法）space-bettewn属性###2.flex怎么使用，flex:1代表了什么（三个属性）###3.使用自适应布局的时候用rem,为什么可以实现自适应布局，在不同的手机端表现得是什么rem是基于html的字体大小来进行布局的（问：不同的移动端是有不同的html字体大小吗，在拿到设计图是怎么计算的）除以16px(问：16px是基于什么来的)##4.http计算机基础相关三次握手四次挥手常见状态码##vueaxios的底层是怎么实现的，用什么实现的（配套AJAX问题）###5.vue的生命周期mounted和created的区别：created的时候，他的html的节点都没有渲染出来mounted的时候，可以进行数据请求，进行数据绑定（此时HTML的结构已经出来了，可以将数据绑定到DOM结构上）###6.组件传值分为（父传子、子传父、兄弟组件之间传值）###7.keep-alive是怎么使用的缓存、会多出来几个生命周期###8.VUE双向绑定的原理数据劫持objectDefinePropoty数据劫持之后，通过发布订阅模式##JS###9.跨域是有哪几种方式实现的（什么是跨域，限制了什么，不同源的话会进行什么策略）跨域的方式有：jsonP、nigix的代理、websocket以及php端修改header。代理设置了location的哪一项？websocket是怎么进行跨域的？php修改header为很么修改了就想能跨域了？###10.this指向普通函数和箭头函数的this，以及怎么改变普通函数里的this指向###11.apply、call、bind,区别apply怎样实现bind##ES6###12.promise和async await有什么区别await有什么特点这两个方法报错了怎么抓取###13.ES6的新特性有哪些promise async await class继承、解构赋值定义const、var、let、箭头函数###14.let、var、const的区别const定义的对象是可以改变的（定义的是指向对象的地址） 99乘法表","link":"/2021/03/18/Interview-Question9/"},{"title":"JavaScript 设计模式","text":"第一篇 面向对象编程 面向对象编程（Object-oriented programming,oop）是一种程序设计范型。它将对象作为程序的基本单元，将程序和数据封装其中，以提高程序的重用性、灵活性和扩展性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169function checkName(){ // 验证姓名}function checkEmail(){ // 验证邮箱 }function checkPassword(){ // 验证密码 }/* * 函数的另一种形式 * 声明了3个全局变量 * 互相覆盖不易察觉 */var checkName = function (){ // 验证姓名}var checkEmail = function (){ // 验证邮箱 }var checkPassword = function (){ // 验证密码 }/* * 存放在一个变量里，减少覆盖风险。 */var checkobject = { checkName: function(){ // 验证姓名 }, checkEmail: function(){ // 验证邮箱 }, checkPassword: function(){ // 验证密码 }}/* * JavaScript 中函数也是对象。 * 无法继承 */var checkobject = function(){};checkobject.checkName = function(){ // 验证姓名 }checkobject.checkEmail = function(){ // 验证邮箱 },checkobject.checkPassword = function(){ // 验证密码 }/* * 返回新的对象 使用互不影响 */var checkobject = function (){ return { checkName: function(){ // 验证姓名 }, checkEmail: function(){ // 验证邮箱 }, checkPassword: function(){ // 验证密码 } }}var a = checkobject();a.checkEmail()/* * 这样做造成的消耗是奢侈的 */var ckeckobject = function (){ this.checkName: function(){ // 验证姓名 }, this.checkEmail: function(){ // 验证邮箱 }, this.checkPassword: function(){ // 验证密码 }}var a = new ckeckobject();a.checkEmail();/* * 这样创建对象实例的时候，创建出来的对象所拥有的方法就都是一个了。因为它们都要依赖 prototype 原型依次寻找，而 * 找到的方法都是同一个，它们都绑定在 checkObject 对象类的原型上。 * 这种方式要将 prototype 写很多遍。 */var checkobject = function (){ checkobject.prototype.checkName: function(){ // 验证姓名 }, ckeckobject.prototype.checkEmail: function(){ // 验证邮箱 }, ckeckobject.prototype.checkPassword: function(){ // 验证密码 }}/* * 这两种方式不能混着用，如在后面为对象的原型赋值新对象时，那么它将会覆盖掉之前 prototype 对象赋值的方法 */var checkobject = function (){}checkobject.prototype={ checkName: function(){ // 验证姓名 }, checkEmail: function(){ // 验证邮箱 }, checkPassword: function(){ // 验证密码 }}var a = new checkobject();a.checkName();a.checkEmail();a.checkPassword();/* * 避免 a 书写 3遍 * 那么就要在声明的每个方法末尾处将当前对象返回，在 JavaScript 中 this 指向的就是当前对象，所以你可以将它返回。 */var checkobject = { checkName: function(){ // 验证姓名 return this; } checkEmail: function(){ // 验证邮箱 return this; } checkPassword: function(){ // 验证密码 return this; }}checkobject.checkName().checkEmail().checkPassword();var checkobject = function (){}checkobject.prototype={ checkName: function(){ // 验证姓名 return this; }, checkEmail: function(){ // 验证邮箱 return this; }, checkPassword: function(){ // 验证密码 return this; }}var a = new checkobject()a.checkName.checkEmail().checkPassword(); prototype.js","link":"/2020/11/28/Book15/"},{"title":"面闭 — 浏览器","text":"一个页面从输入 url 到页面加载完成，这个过程中发生了什么？4个步骤 (1) 当发送一个 url 请求时，不管这个 url 是 web 页面的 url 还是 web 页面上每个资源的 url，浏览器都会开启一个线程来处理这个请求，同时远程 NDS 服务器上启动一个 NDS 查询。这能使浏览器获得请求对应的 IP 地址。 (2) 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递，该握手首先由客户端尝试建立起通信，而后服务器应答接受客户端的请求，最后由客户端发出该请求已经被接受的报文 (3) 一旦 TCP/IP 链接建立，浏览器会通过链接向远程发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应 (4) 此时，web 服务器提供资源服务，客户端开始下载资源。 浏览器同源策略同源策略是客户端脚本（尤其是 JavaScript）的重要安全度量标准。它最早出自 Netscape Navigator 2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指得是 协议，域名，端口相同，同源策略是一种安全协议，指一端脚本只能读取来自同一源的窗口和文档的属性。 如何解决跨域问题理解跨域的概念：协议、端口、域名都相同才同域，否则都是跨域 出于安全考虑，浏览器不允许 ajax 跨域获取数据，但是可以跨域获取文件内容，所以基于这个一点，可以动态创建 script 标签，使用标签的 src 属性访问 js 文件的形式获取 js 脚本，并且这个 js 脚本中的内容是函数调用，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面定义回调函数，在回调函数中处理服务器返回的数据。这就是 JSONP 相关资料","link":"/2021/05/11/Interview-Question11/"},{"title":"开源项目——微信小程序","text":"1、自定义 tabBar 使用官方小程序示例中的 自定义 tabBar 2、引入字体图标 使用 在线 url 将字体 url 转成 base64 的格式后使用出现问题…… 3、API Promise化 使用官方 扩展能力 API Promise化 miniprogram-api-promise 工具 4、封装接口 参考下面文档接合下 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 同时发送异步代码的次数let ajaxTimes=0;export const request=(params)=&gt;{ // 判断 url中是否带有 /my/ 请求的是私有的路径 带上header token let header={...params.header}; if(params.url.includes(&quot;/my/&quot;)){ // 拼接header 带上token header[&quot;Authorization&quot;]=wx.getStorageSync(&quot;token&quot;); } ajaxTimes++; // 显示加载中 效果 wx.showLoading({ title: &quot;加载中&quot;, mask: true }); // 定义公共的url const baseUrl=&quot;https://api.zbztb.cn/api/public/v1&quot;; return new Promise((resolve,reject)=&gt;{ wx.request({ ...params, header:header, url:baseUrl+params.url, success:(result)=&gt;{ resolve(result.data.message); }, fail:(err)=&gt;{ reject(err); }, complete:()=&gt;{ ajaxTimes--; if(ajaxTimes===0){ // 关闭正在等待的图标 wx.hideLoading(); } } }); })}// 使用import { request } from &quot;../../request/index.js&quot;;request({url:&quot;/goods/search&quot;,data:this.QueryParams}).then(res=&gt;{ console.log(res);})// 代码来源黑马 强烈推介的几个微信小程序开发小技巧，简单又实用 5、状态管理 用官方 扩展能力 架构扩展中的 mobx-miniprogram 6、封装组件库 参考 vant 封装 icon、官方指南中自定义组件 4、重写小程序的路由api 设置白名单 tonken 校验。 10、分包 以上是我对下列视频及文章的归纳和总结 Three.js和其它webgl框架CreateJS 新司机开车指南√","link":"/2020/08/04/Blog-about-learning-4/"},{"title":"关于微信小程序的书籍集合","text":"《小程序开发原理与实战》开发 app 1、不菲的开发成本 2、高昂的推广成本 3、高昂的维系成本 开发小程序 1、计算能力不足 2、灵活性不足 3、有一定的局限性 三种运行载体的快速对比 运行载体 运行环境 功能性 便捷性 交互体验 开发成本 推广难度 消息推送 公众号 H5 简单 无需安装 一般 低 低 支持 小程序 微信 轻应用 无需安装 接近原生 App 中 低 受限 App 原生系统 丰富 需要安装 最流畅 高 高 支持 场景值 利用场景值做数值统计 例如：场景 1129 （微信爬虫访问）可以用来对爬虫做一些优化，方便索引；场景 1038（从另一个小程序返回）可以用来对小程序免密签约的场景进行判断。 可以在 App 的 onLaunch 和 onShow 中 options.scene 或 wx.getLaunchOptionsSync 中获取上述场景值。 小程序生命周期的注册 （1）App() 必须在 app.js 中注册，不可以在 App()函数内或在定义 App() 函数前调用 getApp()方法; （2）通过 getApp() 方法获取实例后，不可以私自调用生命周期函数。 Page 的 prototype 中还注册了 data 属性、route 属性、setData()方法。 12this.route // 获取当前所处的页面getCurrentPage() // 获取当前页面的实例 data 会以 JSON 的形式由逻辑层传至渲染层，所以数据必须可以转换 JSON 的格式：字符串、数字、布尔值、对象、数组。 this.setData() 仅支持可 JSON 化的数据（即字符串、数字、布尔值、对象、数组）。单次设置的数据不能超过 1024 KB，尽量避免一次设置过多的数据。 全局变量使用 12345678// app.jsApp({ globalData : 1})// a.jsvar app = getAppp()app.globalData++ 小程序页面栈的表现形式 路由方式 页面栈变化 老页面生命周期变化 新页面生命周期变化 初始化 新页面入栈 无 onLoad()、onShow() 打开新页面 新页面入栈 onHide() onLoad()、onShow() 页面重定向 当前页面出栈，新页面入栈 onUnload() onLoad()、onShow() 页面返回 页面不断出栈，直到目标返回页 onUnload() onShow() tab 切换 页面全部出栈，只留下新的 tab 页面 视具体情况而定 视具体情况而定 重加载 页面全部出栈，只留下新的页面 onUnload() onLoad()、onShow() 注意事项 （1）navigateTo、redirectTo 只能打开非 tabBar 页面。 （2）switchTab 只能打开 tabBar 页面，但是不能传递参数。 （3）reLaunch 可以打开任意页面 （4）页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。 （5）调用页面路由带的参数可以在目标页面的 onLoad 中获取。 12345678910// common.jsfunction sayHello (name) { console.log(`Hello ${name}!`)}function sayGoodbye (name) { console.log(`Goodbye ${name}!`)}module.exports.sayHello = sayHelloexports.sayGoodbye = sayGoodbye 123456789var common = require('common.js')Page({ helloMINA: function(){ common.sayHello('MINA') }, goodbyeMINA: function(){ common.sayGoodbye('MINA') }}) 注意事项 （1）exports 是 module.exports 的一个引用，在模块里随便更改 exports 的指向会造成未知的错误。推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰地知道两者之间的关系。 （2）小程序目前不支持直接引入 node_modules ，建议开发者在需要使用 node_modules 时复制相关的代码到小程序的目录中，或者使用小程序支持的 npm 功能。 api 分为事件监听类、同步执行类、异步执行类。 封装 api 接口 12345678let getImageInfoPromise = new Promise(function(resole,reject){ wx.getImageInfo({ src: '', success: function(res) { resolve(res); } })}) 组件 scroll-view 在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中 滚动是无法触发 onPullDownRefresh 的。 若要使用下拉刷新，请使用页面的滚动，而不是 scroll-view，这样也能通过点击顶部状态栏回到页面顶部。 WXSS 在特殊机型（例如 iphoneX、iphone 11）中，因为取消了物理按键，会出现手机底部区域被手机底部的小黑条遮挡的情况，此时可以使用 padding-bottom: env(safe-area-inset-bottom)来告诉微信进行自动适配。 1、清除浮动的元素本身不能为浮动元素 2、清除浮动的元素本身必须是块级元素。 相对定位，相对的是原来的位置，但原来所占的空间仍然保留。 实战：商城类项目开发 项目目录结构 components 目录：主要用来存放一些自定义组件相关的内容 images 目录：主要用来存放商城用到的图片信息等 libs 目录：主要用来存放商城项目中依赖的第三方库。 models 目录：主要用来封装与后台进行交互的 model 操作类。 pages 目录：主要用来存放商城要用到的各个具体页面，里面的每个不同的子目录都代表一个独立页面，分别包含与目录同名的 wxml、wxss、js、和 json 文件。 utils 目录：主要用来存放商城开发过程中要使用到的各种工具类，避免重复代码。 app.js：小程序主逻辑入口。 app.json：小程序全局配置文件。 app.wxss：小程序公共样式表。 wxss 文件不支持使用本地图片作为资源 双列效果 12345678910111213.djbox { float: left; margin: 0 0 1%; width: 49.5%; box-sizing: border-box; min-height: 240px; postion: relative; background: #fff;}.djbox:nth-child(odd){ margin-right: 1%;} 《小程序，巧应用：微信小程序开发实战（第2版）》 相关资料 小程序开发原理与实战","link":"/2020/03/21/Book16/"}],"tags":[{"name":"article","slug":"article","link":"/tags/article/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"vlog","slug":"vlog","link":"/tags/vlog/"},{"name":"前端学习路线","slug":"前端学习路线","link":"/tags/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"},{"name":"图谱","slug":"图谱","link":"/tags/%E5%9B%BE%E8%B0%B1/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"App","slug":"App","link":"/tags/App/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"开源项目","slug":"开源项目","link":"/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"免费视频教程","slug":"免费视频教程","link":"/tags/%E5%85%8D%E8%B4%B9%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B/"},{"name":"学习工具","slug":"学习工具","link":"/tags/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/"},{"name":"直播公开课","slug":"直播公开课","link":"/tags/%E7%9B%B4%E6%92%AD%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"软件","slug":"软件","link":"/tags/%E8%BD%AF%E4%BB%B6/"},{"name":"Electron","slug":"Electron","link":"/tags/Electron/"},{"name":"桌面","slug":"桌面","link":"/tags/%E6%A1%8C%E9%9D%A2/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"防抖","slug":"防抖","link":"/tags/%E9%98%B2%E6%8A%96/"},{"name":"节流","slug":"节流","link":"/tags/%E8%8A%82%E6%B5%81/"},{"name":"Vuex","slug":"Vuex","link":"/tags/Vuex/"},{"name":"Vue Router","slug":"Vue-Router","link":"/tags/Vue-Router/"},{"name":"learning","slug":"learning","link":"/tags/learning/"},{"name":"Vue CLI","slug":"Vue-CLI","link":"/tags/Vue-CLI/"},{"name":"SSR","slug":"SSR","link":"/tags/SSR/"},{"name":"nuxt.js","slug":"nuxt-js","link":"/tags/nuxt-js/"},{"name":"JavaScript 技巧","slug":"JavaScript-技巧","link":"/tags/JavaScript-%E6%8A%80%E5%B7%A7/"},{"name":"if-else","slug":"if-else","link":"/tags/if-else/"},{"name":"cookie","slug":"cookie","link":"/tags/cookie/"},{"name":"localStorage","slug":"localStorage","link":"/tags/localStorage/"},{"name":"Web SQL","slug":"Web-SQL","link":"/tags/Web-SQL/"},{"name":"IndexedDB","slug":"IndexedDB","link":"/tags/IndexedDB/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Nuxt","slug":"Nuxt","link":"/tags/Nuxt/"},{"name":"uniapp","slug":"uniapp","link":"/tags/uniapp/"},{"name":"Hybrid App","slug":"Hybrid-App","link":"/tags/Hybrid-App/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"React Native","slug":"React-Native","link":"/tags/React-Native/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Serverless","slug":"Serverless","link":"/tags/Serverless/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"Koa2","slug":"Koa2","link":"/tags/Koa2/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"JavaScript 库","slug":"JavaScript-库","link":"/tags/JavaScript-%E5%BA%93/"},{"name":"CSS 库","slug":"CSS-库","link":"/tags/CSS-%E5%BA%93/"},{"name":"技巧","slug":"技巧","link":"/tags/%E6%8A%80%E5%B7%A7/"},{"name":"精华","slug":"精华","link":"/tags/%E7%B2%BE%E5%8D%8E/"},{"name":"大屏","slug":"大屏","link":"/tags/%E5%A4%A7%E5%B1%8F/"},{"name":"可视化","slug":"可视化","link":"/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"图表库","slug":"图表库","link":"/tags/%E5%9B%BE%E8%A1%A8%E5%BA%93/"},{"name":"适配","slug":"适配","link":"/tags/%E9%80%82%E9%85%8D/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"文件预览","slug":"文件预览","link":"/tags/%E6%96%87%E4%BB%B6%E9%A2%84%E8%A7%88/"},{"name":"token","slug":"token","link":"/tags/token/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"VSCode 插件","slug":"VSCode-插件","link":"/tags/VSCode-%E6%8F%92%E4%BB%B6/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"微前端","slug":"微前端","link":"/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"umi","slug":"umi","link":"/tags/umi/"},{"name":"qiankun","slug":"qiankun","link":"/tags/qiankun/"},{"name":"接口","slug":"接口","link":"/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"API","slug":"API","link":"/tags/API/"},{"name":"Ionic","slug":"Ionic","link":"/tags/Ionic/"},{"name":"vscode 扩展","slug":"vscode-扩展","link":"/tags/vscode-%E6%89%A9%E5%B1%95/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"NativeScript","slug":"NativeScript","link":"/tags/NativeScript/"},{"name":"Cordova","slug":"Cordova","link":"/tags/Cordova/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Tensorflow.js","slug":"Tensorflow-js","link":"/tags/Tensorflow-js/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"DOM","slug":"DOM","link":"/tags/DOM/"},{"name":"Babel","slug":"Babel","link":"/tags/Babel/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"单位","slug":"单位","link":"/tags/%E5%8D%95%E4%BD%8D/"},{"name":"Gulp","slug":"Gulp","link":"/tags/Gulp/"},{"name":"liveStyle","slug":"liveStyle","link":"/tags/liveStyle/"},{"name":"liveReload","slug":"liveReload","link":"/tags/liveReload/"},{"name":"BrowserSync","slug":"BrowserSync","link":"/tags/BrowserSync/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"H5","slug":"H5","link":"/tags/H5/"},{"name":"直播","slug":"直播","link":"/tags/%E7%9B%B4%E6%92%AD/"},{"name":"Weex","slug":"Weex","link":"/tags/Weex/"},{"name":"realworld","slug":"realworld","link":"/tags/realworld/"},{"name":"JS 库","slug":"JS-库","link":"/tags/JS-%E5%BA%93/"},{"name":"组件封装","slug":"组件封装","link":"/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"name":"PWA","slug":"PWA","link":"/tags/PWA/"},{"name":"fetch","slug":"fetch","link":"/tags/fetch/"},{"name":"promise","slug":"promise","link":"/tags/promise/"},{"name":"http-server","slug":"http-server","link":"/tags/http-server/"},{"name":"serve","slug":"serve","link":"/tags/serve/"},{"name":"book","slug":"book","link":"/tags/book/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"项目部署","slug":"项目部署","link":"/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"腾讯云","slug":"腾讯云","link":"/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"Uint8Array","slug":"Uint8Array","link":"/tags/Uint8Array/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"私活","slug":"私活","link":"/tags/%E7%A7%81%E6%B4%BB/"},{"name":"开发者","slug":"开发者","link":"/tags/%E5%BC%80%E5%8F%91%E8%80%85/"},{"name":"职业","slug":"职业","link":"/tags/%E8%81%8C%E4%B8%9A/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"反编译","slug":"反编译","link":"/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"name":"phpstudy","slug":"phpstudy","link":"/tags/phpstudy/"},{"name":"代码审查","slug":"代码审查","link":"/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E6%9F%A5/"},{"name":"Android Studio","slug":"Android-Studio","link":"/tags/Android-Studio/"},{"name":"utils","slug":"utils","link":"/tags/utils/"},{"name":"MUI","slug":"MUI","link":"/tags/MUI/"},{"name":"HTML5 + Specification","slug":"HTML5-Specification","link":"/tags/HTML5-Specification/"},{"name":"公开课","slug":"公开课","link":"/tags/%E5%85%AC%E5%BC%80%E8%AF%BE/"},{"name":"直播课","slug":"直播课","link":"/tags/%E7%9B%B4%E6%92%AD%E8%AF%BE/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"请求缓存","slug":"请求缓存","link":"/tags/%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"JSON","slug":"JSON","link":"/tags/JSON/"},{"name":"测试框架","slug":"测试框架","link":"/tags/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/"},{"name":"WordPress","slug":"WordPress","link":"/tags/WordPress/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Discuz","slug":"Discuz","link":"/tags/Discuz/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"GitLab","slug":"GitLab","link":"/tags/GitLab/"},{"name":"Gitblit","slug":"Gitblit","link":"/tags/Gitblit/"},{"name":"SVN","slug":"SVN","link":"/tags/SVN/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Vue.js","slug":"Vue-js","link":"/tags/Vue-js/"},{"name":"uni-app","slug":"uni-app","link":"/tags/uni-app/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"快应用","slug":"快应用","link":"/tags/%E5%BF%AB%E5%BA%94%E7%94%A8/"},{"name":"uniCloud","slug":"uniCloud","link":"/tags/uniCloud/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Egg","slug":"Egg","link":"/tags/Egg/"},{"name":"Vant","slug":"Vant","link":"/tags/Vant/"},{"name":"代码库","slug":"代码库","link":"/tags/%E4%BB%A3%E7%A0%81%E5%BA%93/"},{"name":"ES8","slug":"ES8","link":"/tags/ES8/"},{"name":"注释","slug":"注释","link":"/tags/%E6%B3%A8%E9%87%8A/"},{"name":"JSDoc","slug":"JSDoc","link":"/tags/JSDoc/"},{"name":"观察者模式","slug":"观察者模式","link":"/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"发布-订阅模式","slug":"发布-订阅模式","link":"/tags/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"慕课网","slug":"慕课网","link":"/tags/%E6%85%95%E8%AF%BE%E7%BD%91/"},{"name":"入门","slug":"入门","link":"/tags/%E5%85%A5%E9%97%A8/"},{"name":"专栏","slug":"专栏","link":"/tags/%E4%B8%93%E6%A0%8F/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"socketio","slug":"socketio","link":"/tags/socketio/"},{"name":"Hybrid","slug":"Hybrid","link":"/tags/Hybrid/"},{"name":"target","slug":"target","link":"/tags/target/"},{"name":"理财","slug":"理财","link":"/tags/%E7%90%86%E8%B4%A2/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"prepare","slug":"prepare","link":"/tags/prepare/"},{"name":"性","slug":"性","link":"/tags/%E6%80%A7/"},{"name":"心态","slug":"心态","link":"/tags/%E5%BF%83%E6%80%81/"},{"name":"meteor","slug":"meteor","link":"/tags/meteor/"},{"name":"json-server","slug":"json-server","link":"/tags/json-server/"},{"name":"学习方法","slug":"学习方法","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"学习技巧","slug":"学习技巧","link":"/tags/%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7/"},{"name":"囚徒健身","slug":"囚徒健身","link":"/tags/%E5%9B%9A%E5%BE%92%E5%81%A5%E8%BA%AB/"},{"name":"肌肉完全训练计划","slug":"肌肉完全训练计划","link":"/tags/%E8%82%8C%E8%82%89%E5%AE%8C%E5%85%A8%E8%AE%AD%E7%BB%83%E8%AE%A1%E5%88%92/"},{"name":"工作环境","slug":"工作环境","link":"/tags/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"},{"name":"work","slug":"work","link":"/tags/work/"},{"name":"创业","slug":"创业","link":"/tags/%E5%88%9B%E4%B8%9A/"},{"name":"团队","slug":"团队","link":"/tags/%E5%9B%A2%E9%98%9F/"},{"name":"job","slug":"job","link":"/tags/job/"},{"name":"specialty","slug":"specialty","link":"/tags/specialty/"},{"name":"成长","slug":"成长","link":"/tags/%E6%88%90%E9%95%BF/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"图片格式","slug":"图片格式","link":"/tags/%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"},{"name":"music","slug":"music","link":"/tags/music/"},{"name":"mork","slug":"mork","link":"/tags/mork/"},{"name":"测试","slug":"测试","link":"/tags/%E6%B5%8B%E8%AF%95/"},{"name":"数据分析","slug":"数据分析","link":"/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"网站","slug":"网站","link":"/tags/%E7%BD%91%E7%AB%99/"},{"name":"科学上网","slug":"科学上网","link":"/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"码云","slug":"码云","link":"/tags/%E7%A0%81%E4%BA%91/"},{"name":"命令行工具","slug":"命令行工具","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"momentjs","slug":"momentjs","link":"/tags/momentjs/"},{"name":"库","slug":"库","link":"/tags/%E5%BA%93/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"vue Cli","slug":"vue-Cli","link":"/tags/vue-Cli/"},{"name":"vuex","slug":"vuex","link":"/tags/vuex/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"一篇汇总","slug":"一篇汇总","link":"/tags/%E4%B8%80%E7%AF%87%E6%B1%87%E6%80%BB/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"},{"name":"vue router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"pwa","slug":"pwa","link":"/tags/pwa/"},{"name":"socket.io","slug":"socket-io","link":"/tags/socket-io/"},{"name":"weapp.socket.io","slug":"weapp-socket-io","link":"/tags/weapp-socket-io/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"centOS","slug":"centOS","link":"/tags/centOS/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"VirtualBox","slug":"VirtualBox","link":"/tags/VirtualBox/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"tween.js","slug":"tween-js","link":"/tags/tween-js/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"Koa","slug":"Koa","link":"/tags/Koa/"},{"name":"webgl","slug":"webgl","link":"/tags/webgl/"},{"name":"pixi.js","slug":"pixi-js","link":"/tags/pixi-js/"},{"name":"create.js","slug":"create-js","link":"/tags/create-js/"},{"name":"开源","slug":"开源","link":"/tags/%E5%BC%80%E6%BA%90/"}],"categories":[{"name":"vlog","slug":"vlog","link":"/categories/vlog/"},{"name":"article","slug":"vlog/article","link":"/categories/vlog/article/"},{"name":"industry","slug":"industry","link":"/categories/industry/"},{"name":"News","slug":"industry/News","link":"/categories/industry/News/"},{"name":"learning","slug":"learning","link":"/categories/learning/"},{"name":"GitHub","slug":"learning/GitHub","link":"/categories/learning/GitHub/"},{"name":"小程序","slug":"learning/小程序","link":"/categories/learning/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"JavaScript","slug":"learning/JavaScript","link":"/categories/learning/JavaScript/"},{"name":"移动端","slug":"learning/移动端","link":"/categories/learning/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"Vue","slug":"learning/Vue","link":"/categories/learning/Vue/"},{"name":"Hybrid App","slug":"learning/Hybrid-App","link":"/categories/learning/Hybrid-App/"},{"name":"CSS","slug":"learning/CSS","link":"/categories/learning/CSS/"},{"name":"Node","slug":"learning/Node","link":"/categories/learning/Node/"},{"name":"react","slug":"learning/react","link":"/categories/learning/react/"},{"name":"PHP","slug":"learning/PHP","link":"/categories/learning/PHP/"},{"name":"JS 框架","slug":"learning/JS-框架","link":"/categories/learning/JS-%E6%A1%86%E6%9E%B6/"},{"name":"Web","slug":"learning/Web","link":"/categories/learning/Web/"},{"name":"HTML&amp;&amp;CSS","slug":"learning/HTML-CSS","link":"/categories/learning/HTML-CSS/"},{"name":"其他","slug":"learning/其他","link":"/categories/learning/%E5%85%B6%E4%BB%96/"},{"name":"jQuery","slug":"learning/jQuery","link":"/categories/learning/jQuery/"},{"name":"UI 框架","slug":"learning/UI-框架","link":"/categories/learning/UI-%E6%A1%86%E6%9E%B6/"},{"name":"版本管理","slug":"learning/版本管理","link":"/categories/learning/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"前端优化","slug":"learning/前端优化","link":"/categories/learning/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"},{"name":"JS 库","slug":"learning/JS-库","link":"/categories/learning/JS-%E5%BA%93/"},{"name":"设计模式","slug":"learning/设计模式","link":"/categories/learning/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"后端","slug":"learning/后端","link":"/categories/learning/%E5%90%8E%E7%AB%AF/"},{"name":"调试","slug":"learning/调试","link":"/categories/learning/%E8%B0%83%E8%AF%95/"},{"name":"Hybrid","slug":"learning/Hybrid","link":"/categories/learning/Hybrid/"},{"name":"读书","slug":"vlog/读书","link":"/categories/vlog/%E8%AF%BB%E4%B9%A6/"},{"name":"面试","slug":"learning/面试","link":"/categories/learning/%E9%9D%A2%E8%AF%95/"},{"name":"prepare","slug":"vlog/prepare","link":"/categories/vlog/prepare/"},{"name":"课程","slug":"vlog/课程","link":"/categories/vlog/%E8%AF%BE%E7%A8%8B/"},{"name":"artcle","slug":"vlog/artcle","link":"/categories/vlog/artcle/"},{"name":"健身","slug":"vlog/健身","link":"/categories/vlog/%E5%81%A5%E8%BA%AB/"},{"name":"其他","slug":"vlog/其他","link":"/categories/vlog/%E5%85%B6%E4%BB%96/"},{"name":"movie","slug":"vlog/movie","link":"/categories/vlog/movie/"},{"name":"music","slug":"vlog/music","link":"/categories/vlog/music/"},{"name":"utils","slug":"utils","link":"/categories/utils/"},{"name":"API","slug":"utils/API","link":"/categories/utils/API/"},{"name":"utils","slug":"utils/utils","link":"/categories/utils/utils/"},{"name":"测试","slug":"utils/测试","link":"/categories/utils/%E6%B5%8B%E8%AF%95/"},{"name":"utils","slug":"vlog/utils","link":"/categories/vlog/utils/"},{"name":"web","slug":"utils/web","link":"/categories/utils/web/"}]}